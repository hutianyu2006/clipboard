<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script type="text/javascript">
        "use strict"; (function (root, factory) { (typeof module === 'object' && module.exports) ? module.exports = factory() : root.IpfsHttpClient = factory() }(typeof self !== 'undefined' ? self : this, function () {
            var IpfsHttpClient = (() => {
                var Ad = Object.create; var Er = Object.defineProperty; var vd = Object.getOwnPropertyDescriptor; var Bd = Object.getOwnPropertyNames; var Id = Object.getPrototypeOf, _d = Object.prototype.hasOwnProperty; var _s = (e => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, { get: (t, r) => (typeof require != "undefined" ? require : t)[r] }) : e)(function (e) { if (typeof require != "undefined") return require.apply(this, arguments); throw new Error('Dynamic require of "' + e + '" is not supported') }); var k = (e, t) => () => (e && (t = e(e = 0)), t); var D = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), F = (e, t) => { for (var r in t) Er(e, r, { get: t[r], enumerable: !0 }) }, ks = (e, t, r, n) => { if (t && typeof t == "object" || typeof t == "function") for (let o of Bd(t)) !_d.call(e, o) && o !== r && Er(e, o, { get: () => t[o], enumerable: !(n = vd(t, o)) || n.enumerable }); return e }; var S = (e, t, r) => (r = e != null ? Ad(Id(e)) : {}, ks(t || !e || !e.__esModule ? Er(r, "default", { value: e, enumerable: !0 }) : r, e)), xr = e => ks(Er({}, "__esModule", { value: !0 }), e); function Rs(e, t, r) { t = t || [], r = r || 0; for (var n = r; e >= Fd;)t[r++] = e & 255 | Us, e /= 128; for (; e & Ld;)t[r++] = e & 255 | Us, e >>>= 7; return t[r] = e | 0, Rs.bytes = r - n + 1, t } function Un(e, n) { var r = 0, n = n || 0, o = 0, s = n, i, a = e.length; do { if (s >= a) throw Un.bytes = 0, new RangeError("Could not decode varint"); i = e[s++], r += o < 28 ? (i & Ns) << o : (i & Ns) * Math.pow(2, o), o += 7 } while (i >= jd); return Un.bytes = s - n, r } var Rd, Us, Od, Ld, Fd, $d, jd, Ns, zd, Md, qd, Hd, Vd, Gd, Wd, Jd, Kd, Xd, Qd, Zd, qt, Os = k(() => { Rd = Rs, Us = 128, Od = 127, Ld = ~Od, Fd = Math.pow(2, 31); $d = Un, jd = 128, Ns = 127; zd = Math.pow(2, 7), Md = Math.pow(2, 14), qd = Math.pow(2, 21), Hd = Math.pow(2, 28), Vd = Math.pow(2, 35), Gd = Math.pow(2, 42), Wd = Math.pow(2, 49), Jd = Math.pow(2, 56), Kd = Math.pow(2, 63), Xd = function (e) { return e < zd ? 1 : e < Md ? 2 : e < qd ? 3 : e < Hd ? 4 : e < Vd ? 5 : e < Gd ? 6 : e < Wd ? 7 : e < Jd ? 8 : e < Kd ? 9 : 10 }, Qd = { encode: Rd, decode: $d, encodingLength: Xd }, Zd = Qd, qt = Zd }); var Ht, ht, gt, Ar = k(() => { Os(); Ht = e => [qt.decode(e), qt.decode.bytes], ht = (e, t, r = 0) => (qt.encode(e, t, r), t), gt = e => qt.encodingLength(e) }); var Sb, Ls, De, Fs, $s, Me = k(() => { Sb = new Uint8Array(0), Ls = (e, t) => { if (e === t) return !0; if (e.byteLength !== t.byteLength) return !1; for (let r = 0; r < e.byteLength; r++)if (e[r] !== t[r]) return !1; return !0 }, De = e => { if (e instanceof Uint8Array && e.constructor.name === "Uint8Array") return e; if (e instanceof ArrayBuffer) return new Uint8Array(e); if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength); throw new Error("Unknown type, must be binary type") }, Fs = e => new TextEncoder().encode(e), $s = e => new TextDecoder().decode(e) }); var qe, tt, zs, yt, nt = k(() => { Me(); Ar(); qe = (e, t) => { let r = t.byteLength, n = gt(e), o = n + gt(r), s = new Uint8Array(o + r); return ht(e, s, 0), ht(r, s, n), s.set(t, o), new yt(e, r, t, s) }, tt = e => { let t = De(e), [r, n] = Ht(t), [o, s] = Ht(t.subarray(n)), i = t.subarray(n + s); if (i.byteLength !== o) throw new Error("Incorrect length"); return new yt(r, o, i, t) }, zs = (e, t) => e === t ? !0 : e.code === t.code && e.size === t.size && Ls(e.bytes, t.bytes), yt = class { constructor(t, r, n, o) { this.code = t, this.size = r, this.digest = n, this.bytes = o } } }); function Yd(e, t) { if (e.length >= 255) throw new TypeError("Alphabet too long"); for (var r = new Uint8Array(256), n = 0; n < r.length; n++)r[n] = 255; for (var o = 0; o < e.length; o++) { var s = e.charAt(o), i = s.charCodeAt(0); if (r[i] !== 255) throw new TypeError(s + " is ambiguous"); r[i] = o } var a = e.length, c = e.charAt(0), p = Math.log(a) / Math.log(256), d = Math.log(256) / Math.log(a); function g(v) { if (v instanceof Uint8Array || (ArrayBuffer.isView(v) ? v = new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : Array.isArray(v) && (v = Uint8Array.from(v))), !(v instanceof Uint8Array)) throw new TypeError("Expected Uint8Array"); if (v.length === 0) return ""; for (var _ = 0, U = 0, H = 0, Z = v.length; H !== Z && v[H] === 0;)H++, _++; for (var fe = (Z - H) * d + 1 >>> 0, J = new Uint8Array(fe); H !== Z;) { for (var be = v[H], le = 0, re = fe - 1; (be !== 0 || le < U) && re !== -1; re--, le++)be += 256 * J[re] >>> 0, J[re] = be % a >>> 0, be = be / a >>> 0; if (be !== 0) throw new Error("Non-zero carry"); U = le, H++ } for (var pe = fe - U; pe !== fe && J[pe] === 0;)pe++; for (var mt = c.repeat(_); pe < fe; ++pe)mt += e.charAt(J[pe]); return mt } function x(v) { if (typeof v != "string") throw new TypeError("Expected String"); if (v.length === 0) return new Uint8Array; var _ = 0; if (v[_] !== " ") { for (var U = 0, H = 0; v[_] === c;)U++, _++; for (var Z = (v.length - _) * p + 1 >>> 0, fe = new Uint8Array(Z); v[_];) { var J = r[v.charCodeAt(_)]; if (J === 255) return; for (var be = 0, le = Z - 1; (J !== 0 || be < H) && le !== -1; le--, be++)J += a * fe[le] >>> 0, fe[le] = J % 256 >>> 0, J = J / 256 >>> 0; if (J !== 0) throw new Error("Non-zero carry"); H = be, _++ } if (v[_] !== " ") { for (var re = Z - H; re !== Z && fe[re] === 0;)re++; for (var pe = new Uint8Array(U + (Z - re)), mt = U; re !== Z;)pe[mt++] = fe[re++]; return pe } } } function N(v) { var _ = x(v); if (_) return _; throw new Error(`Non-${t} character`) } return { encode: g, decodeUnsafe: x, decode: N } } var em, tm, Ms, qs = k(() => { em = Yd, tm = em, Ms = tm }); var Nn, Rn, On, Hs, Ln, wt, He, rm, nm, R, Ee = k(() => { qs(); Me(); Nn = class { constructor(t, r, n) { this.name = t, this.prefix = r, this.baseEncode = n } encode(t) { if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`; throw Error("Unknown type, must be binary type") } }, Rn = class { constructor(t, r, n) { if (this.name = t, this.prefix = r, r.codePointAt(0) === void 0) throw new Error("Invalid prefix character"); this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n } decode(t) { if (typeof t == "string") { if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`); return this.baseDecode(t.slice(this.prefix.length)) } else throw Error("Can only multibase decode strings") } or(t) { return Hs(this, t) } }, On = class { constructor(t) { this.decoders = t } or(t) { return Hs(this, t) } decode(t) { let r = t[0], n = this.decoders[r]; if (n) return n.decode(t); throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`) } }, Hs = (e, t) => new On({ ...e.decoders || { [e.prefix]: e }, ...t.decoders || { [t.prefix]: t } }), Ln = class { constructor(t, r, n, o) { this.name = t, this.prefix = r, this.baseEncode = n, this.baseDecode = o, this.encoder = new Nn(t, r, n), this.decoder = new Rn(t, r, o) } encode(t) { return this.encoder.encode(t) } decode(t) { return this.decoder.decode(t) } }, wt = ({ name: e, prefix: t, encode: r, decode: n }) => new Ln(e, t, r, n), He = ({ prefix: e, name: t, alphabet: r }) => { let { encode: n, decode: o } = Ms(r, t); return wt({ prefix: e, name: t, encode: n, decode: s => De(o(s)) }) }, rm = (e, t, r, n) => { let o = {}; for (let d = 0; d < t.length; ++d)o[t[d]] = d; let s = e.length; for (; e[s - 1] === "=";)--s; let i = new Uint8Array(s * r / 8 | 0), a = 0, c = 0, p = 0; for (let d = 0; d < s; ++d) { let g = o[e[d]]; if (g === void 0) throw new SyntaxError(`Non-${n} character`); c = c << r | g, a += r, a >= 8 && (a -= 8, i[p++] = 255 & c >> a) } if (a >= r || 255 & c << 8 - a) throw new SyntaxError("Unexpected end of data"); return i }, nm = (e, t, r) => { let n = t[t.length - 1] === "=", o = (1 << r) - 1, s = "", i = 0, a = 0; for (let c = 0; c < e.length; ++c)for (a = a << 8 | e[c], i += 8; i > r;)i -= r, s += t[o & a >> i]; if (i && (s += t[o & a << r - i]), n) for (; s.length * r & 7;)s += "="; return s }, R = ({ name: e, prefix: t, bitsPerChar: r, alphabet: n }) => wt({ prefix: t, name: e, encode(o) { return nm(o, n, r) }, decode(o) { return rm(o, n, r, e) } }) }); var Fn = {}; F(Fn, { base58btc: () => V, base58flickr: () => om }); var V, om, ot = k(() => { Ee(); V = He({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), om = He({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" }) }); var $n = {}; F($n, { base32: () => xe, base32hex: () => cm, base32hexpad: () => fm, base32hexpadupper: () => lm, base32hexupper: () => um, base32pad: () => im, base32padupper: () => am, base32upper: () => sm, base32z: () => pm }); var xe, sm, im, am, cm, um, fm, lm, pm, Vt = k(() => { Ee(); xe = R({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), sm = R({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), im = R({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), am = R({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), cm = R({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), um = R({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), fm = R({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), lm = R({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), pm = R({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 }) }); var Ws = {}; F(Ws, { CID: () => m }); var m, dm, mm, hm, Gt, gm, Vs, Gs, vr, Br, ym, wm, bm, C = k(() => {
                    Ar(); nt(); ot(); Vt(); Me(); m = class { constructor(t, r, n, o) { this.code = r, this.version = t, this.multihash = n, this.bytes = o, this.byteOffset = o.byteOffset, this.byteLength = o.byteLength, this.asCID = this, this._baseCache = new Map, Object.defineProperties(this, { byteOffset: Br, byteLength: Br, code: vr, version: vr, multihash: vr, bytes: vr, _baseCache: Br, asCID: Br }) } toV0() { switch (this.version) { case 0: return this; default: { let { code: t, multihash: r } = this; if (t !== Gt) throw new Error("Cannot convert a non dag-pb CID to CIDv0"); if (r.code !== gm) throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0"); return m.createV0(r) } } } toV1() { switch (this.version) { case 0: { let { code: t, digest: r } = this.multihash, n = qe(t, r); return m.createV1(this.code, n) } case 1: return this; default: throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`) } } equals(t) { return t && this.code === t.code && this.version === t.version && zs(this.multihash, t.multihash) } toString(t) { let { bytes: r, version: n, _baseCache: o } = this; switch (n) { case 0: return mm(r, o, t || V.encoder); default: return hm(r, o, t || xe.encoder) } } toJSON() { return { code: this.code, version: this.version, hash: this.multihash.bytes } } get [Symbol.toStringTag]() { return "CID" } [Symbol.for("nodejs.util.inspect.custom")]() { return "CID(" + this.toString() + ")" } static isCID(t) { return wm(/^0\.0/, bm), !!(t && (t[Gs] || t.asCID === t)) } get toBaseEncodedString() { throw new Error("Deprecated, use .toString()") } get codec() { throw new Error('"codec" property is deprecated, use integer "code" property instead') } get buffer() { throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead") } get multibaseName() { throw new Error('"multibaseName" property is deprecated') } get prefix() { throw new Error('"prefix" property is deprecated') } static asCID(t) { if (t instanceof m) return t; if (t != null && t.asCID === t) { let { version: r, code: n, multihash: o, bytes: s } = t; return new m(r, n, o, s || Vs(r, n, o.bytes)) } else if (t != null && t[Gs] === !0) { let { version: r, multihash: n, code: o } = t, s = tt(n); return m.create(r, o, s) } else return null } static create(t, r, n) { if (typeof r != "number") throw new Error("String codecs are no longer supported"); switch (t) { case 0: { if (r !== Gt) throw new Error(`Version 0 CID must use dag-pb (code: ${Gt}) block encoding`); return new m(t, r, n, n.bytes) } case 1: { let o = Vs(t, r, n.bytes); return new m(t, r, n, o) } default: throw new Error("Invalid version") } } static createV0(t) { return m.create(0, Gt, t) } static createV1(t, r) { return m.create(1, t, r) } static decode(t) { let [r, n] = m.decodeFirst(t); if (n.length) throw new Error("Incorrect length"); return r } static decodeFirst(t) { let r = m.inspectBytes(t), n = r.size - r.multihashSize, o = De(t.subarray(n, n + r.multihashSize)); if (o.byteLength !== r.multihashSize) throw new Error("Incorrect length"); let s = o.subarray(r.multihashSize - r.digestSize), i = new yt(r.multihashCode, r.digestSize, s, o); return [r.version === 0 ? m.createV0(i) : m.createV1(r.codec, i), t.subarray(r.size)] } static inspectBytes(t) { let r = 0, n = () => { let [g, x] = Ht(t.subarray(r)); return r += x, g }, o = n(), s = Gt; if (o === 18 ? (o = 0, r = 0) : o === 1 && (s = n()), o !== 0 && o !== 1) throw new RangeError(`Invalid CID version ${o}`); let i = r, a = n(), c = n(), p = r + c, d = p - i; return { version: o, codec: s, multihashCode: a, digestSize: c, multihashSize: d, size: p } } static parse(t, r) { let [n, o] = dm(t, r), s = m.decode(o); return s._baseCache.set(n, t), s } }, dm = (e, t) => { switch (e[0]) { case "Q": { let r = t || V; return [V.prefix, r.decode(`${V.prefix}${e}`)] } case V.prefix: { let r = t || V; return [V.prefix, r.decode(e)] } case xe.prefix: { let r = t || xe; return [xe.prefix, r.decode(e)] } default: { if (t == null) throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided"); return [e[0], t.decode(e)] } } }, mm = (e, t, r) => { let { prefix: n } = r; if (n !== V.prefix) throw Error(`Cannot string encode V0 in ${r.name} encoding`); let o = t.get(n); if (o == null) { let s = r.encode(e).slice(1); return t.set(n, s), s } else return o }, hm = (e, t, r) => { let { prefix: n } = r, o = t.get(n); if (o == null) { let s = r.encode(e); return t.set(n, s), s } else return o }, Gt = 112, gm = 18, Vs = (e, t, r) => { let n = gt(e), o = n + gt(t), s = new Uint8Array(o + r.byteLength); return ht(e, s, 0), ht(t, s, n), s.set(r, o), s }, Gs = Symbol.for("@ipld/js-cid/CID"), vr = { writable: !1, configurable: !1, enumerable: !0 }, Br = { writable: !1, enumerable: !1, configurable: !1 }, ym = "0.0.0-dev", wm = (e, t) => { if (e.test(ym)) console.warn(t); else throw new Error(t) }, bm = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
          doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
          // Make sure to use cid instead of value
          doSomethingWithCID(cid)
}
`}); function oi(e) { if (e === null) return "null"; if (e === void 0) return "undefined"; if (e === !0 || e === !1) return "boolean"; let t = typeof e; if (Nm.includes(t)) return t; if (t === "function") return "Function"; if (Array.isArray(e)) return "Array"; if (Om(e)) return "Buffer"; let r = Lm(e); return r || "Object" } function Om(e) { return e && e.constructor && e.constructor.isBuffer && e.constructor.isBuffer.call(null, e) } function Lm(e) { let t = Object.prototype.toString.call(e).slice(8, -1); if (Rm.includes(t)) return t } var Nm, Rm, si = k(() => { Nm = ["string", "number", "bigint", "symbol"], Rm = ["Function", "Generator", "AsyncGenerator", "GeneratorFunction", "AsyncGeneratorFunction", "AsyncFunction", "Observable", "Array", "Buffer", "Object", "RegExp", "Date", "Error", "Map", "Set", "WeakMap", "WeakSet", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Promise", "URL", "HTMLElement", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array"] }); var l, h, Y = k(() => { l = class { constructor(t, r, n) { this.major = t, this.majorEncoded = t << 5, this.name = r, this.terminal = n } toString() { return `Type[${this.major}].${this.name}` } compare(t) { return this.major < t.major ? -1 : this.major > t.major ? 1 : 0 } }; l.uint = new l(0, "uint", !0); l.negint = new l(1, "negint", !0); l.bytes = new l(2, "bytes", !0); l.string = new l(3, "string", !0); l.array = new l(4, "array", !1); l.map = new l(5, "map", !1); l.tag = new l(6, "tag", !1); l.float = new l(7, "float", !0); l.false = new l(7, "false", !0); l.true = new l(7, "true", !0); l.null = new l(7, "null", !0); l.undefined = new l(7, "undefined", !0); l.break = new l(7, "break", !0); h = class { constructor(t, r, n) { this.type = t, this.value = r, this.encodedLength = n, this.encodedBytes = void 0, this.byteValue = void 0 } toString() { return `Token[${this.type}].${this.value}` } } }); function _r(e) { return Dt && globalThis.Buffer.isBuffer(e) } function Jt(e) { return e instanceof Uint8Array ? _r(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e : Uint8Array.from(e) } function pi(e, t) { if (_r(e) && _r(t)) return e.compare(t); for (let r = 0; r < e.length; r++)if (e[r] !== t[r]) return e[r] < t[r] ? -1 : 1; return 0 } function ii(e, t = 1 / 0) { let r, n = e.length, o = null, s = []; for (let i = 0; i < n; ++i) { if (r = e.charCodeAt(i), r > 55295 && r < 57344) { if (!o) { if (r > 56319) { (t -= 3) > -1 && s.push(239, 191, 189); continue } else if (i + 1 === n) { (t -= 3) > -1 && s.push(239, 191, 189); continue } o = r; continue } if (r < 56320) { (t -= 3) > -1 && s.push(239, 191, 189), o = r; continue } r = (o - 55296 << 10 | r - 56320) + 65536 } else o && (t -= 3) > -1 && s.push(239, 191, 189); if (o = null, r < 128) { if ((t -= 1) < 0) break; s.push(r) } else if (r < 2048) { if ((t -= 2) < 0) break; s.push(r >> 6 | 192, r & 63 | 128) } else if (r < 65536) { if ((t -= 3) < 0) break; s.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128) } else if (r < 1114112) { if ((t -= 4) < 0) break; s.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128) } else throw new Error("Invalid code point") } return s } function ai(e, t, r) { let n = []; for (; t < r;) { let o = e[t], s = null, i = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1; if (t + i <= r) { let a, c, p, d; switch (i) { case 1: o < 128 && (s = o); break; case 2: a = e[t + 1], (a & 192) === 128 && (d = (o & 31) << 6 | a & 63, d > 127 && (s = d)); break; case 3: a = e[t + 1], c = e[t + 2], (a & 192) === 128 && (c & 192) === 128 && (d = (o & 15) << 12 | (a & 63) << 6 | c & 63, d > 2047 && (d < 55296 || d > 57343) && (s = d)); break; case 4: a = e[t + 1], c = e[t + 2], p = e[t + 3], (a & 192) === 128 && (c & 192) === 128 && (p & 192) === 128 && (d = (o & 15) << 18 | (a & 63) << 12 | (c & 63) << 6 | p & 63, d > 65535 && d < 1114112 && (s = d)) } } s === null ? (s = 65533, i = 1) : s > 65535 && (s -= 65536, n.push(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), n.push(s), t += i } return Vn(n) } function Vn(e) { let t = e.length; if (t <= ci) return String.fromCharCode.apply(String, e); let r = "", n = 0; for (; n < t;)r += String.fromCharCode.apply(String, e.slice(n, n += ci)); return r } var Dt, Fm, $m, ui, kr, Ie, Et, fi, li, ci, Ve = k(() => { Dt = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer == "function", Fm = new TextDecoder, $m = new TextEncoder; ui = Dt ? (e, t, r) => r - t > 64 ? globalThis.Buffer.from(e.subarray(t, r)).toString("utf8") : ai(e, t, r) : (e, t, r) => r - t > 64 ? Fm.decode(e.subarray(t, r)) : ai(e, t, r), kr = Dt ? e => e.length > 64 ? globalThis.Buffer.from(e) : ii(e) : e => e.length > 64 ? $m.encode(e) : ii(e), Ie = e => Uint8Array.from(e), Et = Dt ? (e, t, r) => _r(e) ? new Uint8Array(e.subarray(t, r)) : e.slice(t, r) : (e, t, r) => e.slice(t, r), fi = Dt ? (e, t) => (e = e.map(r => r instanceof Uint8Array ? r : globalThis.Buffer.from(r)), Jt(globalThis.Buffer.concat(e, t))) : (e, t) => { let r = new Uint8Array(t), n = 0; for (let o of e) n + o.length > r.length && (o = o.subarray(0, r.length - n)), r.set(o, n), n += o.length; return r }, li = Dt ? e => globalThis.Buffer.allocUnsafe(e) : e => new Uint8Array(e); ci = 4096 }); var jm, Kt, di = k(() => { Ve(); jm = 256, Kt = class { constructor(t = jm) { this.chunkSize = t, this.cursor = 0, this.maxCursor = -1, this.chunks = [], this._initReuseChunk = null } reset() { this.cursor = 0, this.maxCursor = -1, this.chunks.length && (this.chunks = []), this._initReuseChunk !== null && (this.chunks.push(this._initReuseChunk), this.maxCursor = this._initReuseChunk.length - 1) } push(t) { let r = this.chunks[this.chunks.length - 1]; if (this.cursor + t.length <= this.maxCursor + 1) { let o = r.length - (this.maxCursor - this.cursor) - 1; r.set(t, o) } else { if (r) { let o = r.length - (this.maxCursor - this.cursor) - 1; o < r.length && (this.chunks[this.chunks.length - 1] = r.subarray(0, o), this.maxCursor = this.cursor - 1) } t.length < 64 && t.length < this.chunkSize ? (r = li(this.chunkSize), this.chunks.push(r), this.maxCursor += r.length, this._initReuseChunk === null && (this._initReuseChunk = r), r.set(t, 0)) : (this.chunks.push(t), this.maxCursor += t.length) } this.cursor += t.length } toBytes(t = !1) { let r; if (this.chunks.length === 1) { let n = this.chunks[0]; t && this.cursor > n.length / 2 ? (r = this.cursor === n.length ? n : n.subarray(0, this.cursor), this._initReuseChunk = null, this.chunks = []) : r = Et(n, 0, this.cursor) } else r = fi(this.chunks, this.cursor); return t && this.reset(), r } } }); function Le(e, t, r) { if (e.length - t < r) throw new Error(`${w} not enough data for type`) } var w, Oe, Xt, ne = k(() => { w = "CBOR decode error:", Oe = "CBOR encode error:", Xt = []; Xt[23] = 1; Xt[24] = 2; Xt[25] = 3; Xt[26] = 5; Xt[27] = 9 }); function oe(e, t, r) { Le(e, t, 1); let n = e[t]; if (r.strict === !0 && n < G[0]) throw new Error(`${w} integer encoded in more bytes than necessary (strict decode)`); return n } function se(e, t, r) { Le(e, t, 2); let n = e[t] << 8 | e[t + 1]; if (r.strict === !0 && n < G[1]) throw new Error(`${w} integer encoded in more bytes than necessary (strict decode)`); return n } function ie(e, t, r) { Le(e, t, 4); let n = e[t] * 16777216 + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3]; if (r.strict === !0 && n < G[2]) throw new Error(`${w} integer encoded in more bytes than necessary (strict decode)`); return n } function ae(e, t, r) { Le(e, t, 8); let n = e[t] * 16777216 + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3], o = e[t + 4] * 16777216 + (e[t + 5] << 16) + (e[t + 6] << 8) + e[t + 7], s = (BigInt(n) << BigInt(32)) + BigInt(o); if (r.strict === !0 && s < G[3]) throw new Error(`${w} integer encoded in more bytes than necessary (strict decode)`); if (s <= Number.MAX_SAFE_INTEGER) return Number(s); if (r.allowBigInt === !0) return s; throw new Error(`${w} integers outside of the safe integer range are not supported`) } function mi(e, t, r, n) { return new h(l.uint, oe(e, t + 1, n), 2) } function hi(e, t, r, n) { return new h(l.uint, se(e, t + 1, n), 3) } function gi(e, t, r, n) { return new h(l.uint, ie(e, t + 1, n), 5) } function yi(e, t, r, n) { return new h(l.uint, ae(e, t + 1, n), 9) } function de(e, t) { return K(e, 0, t.value) } function K(e, t, r) { if (r < G[0]) { let n = Number(r); e.push([t | n]) } else if (r < G[1]) { let n = Number(r); e.push([t | 24, n]) } else if (r < G[2]) { let n = Number(r); e.push([t | 25, n >>> 8, n & 255]) } else if (r < G[3]) { let n = Number(r); e.push([t | 26, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, n & 255]) } else { let n = BigInt(r); if (n < G[4]) { let o = [t | 27, 0, 0, 0, 0, 0, 0, 0], s = Number(n & BigInt(4294967295)), i = Number(n >> BigInt(32) & BigInt(4294967295)); o[8] = s & 255, s = s >> 8, o[7] = s & 255, s = s >> 8, o[6] = s & 255, s = s >> 8, o[5] = s & 255, o[4] = i & 255, i = i >> 8, o[3] = i & 255, i = i >> 8, o[2] = i & 255, i = i >> 8, o[1] = i & 255, e.push(o) } else throw new Error(`${w} encountered BigInt larger than allowable range`) } } var G, _e = k(() => { Y(); ne(); G = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")]; de.encodedSize = function (t) { return K.encodedSize(t.value) }; K.encodedSize = function (t) { return t < G[0] ? 1 : t < G[1] ? 2 : t < G[2] ? 3 : t < G[3] ? 5 : 9 }; de.compareTokens = function (t, r) { return t.value < r.value ? -1 : t.value > r.value ? 1 : 0 } }); function wi(e, t, r, n) { return new h(l.negint, -1 - oe(e, t + 1, n), 2) } function bi(e, t, r, n) { return new h(l.negint, -1 - se(e, t + 1, n), 3) } function Di(e, t, r, n) { return new h(l.negint, -1 - ie(e, t + 1, n), 5) } function xi(e, t, r, n) { let o = ae(e, t + 1, n); if (typeof o != "bigint") { let s = -1 - o; if (s >= Number.MIN_SAFE_INTEGER) return new h(l.negint, s, 9) } if (n.allowBigInt !== !0) throw new Error(`${w} integers outside of the safe integer range are not supported`); return new h(l.negint, Gn - BigInt(o), 9) } function Ur(e, t) { let r = t.value, n = typeof r == "bigint" ? r * Gn - Ei : r * -1 - 1; K(e, t.type.majorEncoded, n) } var Gn, Ei, Wn = k(() => { Y(); _e(); ne(); Gn = BigInt(-1), Ei = BigInt(1); Ur.encodedSize = function (t) { let r = t.value, n = typeof r == "bigint" ? r * Gn - Ei : r * -1 - 1; return n < G[0] ? 1 : n < G[1] ? 2 : n < G[2] ? 3 : n < G[3] ? 5 : 9 }; Ur.compareTokens = function (t, r) { return t.value < r.value ? 1 : t.value > r.value ? -1 : 0 } }); function Qt(e, t, r, n) { Le(e, t, r + n); let o = Et(e, t + r, t + r + n); return new h(l.bytes, o, r + n) } function Si(e, t, r, n) { return Qt(e, t, 1, r) } function Ci(e, t, r, n) { return Qt(e, t, 2, oe(e, t + 1, n)) } function Pi(e, t, r, n) { return Qt(e, t, 3, se(e, t + 1, n)) } function Ti(e, t, r, n) { return Qt(e, t, 5, ie(e, t + 1, n)) } function Ai(e, t, r, n) { let o = ae(e, t + 1, n); if (typeof o == "bigint") throw new Error(`${w} 64-bit integer bytes lengths not supported`); return Qt(e, t, 9, o) } function Nr(e) { return e.encodedBytes === void 0 && (e.encodedBytes = e.type === l.string ? kr(e.value) : e.value), e.encodedBytes } function xt(e, t) { let r = Nr(t); K(e, t.type.majorEncoded, r.length), e.push(r) } function Mm(e, t) { return e.length < t.length ? -1 : e.length > t.length ? 1 : pi(e, t) } var Rr = k(() => { Y(); ne(); _e(); Ve(); xt.encodedSize = function (t) { let r = Nr(t); return K.encodedSize(r.length) + r.length }; xt.compareTokens = function (t, r) { return Mm(Nr(t), Nr(r)) } }); function Zt(e, t, r, n, o) { let s = r + n; Le(e, t, s); let i = new h(l.string, ui(e, t + r, t + s), s); return o.retainStringBytes === !0 && (i.byteValue = Et(e, t + r, t + s)), i } function vi(e, t, r, n) { return Zt(e, t, 1, r, n) } function Bi(e, t, r, n) { return Zt(e, t, 2, oe(e, t + 1, n), n) } function Ii(e, t, r, n) { return Zt(e, t, 3, se(e, t + 1, n), n) } function _i(e, t, r, n) { return Zt(e, t, 5, ie(e, t + 1, n), n) } function ki(e, t, r, n) { let o = ae(e, t + 1, n); if (typeof o == "bigint") throw new Error(`${w} 64-bit integer string lengths not supported`); return Zt(e, t, 9, o, n) } var Ui, Jn = k(() => { Y(); ne(); _e(); Rr(); Ve(); Ui = xt }); function St(e, t, r, n) { return new h(l.array, n, r) } function Ni(e, t, r, n) { return St(e, t, 1, r) } function Ri(e, t, r, n) { return St(e, t, 2, oe(e, t + 1, n)) } function Oi(e, t, r, n) { return St(e, t, 3, se(e, t + 1, n)) } function Li(e, t, r, n) { return St(e, t, 5, ie(e, t + 1, n)) } function Fi(e, t, r, n) { let o = ae(e, t + 1, n); if (typeof o == "bigint") throw new Error(`${w} 64-bit integer array lengths not supported`); return St(e, t, 9, o) } function $i(e, t, r, n) { if (n.allowIndefinite === !1) throw new Error(`${w} indefinite length items not allowed`); return St(e, t, 1, 1 / 0) } function Or(e, t) { K(e, l.array.majorEncoded, t.value) } var Kn = k(() => { Y(); _e(); ne(); Or.compareTokens = de.compareTokens; Or.encodedSize = function (t) { return K.encodedSize(t.value) } }); function Ct(e, t, r, n) { return new h(l.map, n, r) } function ji(e, t, r, n) { return Ct(e, t, 1, r) } function zi(e, t, r, n) { return Ct(e, t, 2, oe(e, t + 1, n)) } function Mi(e, t, r, n) { return Ct(e, t, 3, se(e, t + 1, n)) } function qi(e, t, r, n) { return Ct(e, t, 5, ie(e, t + 1, n)) } function Hi(e, t, r, n) { let o = ae(e, t + 1, n); if (typeof o == "bigint") throw new Error(`${w} 64-bit integer map lengths not supported`); return Ct(e, t, 9, o) } function Vi(e, t, r, n) { if (n.allowIndefinite === !1) throw new Error(`${w} indefinite length items not allowed`); return Ct(e, t, 1, 1 / 0) } function Lr(e, t) { K(e, l.map.majorEncoded, t.value) } var Xn = k(() => { Y(); _e(); ne(); Lr.compareTokens = de.compareTokens; Lr.encodedSize = function (t) { return K.encodedSize(t.value) } }); function Gi(e, t, r, n) { return new h(l.tag, r, 1) } function Wi(e, t, r, n) { return new h(l.tag, oe(e, t + 1, n), 2) } function Ji(e, t, r, n) { return new h(l.tag, se(e, t + 1, n), 3) } function Ki(e, t, r, n) { return new h(l.tag, ie(e, t + 1, n), 5) } function Xi(e, t, r, n) { return new h(l.tag, ae(e, t + 1, n), 9) } function Fr(e, t) { K(e, l.tag.majorEncoded, t.value) } var Qn = k(() => { Y(); _e(); Fr.compareTokens = de.compareTokens; Fr.encodedSize = function (t) { return K.encodedSize(t.value) } }); function Qi(e, t, r, n) { if (n.allowUndefined === !1) throw new Error(`${w} undefined values are not supported`); return n.coerceUndefinedToNull === !0 ? new h(l.null, null, 1) : new h(l.undefined, void 0, 1) } function Zi(e, t, r, n) { if (n.allowIndefinite === !1) throw new Error(`${w} indefinite length items not allowed`); return new h(l.break, void 0, 1) } function Zn(e, t, r) { if (r) { if (r.allowNaN === !1 && Number.isNaN(e)) throw new Error(`${w} NaN values are not supported`); if (r.allowInfinity === !1 && (e === 1 / 0 || e === -1 / 0)) throw new Error(`${w} Infinity values are not supported`) } return new h(l.float, e, t) } function Yi(e, t, r, n) { return Zn(Yn(e, t + 1), 3, n) } function ea(e, t, r, n) { return Zn(eo(e, t + 1), 5, n) } function ta(e, t, r, n) { return Zn(sa(e, t + 1), 9, n) } function $r(e, t, r) { let n = t.value; if (n === !1) e.push([l.float.majorEncoded | Jm]); else if (n === !0) e.push([l.float.majorEncoded | Km]); else if (n === null) e.push([l.float.majorEncoded | Xm]); else if (n === void 0) e.push([l.float.majorEncoded | Qm]); else { let o, s = !1; (!r || r.float64 !== !0) && (na(n), o = Yn(Se, 1), n === o || Number.isNaN(n) ? (Se[0] = 249, e.push(Se.slice(0, 3)), s = !0) : (oa(n), o = eo(Se, 1), n === o && (Se[0] = 250, e.push(Se.slice(0, 5)), s = !0))), s || (Zm(n), o = sa(Se, 1), Se[0] = 251, e.push(Se.slice(0, 9))) } } function na(e) { if (e === 1 / 0) me.setUint16(0, 31744, !1); else if (e === -1 / 0) me.setUint16(0, 64512, !1); else if (Number.isNaN(e)) me.setUint16(0, 32256, !1); else { me.setFloat32(0, e); let t = me.getUint32(0), r = (t & 2139095040) >> 23, n = t & 8388607; if (r === 255) me.setUint16(0, 31744, !1); else if (r === 0) me.setUint16(0, (e & 2147483648) >> 16 | n >> 13, !1); else { let o = r - 127; o < -24 ? me.setUint16(0, 0) : o < -14 ? me.setUint16(0, (t & 2147483648) >> 16 | 1 << 24 + o, !1) : me.setUint16(0, (t & 2147483648) >> 16 | o + 15 << 10 | n >> 13, !1) } } } function Yn(e, t) { if (e.length - t < 2) throw new Error(`${w} not enough data for float16`); let r = (e[t] << 8) + e[t + 1]; if (r === 31744) return 1 / 0; if (r === 64512) return -1 / 0; if (r === 32256) return NaN; let n = r >> 10 & 31, o = r & 1023, s; return n === 0 ? s = o * 2 ** -24 : n !== 31 ? s = (o + 1024) * 2 ** (n - 25) : s = o === 0 ? 1 / 0 : NaN, r & 32768 ? -s : s } function oa(e) { me.setFloat32(0, e, !1) } function eo(e, t) { if (e.length - t < 4) throw new Error(`${w} not enough data for float32`); let r = (e.byteOffset || 0) + t; return new DataView(e.buffer, r, 4).getFloat32(0, !1) } function Zm(e) { me.setFloat64(0, e, !1) } function sa(e, t) { if (e.length - t < 8) throw new Error(`${w} not enough data for float64`); let r = (e.byteOffset || 0) + t; return new DataView(e.buffer, r, 8).getFloat64(0, !1) } var Jm, Km, Xm, Qm, ra, me, Se, to = k(() => { Y(); ne(); _e(); Jm = 20, Km = 21, Xm = 22, Qm = 23; $r.encodedSize = function (t, r) { let n = t.value; if (n === !1 || n === !0 || n === null || n === void 0) return 1; if (!r || r.float64 !== !0) { na(n); let o = Yn(Se, 1); if (n === o || Number.isNaN(n)) return 3; if (oa(n), o = eo(Se, 1), n === o) return 5 } return 9 }; ra = new ArrayBuffer(9), me = new DataView(ra, 1), Se = new Uint8Array(ra, 0); $r.compareTokens = de.compareTokens }); function I(e, t, r) { throw new Error(`${w} encountered invalid minor (${r}) for major ${e[t] >>> 5}`) } function jr(e) { return () => { throw new Error(`${w} ${e}`) } } function ia(e) { switch (e.type) { case l.false: return Ie([244]); case l.true: return Ie([245]); case l.null: return Ie([246]); case l.bytes: return e.value.length ? void 0 : Ie([64]); case l.string: return e.value === "" ? Ie([96]) : void 0; case l.array: return e.value === 0 ? Ie([128]) : void 0; case l.map: return e.value === 0 ? Ie([160]) : void 0; case l.uint: return e.value < 24 ? Ie([Number(e.value)]) : void 0; case l.negint: if (e.value >= -24) return Ie([31 - Number(e.value)]) } } var y, Ce, ro = k(() => { Y(); _e(); Wn(); Rr(); Jn(); Kn(); Xn(); Qn(); to(); ne(); Ve(); y = []; for (let e = 0; e <= 23; e++)y[e] = I; y[24] = mi; y[25] = hi; y[26] = gi; y[27] = yi; y[28] = I; y[29] = I; y[30] = I; y[31] = I; for (let e = 32; e <= 55; e++)y[e] = I; y[56] = wi; y[57] = bi; y[58] = Di; y[59] = xi; y[60] = I; y[61] = I; y[62] = I; y[63] = I; for (let e = 64; e <= 87; e++)y[e] = Si; y[88] = Ci; y[89] = Pi; y[90] = Ti; y[91] = Ai; y[92] = I; y[93] = I; y[94] = I; y[95] = jr("indefinite length bytes/strings are not supported"); for (let e = 96; e <= 119; e++)y[e] = vi; y[120] = Bi; y[121] = Ii; y[122] = _i; y[123] = ki; y[124] = I; y[125] = I; y[126] = I; y[127] = jr("indefinite length bytes/strings are not supported"); for (let e = 128; e <= 151; e++)y[e] = Ni; y[152] = Ri; y[153] = Oi; y[154] = Li; y[155] = Fi; y[156] = I; y[157] = I; y[158] = I; y[159] = $i; for (let e = 160; e <= 183; e++)y[e] = ji; y[184] = zi; y[185] = Mi; y[186] = qi; y[187] = Hi; y[188] = I; y[189] = I; y[190] = I; y[191] = Vi; for (let e = 192; e <= 215; e++)y[e] = Gi; y[216] = Wi; y[217] = Ji; y[218] = Ki; y[219] = Xi; y[220] = I; y[221] = I; y[222] = I; y[223] = I; for (let e = 224; e <= 243; e++)y[e] = jr("simple values are not supported"); y[244] = I; y[245] = I; y[246] = I; y[247] = Qi; y[248] = jr("simple values are not supported"); y[249] = Yi; y[250] = ea; y[251] = ta; y[252] = I; y[253] = I; y[254] = I; y[255] = Zi; Ce = []; for (let e = 0; e < 24; e++)Ce[e] = new h(l.uint, e, 1); for (let e = -1; e >= -24; e--)Ce[31 - e] = new h(l.negint, e, 1); Ce[64] = new h(l.bytes, new Uint8Array(0), 1); Ce[96] = new h(l.string, "", 1); Ce[128] = new h(l.array, 0, 1); Ce[160] = new h(l.map, 0, 1); Ce[244] = new h(l.false, !1, 1); Ce[245] = new h(l.true, !0, 1); Ce[246] = new h(l.null, null, 1) }); function th() { let e = []; return e[l.uint.major] = de, e[l.negint.major] = Ur, e[l.bytes.major] = xt, e[l.string.major] = Ui, e[l.array.major] = Or, e[l.map.major] = Lr, e[l.tag.major] = Fr, e[l.float.major] = $r, e } function zr(e, t = {}, r) { let n = oi(e), o = t && t.typeEncoders && t.typeEncoders[n] || We[n]; if (typeof o == "function") { let i = o(e, n, t, r); if (i != null) return i } let s = We[n]; if (!s) throw new Error(`${Oe} unsupported type: ${n}`); return s(e, n, t, r) } function rh(e, t) { t.mapSorter && e.sort(t.mapSorter) } function nh(e, t) { let r = Array.isArray(e[0]) ? e[0][0] : e[0], n = Array.isArray(t[0]) ? t[0][0] : t[0]; if (r.type !== n.type) return r.type.compare(n.type); let o = r.type.major, s = aa[o].compareTokens(r, n); return s === 0 && console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"), s } function ca(e, t, r, n) { if (Array.isArray(t)) for (let o of t) ca(e, o, r, n); else r[t.type.major](e, t, n) } function oo(e, t, r) { let n = zr(e, r); if (!Array.isArray(n) && r.quickEncodeToken) { let o = r.quickEncodeToken(n); if (o) return o; let s = t[n.type.major]; if (s.encodedSize) { let i = s.encodedSize(n, r), a = new Kt(i); if (s(a, n, r), a.chunks.length !== 1) throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`); return Jt(a.chunks[0]) } } return no.reset(), ca(no, n, t, r), no.toBytes(!0) } function Yt(e, t) { return t = Object.assign({}, eh, t), oo(e, aa, t) } var eh, aa, no, Pt, Ge, We, so = k(() => { si(); Y(); di(); ne(); ro(); Ve(); _e(); Wn(); Rr(); Jn(); Kn(); Xn(); Qn(); to(); eh = { float64: !1, mapSorter: nh, quickEncodeToken: ia }; aa = th(), no = new Kt, Pt = class { constructor(t, r) { this.obj = t, this.parent = r } includes(t) { let r = this; do if (r.obj === t) return !0; while (r = r.parent); return !1 } static createCheck(t, r) { if (t && t.includes(r)) throw new Error(`${Oe} object contains circular references`); return new Pt(r, t) } }, Ge = { null: new h(l.null, null), undefined: new h(l.undefined, void 0), true: new h(l.true, !0), false: new h(l.false, !1), emptyArray: new h(l.array, 0), emptyMap: new h(l.map, 0) }, We = { number(e, t, r, n) { return !Number.isInteger(e) || !Number.isSafeInteger(e) ? new h(l.float, e) : e >= 0 ? new h(l.uint, e) : new h(l.negint, e) }, bigint(e, t, r, n) { return e >= BigInt(0) ? new h(l.uint, e) : new h(l.negint, e) }, Uint8Array(e, t, r, n) { return new h(l.bytes, e) }, string(e, t, r, n) { return new h(l.string, e) }, boolean(e, t, r, n) { return e ? Ge.true : Ge.false }, null(e, t, r, n) { return Ge.null }, undefined(e, t, r, n) { return Ge.undefined }, ArrayBuffer(e, t, r, n) { return new h(l.bytes, new Uint8Array(e)) }, DataView(e, t, r, n) { return new h(l.bytes, new Uint8Array(e.buffer, e.byteOffset, e.byteLength)) }, Array(e, t, r, n) { if (!e.length) return r.addBreakTokens === !0 ? [Ge.emptyArray, new h(l.break)] : Ge.emptyArray; n = Pt.createCheck(n, e); let o = [], s = 0; for (let i of e) o[s++] = zr(i, r, n); return r.addBreakTokens ? [new h(l.array, e.length), o, new h(l.break)] : [new h(l.array, e.length), o] }, Object(e, t, r, n) { let o = t !== "Object", s = o ? e.keys() : Object.keys(e), i = o ? e.size : s.length; if (!i) return r.addBreakTokens === !0 ? [Ge.emptyMap, new h(l.break)] : Ge.emptyMap; n = Pt.createCheck(n, e); let a = [], c = 0; for (let p of s) a[c++] = [zr(p, r, n), zr(o ? e.get(p) : e[p], r, n)]; return rh(a, r), r.addBreakTokens ? [new h(l.map, i), a, new h(l.break)] : [new h(l.map, i), a] } }; We.Map = We.Object; We.Buffer = We.Uint8Array; for (let e of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) We[`${e}Array`] = We.DataView }); function sh(e, t, r) { let n = []; for (let o = 0; o < e.value; o++) { let s = tr(t, r); if (s === Mr) { if (e.value === 1 / 0) break; throw new Error(`${w} got unexpected break to lengthed array`) } if (s === er) throw new Error(`${w} found array but not enough entries (got ${o}, expected ${e.value})`); n[o] = s } return n } function ih(e, t, r) { let n = r.useMaps === !0, o = n ? void 0 : {}, s = n ? new Map : void 0; for (let i = 0; i < e.value; i++) { let a = tr(t, r); if (a === Mr) { if (e.value === 1 / 0) break; throw new Error(`${w} got unexpected break to lengthed map`) } if (a === er) throw new Error(`${w} found map but not enough entries (got ${i} [no key], expected ${e.value})`); if (n !== !0 && typeof a != "string") throw new Error(`${w} non-string keys not supported (got ${typeof a})`); let c = tr(t, r); if (c === er) throw new Error(`${w} found map but not enough entries (got ${i} [no value], expected ${e.value})`); n ? s.set(a, c) : o[a] = c } return n ? s : o } function tr(e, t) { if (e.done()) return er; let r = e.next(); if (r.type === l.break) return Mr; if (r.type.terminal) return r.value; if (r.type === l.array) return sh(r, e, t); if (r.type === l.map) return ih(r, e, t); if (r.type === l.tag) { if (t.tags && typeof t.tags[r.value] == "function") { let n = tr(e, t); return t.tags[r.value](n) } throw new Error(`${w} tag not supported (${r.value})`) } throw new Error("unsupported") } function it(e, t) { if (!(e instanceof Uint8Array)) throw new Error(`${w} data to decode must be a Uint8Array`); t = Object.assign({}, oh, t); let r = t.tokenizer || new io(e, t), n = tr(r, t); if (n === er) throw new Error(`${w} did not find any content to decode`); if (n === Mr) throw new Error(`${w} got unexpected break`); if (!r.done()) throw new Error(`${w} too many terminals, data makes no sense`); return n } var oh, io, er, Mr, ao = k(() => { ne(); Y(); ro(); oh = { strict: !1, allowIndefinite: !0, allowUndefined: !0, allowBigInt: !0 }, io = class { constructor(t, r = {}) { this.pos = 0, this.data = t, this.options = r } done() { return this.pos >= this.data.length } next() { let t = this.data[this.pos], r = Ce[t]; if (r === void 0) { let n = y[t]; if (!n) throw new Error(`${w} no decoder for major type ${t >>> 5} (byte 0x${t.toString(16).padStart(2, "0")})`); let o = t & 31; r = n(this.data, this.pos, o, this.options) } return this.pos += r.encodedLength, r } }, er = Symbol.for("DONE"), Mr = Symbol.for("BREAK") }); var qr = k(() => { so(); ao(); Y() }); var Hr = {}; F(Hr, { base64: () => Tt, base64pad: () => gh, base64url: () => rr, base64urlpad: () => yh }); var Tt, gh, rr, yh, At = k(() => { Ee(); Tt = R({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), gh = R({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), rr = R({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), yh = R({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 }) }); var wo = D(Bt => { "use strict"; Object.defineProperty(Bt, "__esModule", { value: !0 }); Bt.fromBase64url = Bt.toBase64url = void 0; var ma = (At(), xr(Hr)); function Bh(e) { return ma.base64url.encode(e).slice(1) } Bt.toBase64url = Bh; function Ih(e) { return ma.base64url.decode(`u${e}`) } Bt.fromBase64url = Ih }); var ha = D(Do => { "use strict"; Object.defineProperty(Do, "__esModule", { value: !0 }); var at = wo(), bo = (C(), xr(Ws)); function _h(e) { let [t, r, n] = e; return { payload: r, signatures: [{ protected: t, signature: n }], link: bo.CID.decode(at.fromBase64url(r)) } } function kh(e) { let t = { signature: at.fromBase64url(e.signature) }; return e.header && (t.header = e.header), e.protected && (t.protected = at.fromBase64url(e.protected)), t } function Uh(e) { let t = at.fromBase64url(e.payload); try { bo.CID.decode(t) } catch { throw new Error("Not a valid DagJWS") } return { payload: t, signatures: e.signatures.map(kh) } } function Nh(e) { let t = { signature: at.toBase64url(e.signature) }; return e.header && (t.header = e.header), e.protected && (t.protected = at.toBase64url(e.protected)), t } function Rh(e) { let t = { payload: at.toBase64url(e.payload), signatures: e.signatures.map(Nh) }; return t.link = bo.CID.decode(new Uint8Array(e.payload)), t } Do.default = { fromSplit: _h, encode: Uh, decode: Rh } }); var ga = D(Eo => { "use strict"; Object.defineProperty(Eo, "__esModule", { value: !0 }); var he = wo(); function Oh(e) { let [t, r, n, o, s] = e, i = { ciphertext: o, iv: n, protected: t, tag: s }; return r && (i.recipients = [{ encrypted_key: r }]), i } function Lh(e) { let t = {}; return e.encrypted_key && (t.encrypted_key = he.fromBase64url(e.encrypted_key)), e.header && (t.header = e.header), t } function Fh(e) { let t = { ciphertext: he.fromBase64url(e.ciphertext), protected: he.fromBase64url(e.protected), iv: he.fromBase64url(e.iv), tag: he.fromBase64url(e.tag) }; return e.aad && (t.aad = he.fromBase64url(e.aad)), e.recipients && (t.recipients = e.recipients.map(Lh)), e.unprotected && (t.unprotected = e.unprotected), t } function $h(e) { let t = {}; return e.encrypted_key && (t.encrypted_key = he.toBase64url(e.encrypted_key)), e.header && (t.header = e.header), t } function jh(e) { let t = { ciphertext: he.toBase64url(e.ciphertext), protected: he.toBase64url(e.protected), iv: he.toBase64url(e.iv), tag: he.toBase64url(e.tag) }; return e.aad && (t.aad = he.toBase64url(e.aad)), e.recipients && (t.recipients = e.recipients.map($h)), e.unprotected && (t.unprotected = e.unprotected), t } Eo.default = { fromSplit: Oh, decode: jh, encode: Fh } }); var ba = {}; F(ba, { code: () => Wh, decode: () => Kh, encode: () => Jh, name: () => Gh }); function zh(e) { if (e.asCID !== e) return null; let t = m.asCID(e); if (!t) return null; let r = new Uint8Array(t.bytes.byteLength + 1); return r.set(t.bytes, 1), [new h(l.tag, ya), new h(l.bytes, r)] } function Mh() { throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded") } function qh(e) { if (Number.isNaN(e)) throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded"); if (e === 1 / 0 || e === -1 / 0) throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded"); return null } function Vh(e) { if (e[0] !== 0) throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00"); return m.decode(e.subarray(1)) } var ya, Hh, wa, Gh, Wh, Jh, Kh, Da = k(() => { qr(); C(); ya = 42; Hh = { float64: !0, typeEncoders: { Object: zh, undefined: Mh, number: qh } }; wa = { allowIndefinite: !1, allowUndefined: !1, allowNaN: !1, allowInfinity: !1, allowBigInt: !0, strict: !0, useMaps: !1, tags: [] }; wa.tags[ya] = Vh; Gh = "dag-cbor", Wh = 113, Jh = e => Yt(e, Hh), Kh = e => it(e, wa) }); var Ta = D($ => { "use strict"; var Xh = $ && $.__createBinding || (Object.create ? function (e, t, r, n) { n === void 0 && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function () { return t[r] } }) } : function (e, t, r, n) { n === void 0 && (n = r), e[n] = t[r] }), Qh = $ && $.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), Zh = $ && $.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Xh(t, e, r); return Qh(t, e), t }, Ea = $ && $.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty($, "__esModule", { value: !0 }); $.decode = $.encode = $.toGeneral = $.code = $.name = void 0; var xo = Ea(ha()), So = Ea(ga()), xa = Zh((Da(), xr(ba))); $.name = "dag-jose"; $.code = 133; function Sa(e) { return "payload" in e && typeof e.payload == "string" && "signatures" in e && Array.isArray(e.signatures) } function Yh(e) { return "payload" in e && e.payload instanceof Uint8Array && "signatures" in e && Array.isArray(e.signatures) } function eg(e) { return "ciphertext" in e && e.ciphertext instanceof Uint8Array && "iv" in e && e.iv instanceof Uint8Array && "protected" in e && e.protected instanceof Uint8Array && "tag" in e && e.tag instanceof Uint8Array } function Ca(e) { return "ciphertext" in e && typeof e.ciphertext == "string" && "iv" in e && typeof e.iv == "string" && "protected" in e && typeof e.protected == "string" && "tag" in e && typeof e.tag == "string" } function Pa(e) { if (typeof e == "string") { let t = e.split("."); if (t.length === 3) return xo.default.fromSplit(t); if (t.length === 5) return So.default.fromSplit(t); throw new Error("Not a valid JOSE string") } if (Sa(e) || Ca(e)) return e; throw new Error("Not a valid unencoded JOSE object") } $.toGeneral = Pa; function tg(e) { typeof e == "string" && (e = Pa(e)); let t; if (Sa(e)) t = xo.default.encode(e); else if (Ca(e)) t = So.default.encode(e); else throw new Error("Not a valid JOSE object"); return new Uint8Array(xa.encode(t)) } $.encode = tg; function rg(e) { let t; try { t = xa.decode(e) } catch { throw new Error("Not a valid DAG-JOSE object") } if (Yh(t)) return xo.default.decode(t); if (eg(t)) return So.default.decode(t); throw new Error("Not a valid DAG-JOSE object") } $.decode = rg }); var Ma = D((U0, za) => { za.exports = $o; var ja = 128, Lg = 127, Fg = ~Lg, $g = Math.pow(2, 31); function $o(e, t, r) { if (Number.MAX_SAFE_INTEGER && e > Number.MAX_SAFE_INTEGER) throw $o.bytes = 0, new RangeError("Could not encode varint"); t = t || [], r = r || 0; for (var n = r; e >= $g;)t[r++] = e & 255 | ja, e /= 128; for (; e & Fg;)t[r++] = e & 255 | ja, e >>>= 7; return t[r] = e | 0, $o.bytes = r - n + 1, t } }); var Va = D((N0, Ha) => { Ha.exports = jo; var jg = 128, qa = 127; function jo(e, n) { var r = 0, n = n || 0, o = 0, s = n, i, a = e.length; do { if (s >= a || o > 49) throw jo.bytes = 0, new RangeError("Could not decode varint"); i = e[s++], r += o < 28 ? (i & qa) << o : (i & qa) * Math.pow(2, o), o += 7 } while (i >= jg); return jo.bytes = s - n, r } }); var Wa = D((R0, Ga) => { var zg = Math.pow(2, 7), Mg = Math.pow(2, 14), qg = Math.pow(2, 21), Hg = Math.pow(2, 28), Vg = Math.pow(2, 35), Gg = Math.pow(2, 42), Wg = Math.pow(2, 49), Jg = Math.pow(2, 56), Kg = Math.pow(2, 63); Ga.exports = function (e) { return e < zg ? 1 : e < Mg ? 2 : e < qg ? 3 : e < Hg ? 4 : e < Vg ? 5 : e < Gg ? 6 : e < Wg ? 7 : e < Jg ? 8 : e < Kg ? 9 : 10 } }); var Xr = D((O0, Ja) => { Ja.exports = { encode: Ma(), decode: Va(), encodingLength: Wa() } }); var ee = D((Z0, nc) => { "use strict"; function rc(e, t) { for (let r in t) Object.defineProperty(e, r, { value: t[r], enumerable: !0, configurable: !0 }); return e } function uy(e, t, r) { if (!e || typeof e == "string") throw new TypeError("Please pass an Error to err-code"); r || (r = {}), typeof t == "object" && (r = t, t = ""), t && (r.code = t); try { return rc(e, r) } catch { r.message = e.message, r.stack = e.stack; let o = function () { }; return o.prototype = Object.create(Object.getPrototypeOf(e)), rc(new o, r) } } nc.exports = uy }); var cc = D((i1, ac) => { function ly() { return typeof window < "u" && typeof window.process == "object" && window.process.type === "renderer" || typeof process < "u" && typeof process.versions == "object" && !!process.versions.electron || typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Electron") >= 0 } ac.exports = ly }); var fc = D((a1, uc) => { "use strict"; var py = cc(), en = typeof window == "object" && typeof document == "object" && document.nodeType === 9, ir = py(), dy = en && !ir, my = ir && !en, hy = ir && en, gy = typeof _s == "function" && typeof process < "u" && typeof process.release < "u" && process.release.name === "node" && !ir, yy = typeof importScripts == "function" && typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, wy = typeof process < "u" && typeof process.env < "u" && !1, by = typeof navigator < "u" && navigator.product === "ReactNative"; uc.exports = { isTest: wy, isElectron: ir, isElectronMain: my, isElectronRenderer: hy, isNode: gy, isBrowser: dy, isWebWorker: yy, isEnvWithDom: en, isReactNative: by } }); var mc = D((u1, dc) => { var _t = 1e3, kt = _t * 60, Ut = kt * 60, ft = Ut * 24, Ey = ft * 7, xy = ft * 365.25; dc.exports = function (e, t) { t = t || {}; var r = typeof e; if (r === "string" && e.length > 0) return Sy(e); if (r === "number" && isFinite(e)) return t.long ? Py(e) : Cy(e); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e)) }; function Sy(e) { if (e = String(e), !(e.length > 100)) { var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e); if (!!t) { var r = parseFloat(t[1]), n = (t[2] || "ms").toLowerCase(); switch (n) { case "years": case "year": case "yrs": case "yr": case "y": return r * xy; case "weeks": case "week": case "w": return r * Ey; case "days": case "day": case "d": return r * ft; case "hours": case "hour": case "hrs": case "hr": case "h": return r * Ut; case "minutes": case "minute": case "mins": case "min": case "m": return r * kt; case "seconds": case "second": case "secs": case "sec": case "s": return r * _t; case "milliseconds": case "millisecond": case "msecs": case "msec": case "ms": return r; default: return } } } } function Cy(e) { var t = Math.abs(e); return t >= ft ? Math.round(e / ft) + "d" : t >= Ut ? Math.round(e / Ut) + "h" : t >= kt ? Math.round(e / kt) + "m" : t >= _t ? Math.round(e / _t) + "s" : e + "ms" } function Py(e) { var t = Math.abs(e); return t >= ft ? tn(e, t, ft, "day") : t >= Ut ? tn(e, t, Ut, "hour") : t >= kt ? tn(e, t, kt, "minute") : t >= _t ? tn(e, t, _t, "second") : e + " ms" } function tn(e, t, r, n) { var o = t >= r * 1.5; return Math.round(e / r) + " " + n + (o ? "s" : "") } }); var gc = D((f1, hc) => { function Ty(e) { r.debug = r, r.default = r, r.coerce = c, r.disable = s, r.enable = o, r.enabled = i, r.humanize = mc(), r.destroy = p, Object.keys(e).forEach(d => { r[d] = e[d] }), r.names = [], r.skips = [], r.formatters = {}; function t(d) { let g = 0; for (let x = 0; x < d.length; x++)g = (g << 5) - g + d.charCodeAt(x), g |= 0; return r.colors[Math.abs(g) % r.colors.length] } r.selectColor = t; function r(d) { let g, x = null, N, v; function _(...U) { if (!_.enabled) return; let H = _, Z = Number(new Date), fe = Z - (g || Z); H.diff = fe, H.prev = g, H.curr = Z, g = Z, U[0] = r.coerce(U[0]), typeof U[0] != "string" && U.unshift("%O"); let J = 0; U[0] = U[0].replace(/%([a-zA-Z%])/g, (le, re) => { if (le === "%%") return "%"; J++; let pe = r.formatters[re]; if (typeof pe == "function") { let mt = U[J]; le = pe.call(H, mt), U.splice(J, 1), J-- } return le }), r.formatArgs.call(H, U), (H.log || r.log).apply(H, U) } return _.namespace = d, _.useColors = r.useColors(), _.color = r.selectColor(d), _.extend = n, _.destroy = r.destroy, Object.defineProperty(_, "enabled", { enumerable: !0, configurable: !1, get: () => x !== null ? x : (N !== r.namespaces && (N = r.namespaces, v = r.enabled(d)), v), set: U => { x = U } }), typeof r.init == "function" && r.init(_), _ } function n(d, g) { let x = r(this.namespace + (typeof g > "u" ? ":" : g) + d); return x.log = this.log, x } function o(d) { r.save(d), r.namespaces = d, r.names = [], r.skips = []; let g, x = (typeof d == "string" ? d : "").split(/[\s,]+/), N = x.length; for (g = 0; g < N; g++)!x[g] || (d = x[g].replace(/\*/g, ".*?"), d[0] === "-" ? r.skips.push(new RegExp("^" + d.slice(1) + "$")) : r.names.push(new RegExp("^" + d + "$"))) } function s() { let d = [...r.names.map(a), ...r.skips.map(a).map(g => "-" + g)].join(","); return r.enable(""), d } function i(d) { if (d[d.length - 1] === "*") return !0; let g, x; for (g = 0, x = r.skips.length; g < x; g++)if (r.skips[g].test(d)) return !1; for (g = 0, x = r.names.length; g < x; g++)if (r.names[g].test(d)) return !0; return !1 } function a(d) { return d.toString().substring(2, d.toString().length - 2).replace(/\.\*\?$/, "*") } function c(d) { return d instanceof Error ? d.stack || d.message : d } function p() { console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.") } return r.enable(r.load()), r } hc.exports = Ty }); var yc = D((ue, rn) => { ue.formatArgs = vy; ue.save = By; ue.load = Iy; ue.useColors = Ay; ue.storage = _y(); ue.destroy = (() => { let e = !1; return () => { e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")) } })(); ue.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"]; function Ay() { return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/) } function vy(e) { if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + rn.exports.humanize(this.diff), !this.useColors) return; let t = "color: " + this.color; e.splice(1, 0, t, "color: inherit"); let r = 0, n = 0; e[0].replace(/%[a-zA-Z%]/g, o => { o !== "%%" && (r++, o === "%c" && (n = r)) }), e.splice(n, 0, t) } ue.log = console.debug || console.log || (() => { }); function By(e) { try { e ? ue.storage.setItem("debug", e) : ue.storage.removeItem("debug") } catch { } } function Iy() { let e; try { e = ue.storage.getItem("debug") } catch { } return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e } function _y() { try { return localStorage } catch { } } rn.exports = gc()(ue); var { formatters: ky } = rn.exports; ky.j = function (e) { try { return JSON.stringify(e) } catch (t) { return "[UnexpectedJSONParseError]: " + t.message } } }); var Xo = D(on => { "use strict"; var Wo = class extends Error { constructor(t = "Request timed out") { super(t), this.name = "TimeoutError" } }; on.TimeoutError = Wo; var Jo = class extends Error { constructor(t = "The operation was aborted.") { super(t), this.name = "AbortError" } }; on.AbortError = Jo; var Ko = class extends Error { constructor(t) { super(t.statusText), this.name = "HTTPError", this.response = t } }; on.HTTPError = Ko }); var ar = D((Nt, wc) => { "use strict"; var Uy = function () { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof Fe < "u") return Fe; throw new Error("unable to locate global object") }, Fe = Uy(); wc.exports = Nt = Fe.fetch; Fe.fetch && (Nt.default = Fe.fetch.bind(Fe)); Nt.Headers = Fe.Headers; Nt.Request = Fe.Request; Nt.Response = Fe.Response }); var bc = D((g1, Qo) => { "use strict"; globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response ? Qo.exports = { default: globalThis.fetch, Headers: globalThis.Headers, Request: globalThis.Request, Response: globalThis.Response } : Qo.exports = { default: ar().default, Headers: ar().Headers, Request: ar().Request, Response: ar().Response } }); var Ec = D((y1, Dc) => { "use strict"; Dc.exports = bc() }); var Cc = D((w1, Sc) => { "use strict"; var { TimeoutError: Ny, AbortError: Ry } = Xo(), { Response: xc, Request: Oy, Headers: Yo, default: Ly } = Ec(), Fy = (e, t = {}) => { let r = new XMLHttpRequest; r.open(t.method || "GET", e.toString(), !0); let { timeout: n, headers: o } = t; if (n && n > 0 && n < 1 / 0 && (r.timeout = n), t.overrideMimeType != null && r.overrideMimeType(t.overrideMimeType), o) for (let [s, i] of new Yo(o)) r.setRequestHeader(s, i); return t.signal && (t.signal.onabort = () => r.abort()), t.onUploadProgress && (r.upload.onprogress = t.onUploadProgress), r.responseType = "arraybuffer", new Promise((s, i) => { let a = c => { switch (c.type) { case "error": { s(xc.error()); break } case "load": { s(new Zo(r.responseURL, r.response, { status: r.status, statusText: r.statusText, headers: zy(r.getAllResponseHeaders()) })); break } case "timeout": { i(new Ny); break } case "abort": { i(new Ry); break } default: break } }; r.onerror = a, r.onload = a, r.ontimeout = a, r.onabort = a, r.send(t.body) }) }, $y = Ly, jy = (e, t = {}) => t.onUploadProgress != null ? Fy(e, t) : $y(e, t), zy = e => { let t = new Yo; for (let r of e.trim().split(/[\r\n]+/)) { let n = r.indexOf(": "); n > 0 && t.set(r.slice(0, n), r.slice(n + 1)) } return t }, Zo = class extends xc { constructor(t, r, n) { super(r, n), Object.defineProperty(this, "url", { value: t }) } }; Sc.exports = { fetch: jy, Request: Oy, Headers: Yo } }); var Tc = D((b1, Pc) => { "use strict"; Pc.exports = e => { if (Object.prototype.toString.call(e) !== "[object Object]") return !1; let t = Object.getPrototypeOf(e); return t === null || t === Object.prototype } }); var ts = D((Ic, _c) => { "use strict"; var sn = Tc(), { hasOwnProperty: vc } = Object.prototype, { propertyIsEnumerable: My } = Object, Rt = (e, t, r) => Object.defineProperty(e, t, { value: r, writable: !0, enumerable: !0, configurable: !0 }), qy = Ic, Ac = { concatArrays: !1, ignoreUndefined: !1 }, an = e => { let t = []; for (let r in e) vc.call(e, r) && t.push(r); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); for (let n of r) My.call(e, n) && t.push(n) } return t }; function Ot(e) { return Array.isArray(e) ? Hy(e) : sn(e) ? Vy(e) : e } function Hy(e) { let t = e.slice(0, 0); return an(e).forEach(r => { Rt(t, r, Ot(e[r])) }), t } function Vy(e) { let t = Object.getPrototypeOf(e) === null ? Object.create(null) : {}; return an(e).forEach(r => { Rt(t, r, Ot(e[r])) }), t } var Bc = (e, t, r, n) => (r.forEach(o => { typeof t[o] > "u" && n.ignoreUndefined || (o in e && e[o] !== Object.getPrototypeOf(e) ? Rt(e, o, es(e[o], t[o], n)) : Rt(e, o, Ot(t[o]))) }), e), Gy = (e, t, r) => { let n = e.slice(0, 0), o = 0; return [e, t].forEach(s => { let i = []; for (let a = 0; a < s.length; a++)!vc.call(s, a) || (i.push(String(a)), s === e ? Rt(n, o++, s[a]) : Rt(n, o++, Ot(s[a]))); n = Bc(n, s, an(s).filter(a => !i.includes(a)), r) }), n }; function es(e, t, r) { return r.concatArrays && Array.isArray(e) && Array.isArray(t) ? Gy(e, t, r) : !sn(t) || !sn(e) ? Ot(t) : Bc(e, t, an(t), r) } _c.exports = function (...e) { let t = es(Ot(Ac), this !== qy && this || {}, Ac), r = { _: {} }; for (let n of e) if (n !== void 0) { if (!sn(n)) throw new TypeError("`" + n + "` is not an Option Object"); r = es(r, { _: n }, t) } return r._ } }); var ns = D((D1, Uc) => { "use strict"; var Wy = typeof navigator < "u" && navigator.product === "ReactNative"; function Jy() { return Wy ? "http://localhost" : self.location ? self.location.protocol + "//" + self.location.host : "" } var cr = self.URL, kc = Jy(), rs = class { constructor(t = "", r = kc) { this.super = new cr(t, r), this.path = this.pathname + this.search, this.auth = this.username && this.password ? this.username + ":" + this.password : null, this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null } get hash() { return this.super.hash } get host() { return this.super.host } get hostname() { return this.super.hostname } get href() { return this.super.href } get origin() { return this.super.origin } get password() { return this.super.password } get pathname() { return this.super.pathname } get port() { return this.super.port } get protocol() { return this.super.protocol } get search() { return this.super.search } get searchParams() { return this.super.searchParams } get username() { return this.super.username } set hash(t) { this.super.hash = t } set host(t) { this.super.host = t } set hostname(t) { this.super.hostname = t } set href(t) { this.super.href = t } set password(t) { this.super.password = t } set pathname(t) { this.super.pathname = t } set port(t) { this.super.port = t } set protocol(t) { this.super.protocol = t } set search(t) { this.super.search = t } set username(t) { this.super.username = t } static createObjectURL(t) { return cr.createObjectURL(t) } static revokeObjectURL(t) { cr.revokeObjectURL(t) } toJSON() { return this.super.toJSON() } toString() { return this.super.toString() } format() { return this.toString() } }; function Ky(e) { if (typeof e == "string") return new cr(e).toString(); if (!(e instanceof cr)) { let t = e.username && e.password ? `${e.username}:${e.password}@` : "", r = e.auth ? e.auth + "@" : "", n = e.port ? ":" + e.port : "", o = e.protocol ? e.protocol + "//" : "", s = e.host || "", i = e.hostname || "", a = e.search || (e.query ? "?" + e.query : ""), c = e.hash || "", p = e.pathname || "", d = e.path || p + a; return `${o}${t || r}${s || i + n}${d}${c}` } } Uc.exports = { URLWithLegacySupport: rs, URLSearchParams: self.URLSearchParams, defaultBase: kc, format: Ky } }); var Oc = D((E1, Rc) => { "use strict"; var { URLWithLegacySupport: Nc, format: Xy } = ns(); Rc.exports = (e, t = {}, r = {}, n) => { let o = t.protocol ? t.protocol.replace(":", "") : "http"; o = (r[o] || n || o) + ":"; let s; try { s = new Nc(e) } catch { s = {} } let i = Object.assign({}, t, { protocol: o || s.protocol, host: t.host || s.host }); return new Nc(e, Xy(i)).toString() } }); var Fc = D((x1, Lc) => { "use strict"; var { URLWithLegacySupport: Qy, format: Zy, URLSearchParams: Yy, defaultBase: ew } = ns(), tw = Oc(); Lc.exports = { URL: Qy, URLSearchParams: Yy, format: Zy, relative: tw, defaultBase: ew } }); var ss = D((S1, os) => { function $c(e) { let t = new globalThis.AbortController; function r() { t.abort(); for (let n of e) !n || !n.removeEventListener || n.removeEventListener("abort", r) } for (let n of e) if (!(!n || !n.addEventListener)) { if (n.aborted) { r(); break } n.addEventListener("abort", r) } return t.signal } os.exports = $c; os.exports.anySignal = $c }); var cn = D((C1, Vc) => { "use strict"; var { fetch: rw, Request: nw, Headers: ow } = Cc(), { TimeoutError: is, HTTPError: qc } = Xo(), jc = ts().bind({ ignoreUndefined: !0 }), { URL: zc, URLSearchParams: Mc } = Fc(), sw = ss(), iw = (e, t, r) => { if (t === void 0) return e; let n = Date.now(), o = () => Date.now() - n >= t; return new Promise((s, i) => { let a = setTimeout(() => { o() && (i(new is), r.abort()) }, t), c = p => g => { if (clearTimeout(a), o()) { i(new is); return } p(g) }; e.then(c(s), c(i)) }) }, aw = { throwHttpErrors: !0, credentials: "same-origin" }, Q = class { constructor(t = {}) { this.opts = jc(aw, t) } async fetch(t, r = {}) { let n = jc(this.opts, r), o = new ow(n.headers); if (typeof t != "string" && !(t instanceof zc || t instanceof nw)) throw new TypeError("`resource` must be a string, URL, or Request"); let s = new zc(t.toString(), n.base), { searchParams: i, transformSearchParams: a, json: c } = n; i && (typeof a == "function" ? s.search = a(new Mc(n.searchParams)) : s.search = new Mc(n.searchParams)), c && (n.body = JSON.stringify(n.json), o.set("content-type", "application/json")); let p = new AbortController, d = sw([p.signal, n.signal]), g = await iw(rw(s.toString(), { ...n, signal: d, timeout: void 0, headers: o }), n.timeout, p); if (!g.ok && n.throwHttpErrors) throw n.handleError && await n.handleError(g), new qc(g); return g.iterator = async function* () { yield* Hc(g.body) }, g.ndjson = async function* () { for await (let x of cw(g.iterator())) r.transform ? yield r.transform(x) : yield x }, g } post(t, r = {}) { return this.fetch(t, { ...r, method: "POST" }) } get(t, r = {}) { return this.fetch(t, { ...r, method: "GET" }) } put(t, r = {}) { return this.fetch(t, { ...r, method: "PUT" }) } delete(t, r = {}) { return this.fetch(t, { ...r, method: "DELETE" }) } options(t, r = {}) { return this.fetch(t, { ...r, method: "OPTIONS" }) } }, cw = async function* (e) { let t = new TextDecoder, r = ""; for await (let n of e) { r += t.decode(n, { stream: !0 }); let o = r.split(/\r?\n/); for (let s = 0; s < o.length - 1; s++) { let i = o[s].trim(); i.length > 0 && (yield JSON.parse(i)) } r = o[o.length - 1] } r += t.decode(), r = r.trim(), r.length !== 0 && (yield JSON.parse(r)) }, Hc = e => { if (lw(e)) { let t = e[Symbol.asyncIterator](); return { [Symbol.asyncIterator]() { return { next: t.next.bind(t), return(r) { return e.destroy(), typeof t.return == "function" ? t.return() : Promise.resolve({ done: !0, value: r }) } } } } } if (fw(e)) { let t = e.getReader(); return async function* () { try { for (; ;) { let { done: r, value: n } = await t.read(); if (r) return; n && (yield n) } } finally { t.releaseLock() } }() } if (uw(e)) return e; throw new TypeError("Body can't be converted to AsyncIterable") }, uw = e => typeof e == "object" && e !== null && typeof e[Symbol.asyncIterator] == "function", fw = e => e && typeof e.getReader == "function", lw = e => Object.prototype.hasOwnProperty.call(e, "readable") && Object.prototype.hasOwnProperty.call(e, "writable"); Q.HTTPError = qc; Q.TimeoutError = is; Q.streamToAsyncIterator = Hc; Q.post = (e, t) => new Q(t).post(e, t); Q.get = (e, t) => new Q(t).get(e, t); Q.put = (e, t) => new Q(t).put(e, t); Q.delete = (e, t) => new Q(t).delete(e, t); Q.options = (e, t) => new Q(t).options(e, t); Vc.exports = Q }); var dr = D((T2, cu) => { "use strict"; function Tw(e) { let [t, r] = e[Symbol.asyncIterator] ? [e[Symbol.asyncIterator](), Symbol.asyncIterator] : [e[Symbol.iterator](), Symbol.iterator], n = []; return { peek: () => t.next(), push: o => { n.push(o) }, next: () => n.length ? { done: !1, value: n.shift() } : t.next(), [r]() { return this } } } cu.exports = Tw }); var Lt = D((A2, uu) => { "use strict"; async function* Aw(e, t = {}) { let r = e.getReader(); try { for (; ;) { let n = await r.read(); if (n.done) return; yield n.value } } finally { t.preventCancel !== !0 && r.cancel(), r.releaseLock() } } uu.exports = Aw }); var cs = D((v2, fu) => { "use strict"; var vw = async e => { let t = []; for await (let r of e) t.push(r); return t }; fu.exports = vw }); var us = D((k2, yu) => { "use strict"; var Bw = async function* (e, t) { for await (let r of e) yield t(r) }; yu.exports = Bw }); var bu = D((U2, wu) => { "use strict"; wu.exports = Iw; function Iw(e, t) { for (var r = new Array(arguments.length - 1), n = 0, o = 2, s = !0; o < arguments.length;)r[n++] = arguments[o++]; return new Promise(function (a, c) { r[n] = function (d) { if (s) if (s = !1, d) c(d); else { for (var g = new Array(arguments.length - 1), x = 0; x < g.length;)g[x++] = arguments[x]; a.apply(null, g) } }; try { e.apply(t || null, r) } catch (p) { s && (s = !1, c(p)) } }) } }); var Su = D(xu => { "use strict"; var mn = xu; mn.length = function (t) { var r = t.length; if (!r) return 0; for (var n = 0; --r % 4 > 1 && t.charAt(r) === "=";)++n; return Math.ceil(t.length * 3) / 4 - n }; var Ft = new Array(64), Eu = new Array(123); for (Ae = 0; Ae < 64;)Eu[Ft[Ae] = Ae < 26 ? Ae + 65 : Ae < 52 ? Ae + 71 : Ae < 62 ? Ae - 4 : Ae - 59 | 43] = Ae++; var Ae; mn.encode = function (t, r, n) { for (var o = null, s = [], i = 0, a = 0, c; r < n;) { var p = t[r++]; switch (a) { case 0: s[i++] = Ft[p >> 2], c = (p & 3) << 4, a = 1; break; case 1: s[i++] = Ft[c | p >> 4], c = (p & 15) << 2, a = 2; break; case 2: s[i++] = Ft[c | p >> 6], s[i++] = Ft[p & 63], a = 0; break }i > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, s)), i = 0) } return a && (s[i++] = Ft[c], s[i++] = 61, a === 1 && (s[i++] = 61)), o ? (i && o.push(String.fromCharCode.apply(String, s.slice(0, i))), o.join("")) : String.fromCharCode.apply(String, s.slice(0, i)) }; var Du = "invalid encoding"; mn.decode = function (t, r, n) { for (var o = n, s = 0, i, a = 0; a < t.length;) { var c = t.charCodeAt(a++); if (c === 61 && s > 1) break; if ((c = Eu[c]) === void 0) throw Error(Du); switch (s) { case 0: i = c, s = 1; break; case 1: r[n++] = i << 2 | (c & 48) >> 4, i = c, s = 2; break; case 2: r[n++] = (i & 15) << 4 | (c & 60) >> 2, i = c, s = 3; break; case 3: r[n++] = (i & 3) << 6 | c, s = 0; break } } if (s === 1) throw Error(Du); return n - o }; mn.test = function (t) { return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t) } }); var Pu = D((R2, Cu) => { "use strict"; Cu.exports = hn; function hn() { this._listeners = {} } hn.prototype.on = function (t, r, n) { return (this._listeners[t] || (this._listeners[t] = [])).push({ fn: r, ctx: n || this }), this }; hn.prototype.off = function (t, r) { if (t === void 0) this._listeners = {}; else if (r === void 0) this._listeners[t] = []; else for (var n = this._listeners[t], o = 0; o < n.length;)n[o].fn === r ? n.splice(o, 1) : ++o; return this }; hn.prototype.emit = function (t) { var r = this._listeners[t]; if (r) { for (var n = [], o = 1; o < arguments.length;)n.push(arguments[o++]); for (o = 0; o < r.length;)r[o].fn.apply(r[o++].ctx, n) } return this } }); var ku = D((O2, _u) => { "use strict"; _u.exports = Tu(Tu); function Tu(e) { return typeof Float32Array < "u" ? function () { var t = new Float32Array([-0]), r = new Uint8Array(t.buffer), n = r[3] === 128; function o(c, p, d) { t[0] = c, p[d] = r[0], p[d + 1] = r[1], p[d + 2] = r[2], p[d + 3] = r[3] } function s(c, p, d) { t[0] = c, p[d] = r[3], p[d + 1] = r[2], p[d + 2] = r[1], p[d + 3] = r[0] } e.writeFloatLE = n ? o : s, e.writeFloatBE = n ? s : o; function i(c, p) { return r[0] = c[p], r[1] = c[p + 1], r[2] = c[p + 2], r[3] = c[p + 3], t[0] } function a(c, p) { return r[3] = c[p], r[2] = c[p + 1], r[1] = c[p + 2], r[0] = c[p + 3], t[0] } e.readFloatLE = n ? i : a, e.readFloatBE = n ? a : i }() : function () { function t(n, o, s, i) { var a = o < 0 ? 1 : 0; if (a && (o = -o), o === 0) n(1 / o > 0 ? 0 : 2147483648, s, i); else if (isNaN(o)) n(2143289344, s, i); else if (o > 34028234663852886e22) n((a << 31 | 2139095040) >>> 0, s, i); else if (o < 11754943508222875e-54) n((a << 31 | Math.round(o / 1401298464324817e-60)) >>> 0, s, i); else { var c = Math.floor(Math.log(o) / Math.LN2), p = Math.round(o * Math.pow(2, -c) * 8388608) & 8388607; n((a << 31 | c + 127 << 23 | p) >>> 0, s, i) } } e.writeFloatLE = t.bind(null, Au), e.writeFloatBE = t.bind(null, vu); function r(n, o, s) { var i = n(o, s), a = (i >> 31) * 2 + 1, c = i >>> 23 & 255, p = i & 8388607; return c === 255 ? p ? NaN : a * (1 / 0) : c === 0 ? a * 1401298464324817e-60 * p : a * Math.pow(2, c - 150) * (p + 8388608) } e.readFloatLE = r.bind(null, Bu), e.readFloatBE = r.bind(null, Iu) }(), typeof Float64Array < "u" ? function () { var t = new Float64Array([-0]), r = new Uint8Array(t.buffer), n = r[7] === 128; function o(c, p, d) { t[0] = c, p[d] = r[0], p[d + 1] = r[1], p[d + 2] = r[2], p[d + 3] = r[3], p[d + 4] = r[4], p[d + 5] = r[5], p[d + 6] = r[6], p[d + 7] = r[7] } function s(c, p, d) { t[0] = c, p[d] = r[7], p[d + 1] = r[6], p[d + 2] = r[5], p[d + 3] = r[4], p[d + 4] = r[3], p[d + 5] = r[2], p[d + 6] = r[1], p[d + 7] = r[0] } e.writeDoubleLE = n ? o : s, e.writeDoubleBE = n ? s : o; function i(c, p) { return r[0] = c[p], r[1] = c[p + 1], r[2] = c[p + 2], r[3] = c[p + 3], r[4] = c[p + 4], r[5] = c[p + 5], r[6] = c[p + 6], r[7] = c[p + 7], t[0] } function a(c, p) { return r[7] = c[p], r[6] = c[p + 1], r[5] = c[p + 2], r[4] = c[p + 3], r[3] = c[p + 4], r[2] = c[p + 5], r[1] = c[p + 6], r[0] = c[p + 7], t[0] } e.readDoubleLE = n ? i : a, e.readDoubleBE = n ? a : i }() : function () { function t(n, o, s, i, a, c) { var p = i < 0 ? 1 : 0; if (p && (i = -i), i === 0) n(0, a, c + o), n(1 / i > 0 ? 0 : 2147483648, a, c + s); else if (isNaN(i)) n(0, a, c + o), n(2146959360, a, c + s); else if (i > 17976931348623157e292) n(0, a, c + o), n((p << 31 | 2146435072) >>> 0, a, c + s); else { var d; if (i < 22250738585072014e-324) d = i / 5e-324, n(d >>> 0, a, c + o), n((p << 31 | d / 4294967296) >>> 0, a, c + s); else { var g = Math.floor(Math.log(i) / Math.LN2); g === 1024 && (g = 1023), d = i * Math.pow(2, -g), n(d * 4503599627370496 >>> 0, a, c + o), n((p << 31 | g + 1023 << 20 | d * 1048576 & 1048575) >>> 0, a, c + s) } } } e.writeDoubleLE = t.bind(null, Au, 0, 4), e.writeDoubleBE = t.bind(null, vu, 4, 0); function r(n, o, s, i, a) { var c = n(i, a + o), p = n(i, a + s), d = (p >> 31) * 2 + 1, g = p >>> 20 & 2047, x = 4294967296 * (p & 1048575) + c; return g === 2047 ? x ? NaN : d * (1 / 0) : g === 0 ? d * 5e-324 * x : d * Math.pow(2, g - 1075) * (x + 4503599627370496) } e.readDoubleLE = r.bind(null, Bu, 0, 4), e.readDoubleBE = r.bind(null, Iu, 4, 0) }(), e } function Au(e, t, r) { t[r] = e & 255, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24 } function vu(e, t, r) { t[r] = e >>> 24, t[r + 1] = e >>> 16 & 255, t[r + 2] = e >>> 8 & 255, t[r + 3] = e & 255 } function Bu(e, t) { return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0 } function Iu(e, t) { return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0 } }); var Uu = D((exports, module) => { "use strict"; module.exports = inquire; function inquire(moduleName) { try { var mod = eval("quire".replace(/^/, "re"))(moduleName); if (mod && (mod.length || Object.keys(mod).length)) return mod } catch (e) { } return null } }); var Ru = D(Nu => { "use strict"; var fs = Nu; fs.length = function (t) { for (var r = 0, n = 0, o = 0; o < t.length; ++o)n = t.charCodeAt(o), n < 128 ? r += 1 : n < 2048 ? r += 2 : (n & 64512) === 55296 && (t.charCodeAt(o + 1) & 64512) === 56320 ? (++o, r += 4) : r += 3; return r }; fs.read = function (t, r, n) { var o = n - r; if (o < 1) return ""; for (var s = null, i = [], a = 0, c; r < n;)c = t[r++], c < 128 ? i[a++] = c : c > 191 && c < 224 ? i[a++] = (c & 31) << 6 | t[r++] & 63 : c > 239 && c < 365 ? (c = ((c & 7) << 18 | (t[r++] & 63) << 12 | (t[r++] & 63) << 6 | t[r++] & 63) - 65536, i[a++] = 55296 + (c >> 10), i[a++] = 56320 + (c & 1023)) : i[a++] = (c & 15) << 12 | (t[r++] & 63) << 6 | t[r++] & 63, a > 8191 && ((s || (s = [])).push(String.fromCharCode.apply(String, i)), a = 0); return s ? (a && s.push(String.fromCharCode.apply(String, i.slice(0, a))), s.join("")) : String.fromCharCode.apply(String, i.slice(0, a)) }; fs.write = function (t, r, n) { for (var o = n, s, i, a = 0; a < t.length; ++a)s = t.charCodeAt(a), s < 128 ? r[n++] = s : s < 2048 ? (r[n++] = s >> 6 | 192, r[n++] = s & 63 | 128) : (s & 64512) === 55296 && ((i = t.charCodeAt(a + 1)) & 64512) === 56320 ? (s = 65536 + ((s & 1023) << 10) + (i & 1023), ++a, r[n++] = s >> 18 | 240, r[n++] = s >> 12 & 63 | 128, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128) : (r[n++] = s >> 12 | 224, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128); return n - o } }); var Lu = D((F2, Ou) => { "use strict"; Ou.exports = _w; function _w(e, t, r) { var n = r || 8192, o = n >>> 1, s = null, i = n; return function (c) { if (c < 1 || c > o) return e(c); i + c > n && (s = e(n), i = 0); var p = t.call(s, i, i += c); return i & 7 && (i = (i | 7) + 1), p } } }); var $u = D(($2, Fu) => { "use strict"; Fu.exports = W; var hr = Ye(); function W(e, t) { this.lo = e >>> 0, this.hi = t >>> 0 } var pt = W.zero = new W(0, 0); pt.toNumber = function () { return 0 }; pt.zzEncode = pt.zzDecode = function () { return this }; pt.length = function () { return 1 }; var kw = W.zeroHash = "\0\0\0\0\0\0\0\0"; W.fromNumber = function (t) { if (t === 0) return pt; var r = t < 0; r && (t = -t); var n = t >>> 0, o = (t - n) / 4294967296 >>> 0; return r && (o = ~o >>> 0, n = ~n >>> 0, ++n > 4294967295 && (n = 0, ++o > 4294967295 && (o = 0))), new W(n, o) }; W.from = function (t) { if (typeof t == "number") return W.fromNumber(t); if (hr.isString(t)) if (hr.Long) t = hr.Long.fromString(t); else return W.fromNumber(parseInt(t, 10)); return t.low || t.high ? new W(t.low >>> 0, t.high >>> 0) : pt }; W.prototype.toNumber = function (t) { if (!t && this.hi >>> 31) { var r = ~this.lo + 1 >>> 0, n = ~this.hi >>> 0; return r || (n = n + 1 >>> 0), -(r + n * 4294967296) } return this.lo + this.hi * 4294967296 }; W.prototype.toLong = function (t) { return hr.Long ? new hr.Long(this.lo | 0, this.hi | 0, Boolean(t)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(t) } }; var Ze = String.prototype.charCodeAt; W.fromHash = function (t) { return t === kw ? pt : new W((Ze.call(t, 0) | Ze.call(t, 1) << 8 | Ze.call(t, 2) << 16 | Ze.call(t, 3) << 24) >>> 0, (Ze.call(t, 4) | Ze.call(t, 5) << 8 | Ze.call(t, 6) << 16 | Ze.call(t, 7) << 24) >>> 0) }; W.prototype.toHash = function () { return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24) }; W.prototype.zzEncode = function () { var t = this.hi >> 31; return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t) >>> 0, this.lo = (this.lo << 1 ^ t) >>> 0, this }; W.prototype.zzDecode = function () { var t = -(this.lo & 1); return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t) >>> 0, this.hi = (this.hi >>> 1 ^ t) >>> 0, this }; W.prototype.length = function () { var t = this.lo, r = (this.lo >>> 28 | this.hi << 4) >>> 0, n = this.hi >>> 24; return n === 0 ? r === 0 ? t < 16384 ? t < 128 ? 1 : 2 : t < 2097152 ? 3 : 4 : r < 16384 ? r < 128 ? 5 : 6 : r < 2097152 ? 7 : 8 : n < 128 ? 9 : 10 } }); var Ye = D(ls => { "use strict"; var b = ls; b.asPromise = bu(); b.base64 = Su(); b.EventEmitter = Pu(); b.float = ku(); b.inquire = Uu(); b.utf8 = Ru(); b.pool = Lu(); b.LongBits = $u(); b.isNode = Boolean(typeof globalThis < "u" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node); b.global = b.isNode && globalThis || typeof window < "u" && window || typeof self < "u" && self || ls; b.emptyArray = Object.freeze ? Object.freeze([]) : []; b.emptyObject = Object.freeze ? Object.freeze({}) : {}; b.isInteger = Number.isInteger || function (t) { return typeof t == "number" && isFinite(t) && Math.floor(t) === t }; b.isString = function (t) { return typeof t == "string" || t instanceof String }; b.isObject = function (t) { return t && typeof t == "object" }; b.isset = b.isSet = function (t, r) { var n = t[r]; return n != null && t.hasOwnProperty(r) ? typeof n != "object" || (Array.isArray(n) ? n.length : Object.keys(n).length) > 0 : !1 }; b.Buffer = function () { try { var e = b.inquire("buffer").Buffer; return e.prototype.utf8Write ? e : null } catch { return null } }(); b._Buffer_from = null; b._Buffer_allocUnsafe = null; b.newBuffer = function (t) { return typeof t == "number" ? b.Buffer ? b._Buffer_allocUnsafe(t) : new b.Array(t) : b.Buffer ? b._Buffer_from(t) : typeof Uint8Array > "u" ? t : new Uint8Array(t) }; b.Array = typeof Uint8Array < "u" ? Uint8Array : Array; b.Long = b.global.dcodeIO && b.global.dcodeIO.Long || b.global.Long || b.inquire("long"); b.key2Re = /^true|false|0|1$/; b.key32Re = /^-?(?:0|[1-9][0-9]*)$/; b.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/; b.longToHash = function (t) { return t ? b.LongBits.from(t).toHash() : b.LongBits.zeroHash }; b.longFromHash = function (t, r) { var n = b.LongBits.fromHash(t); return b.Long ? b.Long.fromBits(n.lo, n.hi, r) : n.toNumber(Boolean(r)) }; function ju(e, t, r) { for (var n = Object.keys(t), o = 0; o < n.length; ++o)(e[n[o]] === void 0 || !r) && (e[n[o]] = t[n[o]]); return e } b.merge = ju; b.lcFirst = function (t) { return t.charAt(0).toLowerCase() + t.substring(1) }; function zu(e) { function t(r, n) { if (!(this instanceof t)) return new t(r, n); Object.defineProperty(this, "message", { get: function () { return r } }), Error.captureStackTrace ? Error.captureStackTrace(this, t) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), n && ju(this, n) } return (t.prototype = Object.create(Error.prototype)).constructor = t, Object.defineProperty(t.prototype, "name", { get: function () { return e } }), t.prototype.toString = function () { return this.name + ": " + this.message }, t } b.newError = zu; b.ProtocolError = zu("ProtocolError"); b.oneOfGetter = function (t) { for (var r = {}, n = 0; n < t.length; ++n)r[t[n]] = 1; return function () { for (var o = Object.keys(this), s = o.length - 1; s > -1; --s)if (r[o[s]] === 1 && this[o[s]] !== void 0 && this[o[s]] !== null) return o[s] } }; b.oneOfSetter = function (t) { return function (r) { for (var n = 0; n < t.length; ++n)t[n] !== r && delete this[t[n]] } }; b.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }; b._configure = function () { var e = b.Buffer; if (!e) { b._Buffer_from = b._Buffer_allocUnsafe = null; return } b._Buffer_from = e.from !== Uint8Array.from && e.from || function (r, n) { return new e(r, n) }, b._Buffer_allocUnsafe = e.allocUnsafe || function (r) { return new e(r) } } }); var ws = D((z2, Vu) => { "use strict"; Vu.exports = B; var ye = Ye(), ps, gn = ye.LongBits, Mu = ye.base64, qu = ye.utf8; function gr(e, t, r) { this.fn = e, this.len = t, this.next = void 0, this.val = r } function ms() { } function Uw(e) { this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states } function B() { this.len = 0, this.head = new gr(ms, 0, 0), this.tail = this.head, this.states = null } var Hu = function () { return ye.Buffer ? function () { return (B.create = function () { return new ps })() } : function () { return new B } }; B.create = Hu(); B.alloc = function (t) { return new ye.Array(t) }; ye.Array !== Array && (B.alloc = ye.pool(B.alloc, ye.Array.prototype.subarray)); B.prototype._push = function (t, r, n) { return this.tail = this.tail.next = new gr(t, r, n), this.len += r, this }; function hs(e, t, r) { t[r] = e & 255 } function Nw(e, t, r) { for (; e > 127;)t[r++] = e & 127 | 128, e >>>= 7; t[r] = e } function gs(e, t) { this.len = e, this.next = void 0, this.val = t } gs.prototype = Object.create(gr.prototype); gs.prototype.fn = Nw; B.prototype.uint32 = function (t) { return this.len += (this.tail = this.tail.next = new gs((t = t >>> 0) < 128 ? 1 : t < 16384 ? 2 : t < 2097152 ? 3 : t < 268435456 ? 4 : 5, t)).len, this }; B.prototype.int32 = function (t) { return t < 0 ? this._push(ys, 10, gn.fromNumber(t)) : this.uint32(t) }; B.prototype.sint32 = function (t) { return this.uint32((t << 1 ^ t >> 31) >>> 0) }; function ys(e, t, r) { for (; e.hi;)t[r++] = e.lo & 127 | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7; for (; e.lo > 127;)t[r++] = e.lo & 127 | 128, e.lo = e.lo >>> 7; t[r++] = e.lo } B.prototype.uint64 = function (t) { var r = gn.from(t); return this._push(ys, r.length(), r) }; B.prototype.int64 = B.prototype.uint64; B.prototype.sint64 = function (t) { var r = gn.from(t).zzEncode(); return this._push(ys, r.length(), r) }; B.prototype.bool = function (t) { return this._push(hs, 1, t ? 1 : 0) }; function ds(e, t, r) { t[r] = e & 255, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24 } B.prototype.fixed32 = function (t) { return this._push(ds, 4, t >>> 0) }; B.prototype.sfixed32 = B.prototype.fixed32; B.prototype.fixed64 = function (t) { var r = gn.from(t); return this._push(ds, 4, r.lo)._push(ds, 4, r.hi) }; B.prototype.sfixed64 = B.prototype.fixed64; B.prototype.float = function (t) { return this._push(ye.float.writeFloatLE, 4, t) }; B.prototype.double = function (t) { return this._push(ye.float.writeDoubleLE, 8, t) }; var Rw = ye.Array.prototype.set ? function (t, r, n) { r.set(t, n) } : function (t, r, n) { for (var o = 0; o < t.length; ++o)r[n + o] = t[o] }; B.prototype.bytes = function (t) { var r = t.length >>> 0; if (!r) return this._push(hs, 1, 0); if (ye.isString(t)) { var n = B.alloc(r = Mu.length(t)); Mu.decode(t, n, 0), t = n } return this.uint32(r)._push(Rw, r, t) }; B.prototype.string = function (t) { var r = qu.length(t); return r ? this.uint32(r)._push(qu.write, r, t) : this._push(hs, 1, 0) }; B.prototype.fork = function () { return this.states = new Uw(this), this.head = this.tail = new gr(ms, 0, 0), this.len = 0, this }; B.prototype.reset = function () { return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new gr(ms, 0, 0), this.len = 0), this }; B.prototype.ldelim = function () { var t = this.head, r = this.tail, n = this.len; return this.reset().uint32(n), n && (this.tail.next = t.next, this.tail = r, this.len += n), this }; B.prototype.finish = function () { for (var t = this.head.next, r = this.constructor.alloc(this.len), n = 0; t;)t.fn(t.val, r, n), n += t.len, t = t.next; return r }; B._configure = function (e) { ps = e, B.create = Hu(), ps._configure() } }); var Ju = D((M2, Wu) => { "use strict"; Wu.exports = Ne; var Gu = ws(); (Ne.prototype = Object.create(Gu.prototype)).constructor = Ne; var et = Ye(); function Ne() { Gu.call(this) } Ne._configure = function () { Ne.alloc = et._Buffer_allocUnsafe, Ne.writeBytesBuffer = et.Buffer && et.Buffer.prototype instanceof Uint8Array && et.Buffer.prototype.set.name === "set" ? function (t, r, n) { r.set(t, n) } : function (t, r, n) { if (t.copy) t.copy(r, n, 0, t.length); else for (var o = 0; o < t.length;)r[n++] = t[o++] } }; Ne.prototype.bytes = function (t) { et.isString(t) && (t = et._Buffer_from(t, "base64")); var r = t.length >>> 0; return this.uint32(r), r && this._push(Ne.writeBytesBuffer, r, t), this }; function Ow(e, t, r) { e.length < 40 ? et.utf8.write(e, t, r) : t.utf8Write ? t.utf8Write(e, r) : t.write(e, r) } Ne.prototype.string = function (t) { var r = et.Buffer.byteLength(t); return this.uint32(r), r && this._push(Ow, r, t), this }; Ne._configure() }); var Es = D((q2, Yu) => { "use strict"; Yu.exports = L; var Re = Ye(), Ds, Qu = Re.LongBits, Lw = Re.utf8; function ve(e, t) { return RangeError("index out of range: " + e.pos + " + " + (t || 1) + " > " + e.len) } function L(e) { this.buf = e, this.pos = 0, this.len = e.length } var Ku = typeof Uint8Array < "u" ? function (t) { if (t instanceof Uint8Array || Array.isArray(t)) return new L(t); throw Error("illegal buffer") } : function (t) { if (Array.isArray(t)) return new L(t); throw Error("illegal buffer") }, Zu = function () { return Re.Buffer ? function (r) { return (L.create = function (o) { return Re.Buffer.isBuffer(o) ? new Ds(o) : Ku(o) })(r) } : Ku }; L.create = Zu(); L.prototype._slice = Re.Array.prototype.subarray || Re.Array.prototype.slice; L.prototype.uint32 = function () { var t = 4294967295; return function () { if (t = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (t = (t | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (t = (t | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (t = (t | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (t = (t | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return t; if ((this.pos += 5) > this.len) throw this.pos = this.len, ve(this, 10); return t } }(); L.prototype.int32 = function () { return this.uint32() | 0 }; L.prototype.sint32 = function () { var t = this.uint32(); return t >>> 1 ^ -(t & 1) | 0 }; function bs() { var e = new Qu(0, 0), t = 0; if (this.len - this.pos > 4) { for (; t < 4; ++t)if (e.lo = (e.lo | (this.buf[this.pos] & 127) << t * 7) >>> 0, this.buf[this.pos++] < 128) return e; if (e.lo = (e.lo | (this.buf[this.pos] & 127) << 28) >>> 0, e.hi = (e.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128) return e; t = 0 } else { for (; t < 3; ++t) { if (this.pos >= this.len) throw ve(this); if (e.lo = (e.lo | (this.buf[this.pos] & 127) << t * 7) >>> 0, this.buf[this.pos++] < 128) return e } return e.lo = (e.lo | (this.buf[this.pos++] & 127) << t * 7) >>> 0, e } if (this.len - this.pos > 4) { for (; t < 5; ++t)if (e.hi = (e.hi | (this.buf[this.pos] & 127) << t * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return e } else for (; t < 5; ++t) { if (this.pos >= this.len) throw ve(this); if (e.hi = (e.hi | (this.buf[this.pos] & 127) << t * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return e } throw Error("invalid varint encoding") } L.prototype.bool = function () { return this.uint32() !== 0 }; function yn(e, t) { return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0 } L.prototype.fixed32 = function () { if (this.pos + 4 > this.len) throw ve(this, 4); return yn(this.buf, this.pos += 4) }; L.prototype.sfixed32 = function () { if (this.pos + 4 > this.len) throw ve(this, 4); return yn(this.buf, this.pos += 4) | 0 }; function Xu() { if (this.pos + 8 > this.len) throw ve(this, 8); return new Qu(yn(this.buf, this.pos += 4), yn(this.buf, this.pos += 4)) } L.prototype.float = function () { if (this.pos + 4 > this.len) throw ve(this, 4); var t = Re.float.readFloatLE(this.buf, this.pos); return this.pos += 4, t }; L.prototype.double = function () { if (this.pos + 8 > this.len) throw ve(this, 4); var t = Re.float.readDoubleLE(this.buf, this.pos); return this.pos += 8, t }; L.prototype.bytes = function () { var t = this.uint32(), r = this.pos, n = this.pos + t; if (n > this.len) throw ve(this, t); return this.pos += t, Array.isArray(this.buf) ? this.buf.slice(r, n) : r === n ? new this.buf.constructor(0) : this._slice.call(this.buf, r, n) }; L.prototype.string = function () { var t = this.bytes(); return Lw.read(t, 0, t.length) }; L.prototype.skip = function (t) { if (typeof t == "number") { if (this.pos + t > this.len) throw ve(this, t); this.pos += t } else do if (this.pos >= this.len) throw ve(this); while (this.buf[this.pos++] & 128); return this }; L.prototype.skipType = function (e) { switch (e) { case 0: this.skip(); break; case 1: this.skip(8); break; case 2: this.skip(this.uint32()); break; case 3: for (; (e = this.uint32() & 7) !== 4;)this.skipType(e); break; case 5: this.skip(4); break; default: throw Error("invalid wire type " + e + " at offset " + this.pos) }return this }; L._configure = function (e) { Ds = e, L.create = Zu(), Ds._configure(); var t = Re.Long ? "toLong" : "toNumber"; Re.merge(L.prototype, { int64: function () { return bs.call(this)[t](!1) }, uint64: function () { return bs.call(this)[t](!0) }, sint64: function () { return bs.call(this).zzDecode()[t](!1) }, fixed64: function () { return Xu.call(this)[t](!0) }, sfixed64: function () { return Xu.call(this)[t](!1) } }) } }); var nf = D((H2, rf) => { "use strict"; rf.exports = dt; var tf = Es(); (dt.prototype = Object.create(tf.prototype)).constructor = dt; var ef = Ye(); function dt(e) { tf.call(this, e) } dt._configure = function () { ef.Buffer && (dt.prototype._slice = ef.Buffer.prototype.slice) }; dt.prototype.string = function () { var t = this.uint32(); return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + t, this.len)) }; dt._configure() }); var sf = D((V2, of) => { "use strict"; of.exports = yr; var xs = Ye(); (yr.prototype = Object.create(xs.EventEmitter.prototype)).constructor = yr; function yr(e, t, r) { if (typeof e != "function") throw TypeError("rpcImpl must be a function"); xs.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = Boolean(t), this.responseDelimited = Boolean(r) } yr.prototype.rpcCall = function e(t, r, n, o, s) { if (!o) throw TypeError("request must be specified"); var i = this; if (!s) return xs.asPromise(e, i, t, r, n, o); if (!i.rpcImpl) { setTimeout(function () { s(Error("already ended")) }, 0); return } try { return i.rpcImpl(t, r[i.requestDelimited ? "encodeDelimited" : "encode"](o).finish(), function (c, p) { if (c) return i.emit("error", c, t), s(c); if (p === null) { i.end(!0); return } if (!(p instanceof n)) try { p = n[i.responseDelimited ? "decodeDelimited" : "decode"](p) } catch (d) { return i.emit("error", d, t), s(d) } return i.emit("data", p, t), s(null, p) }) } catch (a) { i.emit("error", a, t), setTimeout(function () { s(a) }, 0); return } }; yr.prototype.end = function (t) { return this.rpcImpl && (t || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this } }); var cf = D(af => { "use strict"; var Fw = af; Fw.Service = sf() }); var ff = D((W2, uf) => { "use strict"; uf.exports = {} }); var df = D(pf => { "use strict"; var te = pf; te.build = "minimal"; te.Writer = ws(); te.BufferWriter = Ju(); te.Reader = Es(); te.BufferReader = nf(); te.util = Ye(); te.rpc = cf(); te.roots = ff(); te.configure = lf; function lf() { te.util._configure(), te.Writer._configure(te.BufferWriter), te.Reader._configure(te.BufferReader) } lf() }); var hf = D((K2, mf) => { "use strict"; mf.exports = df() }); var qf = D((j8, Mf) => { "use strict"; var Hw = async e => { for await (let t of e) return t }; Mf.exports = Hw }); var br = D((z8, Hf) => { "use strict"; var Vw = async e => { let t; for await (let r of e) t = r; return t }; Hf.exports = Vw }); var yl = D((Fx, gl) => { gl.exports = e => { if (e[Symbol.asyncIterator]) return e; if (e.getReader) return async function* () { let t = e.getReader(); try { for (; ;) { let { done: r, value: n } = await t.read(); if (r) return; yield n } } finally { t.releaseLock() } }(); throw new Error("unknown stream") } }); var Jp = D((RT, Wp) => { "use strict"; var Gp = Lt(); function cb(e) { return typeof e.stream == "function" ? Gp(e.stream()) : Gp(new Response(e).body) } Wp.exports = cb }); var xd = D(() => { }); var Cd = D((VA, Sd) => { "use strict"; var fb = cn(), lb = (e, t) => ({ path: decodeURIComponent(new URL(e).pathname.split("/").pop() || ""), content: pb(e, t) }); async function* pb(e, t) { yield* (await new fb().get(e, t)).iterator() } Sd.exports = lb }); var gb = {}; F(gb, { CID: () => m, create: () => mb, globSource: () => hb, multiaddr: () => P, urlSource: () => Td.default }); var kd = e => Promise.reject(new Error(`No base found for "${e}"`)), Sr = class { constructor(t) { this._basesByName = {}, this._basesByPrefix = {}, this._loadBase = t.loadBase || kd; for (let r of t.bases) this.addBase(r) } addBase(t) { if (this._basesByName[t.name] || this._basesByPrefix[t.prefix]) throw new Error(`Codec already exists for codec "${t.name}"`); this._basesByName[t.name] = t, this._basesByPrefix[t.prefix] = t } removeBase(t) { delete this._basesByName[t.name], delete this._basesByPrefix[t.prefix] } async getBase(t) { if (this._basesByName[t]) return this._basesByName[t]; if (this._basesByPrefix[t]) return this._basesByPrefix[t]; let r = await this._loadBase(t); return this._basesByName[r.name] == null && this._basesByPrefix[r.prefix] == null && this.addBase(r), r } listBases() { return Object.values(this._basesByName) } }; var Ud = e => Promise.reject(new Error(`No codec found for "${e}"`)), Cr = class { constructor(t) { this._codecsByName = {}, this._codecsByCode = {}, this._loadCodec = t.loadCodec || Ud; for (let r of t.codecs) this.addCodec(r) } addCodec(t) { if (this._codecsByName[t.name] || this._codecsByCode[t.code]) throw new Error(`Resolver already exists for codec "${t.name}"`); this._codecsByName[t.name] = t, this._codecsByCode[t.code] = t } removeCodec(t) { delete this._codecsByName[t.name], delete this._codecsByCode[t.code] } async getCodec(t) { let r = typeof t == "string" ? this._codecsByName : this._codecsByCode; if (r[t]) return r[t]; let n = await this._loadCodec(t); return r[t] == null && this.addCodec(n), n } listCodecs() { return Object.values(this._codecsByName) } }; var Nd = e => Promise.reject(new Error(`No hasher found for "${e}"`)), Pr = class { constructor(t) { this._hashersByName = {}, this._hashersByCode = {}, this._loadHasher = t.loadHasher || Nd; for (let r of t.hashers) this.addHasher(r) } addHasher(t) { if (this._hashersByName[t.name] || this._hashersByCode[t.code]) throw new Error(`Resolver already exists for codec "${t.name}"`); this._hashersByName[t.name] = t, this._hashersByCode[t.code] = t } removeHasher(t) { delete this._hashersByName[t.name], delete this._hashersByCode[t.code] } async getHasher(t) { let r = typeof t == "string" ? this._hashersByName : this._hashersByCode; if (r[t]) return r[t]; let n = await this._loadHasher(t); return r[t] == null && this.addHasher(n), n } listHashers() { return Object.values(this._hashersByName) } }; var Hn = {}; F(Hn, { code: () => _m, createLink: () => ni, createNode: () => ri, decode: () => Um, encode: () => km, name: () => Im, prepare: () => Mn, validate: () => qn }); C(); var Dm = new TextDecoder; function jn(e, t) { let r = 0; for (let n = 0; ; n += 7) { if (n >= 64) throw new Error("protobuf: varint overflow"); if (t >= e.length) throw new Error("protobuf: unexpected end of data"); let o = e[t++]; if (r += n < 28 ? (o & 127) << n : (o & 127) * 2 ** n, o < 128) break } return [r, t] } function Ir(e, t) { let r;[r, t] = jn(e, t); let n = t + r; if (r < 0 || n < 0) throw new Error("protobuf: invalid length"); if (n > e.length) throw new Error("protobuf: unexpected end of data"); return [e.subarray(t, n), n] } function Js(e, t) { let r; return [r, t] = jn(e, t), [r & 7, r >> 3, t] } function Em(e) { let t = {}, r = e.length, n = 0; for (; n < r;) { let o, s; if ([o, s, n] = Js(e, n), s === 1) { if (t.Hash) throw new Error("protobuf: (PBLink) duplicate Hash section"); if (o !== 2) throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Hash`); if (t.Name !== void 0) throw new Error("protobuf: (PBLink) invalid order, found Name before Hash"); if (t.Tsize !== void 0) throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[t.Hash, n] = Ir(e, n) } else if (s === 2) { if (t.Name !== void 0) throw new Error("protobuf: (PBLink) duplicate Name section"); if (o !== 2) throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Name`); if (t.Tsize !== void 0) throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name"); let i;[i, n] = Ir(e, n), t.Name = Dm.decode(i) } else if (s === 3) { if (t.Tsize !== void 0) throw new Error("protobuf: (PBLink) duplicate Tsize section"); if (o !== 0) throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Tsize`);[t.Tsize, n] = jn(e, n) } else throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${s}`) } if (n > r) throw new Error("protobuf: (PBLink) unexpected end of data"); return t } function Ks(e) { let t = e.length, r = 0, n, o = !1, s; for (; r < t;) { let a, c; if ([a, c, r] = Js(e, r), a !== 2) throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${a}`); if (c === 1) { if (s) throw new Error("protobuf: (PBNode) duplicate Data section");[s, r] = Ir(e, r), n && (o = !0) } else if (c === 2) { if (o) throw new Error("protobuf: (PBNode) duplicate Links section"); n || (n = []); let p;[p, r] = Ir(e, r), n.push(Em(p)) } else throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${c}`) } if (r > t) throw new Error("protobuf: (PBNode) unexpected end of data"); let i = {}; return s && (i.Data = s), i.Links = n || [], i } var Qs = new TextEncoder, Xs = 2 ** 32, xm = 2 ** 31; function Sm(e, t) { let r = t.length; if (typeof e.Tsize == "number") { if (e.Tsize < 0) throw new Error("Tsize cannot be negative"); if (!Number.isSafeInteger(e.Tsize)) throw new Error("Tsize too large for encoding"); r = Wt(t, r, e.Tsize) - 1, t[r] = 24 } if (typeof e.Name == "string") { let n = Qs.encode(e.Name); r -= n.length, t.set(n, r), r = Wt(t, r, n.length) - 1, t[r] = 18 } return e.Hash && (r -= e.Hash.length, t.set(e.Hash, r), r = Wt(t, r, e.Hash.length) - 1, t[r] = 10), t.length - r } function Zs(e) { let t = Pm(e), r = new Uint8Array(t), n = t; if (e.Data && (n -= e.Data.length, r.set(e.Data, n), n = Wt(r, n, e.Data.length) - 1, r[n] = 10), e.Links) for (let o = e.Links.length - 1; o >= 0; o--) { let s = Sm(e.Links[o], r.subarray(0, n)); n -= s, n = Wt(r, n, s) - 1, r[n] = 18 } return r } function Cm(e) { let t = 0; if (e.Hash) { let r = e.Hash.length; t += 1 + r + bt(r) } if (typeof e.Name == "string") { let r = Qs.encode(e.Name).length; t += 1 + r + bt(r) } return typeof e.Tsize == "number" && (t += 1 + bt(e.Tsize)), t } function Pm(e) { let t = 0; if (e.Data) { let r = e.Data.length; t += 1 + r + bt(r) } if (e.Links) for (let r of e.Links) { let n = Cm(r); t += 1 + n + bt(n) } return t } function Wt(e, t, r) { t -= bt(r); let n = t; for (; r >= xm;)e[t++] = r & 127 | 128, r /= 128; for (; r >= 128;)e[t++] = r & 127 | 128, r >>>= 7; return e[t] = r, n } function bt(e) { return e % 2 === 0 && e++, Math.floor((Tm(e) + 6) / 7) } function Tm(e) { let t = 0; return e >= Xs && (e = Math.floor(e / Xs), t = 32), e >= 1 << 16 && (e >>>= 16, t += 16), e >= 1 << 8 && (e >>>= 8, t += 8), t + Am[e] } var Am = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]; C(); var vm = ["Data", "Links"], Bm = ["Hash", "Name", "Tsize"], zn = new TextEncoder; function ei(e, t) { if (e === t) return 0; let r = e.Name ? zn.encode(e.Name) : [], n = t.Name ? zn.encode(t.Name) : [], o = r.length, s = n.length; for (let i = 0, a = Math.min(o, s); i < a; ++i)if (r[i] !== n[i]) { o = r[i], s = n[i]; break } return o < s ? -1 : s < o ? 1 : 0 } function Ys(e, t) { return !Object.keys(e).some(r => !t.includes(r)) } function ti(e) { if (typeof e.asCID == "object") { let r = m.asCID(e); if (!r) throw new TypeError("Invalid DAG-PB form"); return { Hash: r } } if (typeof e != "object" || Array.isArray(e)) throw new TypeError("Invalid DAG-PB form"); let t = {}; if (e.Hash) { let r = m.asCID(e.Hash); try { r || (typeof e.Hash == "string" ? r = m.parse(e.Hash) : e.Hash instanceof Uint8Array && (r = m.decode(e.Hash))) } catch (n) { throw new TypeError(`Invalid DAG-PB form: ${n.message}`) } r && (t.Hash = r) } if (!t.Hash) throw new TypeError("Invalid DAG-PB form"); return typeof e.Name == "string" && (t.Name = e.Name), typeof e.Tsize == "number" && (t.Tsize = e.Tsize), t } function Mn(e) { if ((e instanceof Uint8Array || typeof e == "string") && (e = { Data: e }), typeof e != "object" || Array.isArray(e)) throw new TypeError("Invalid DAG-PB form"); let t = {}; if (e.Data !== void 0) if (typeof e.Data == "string") t.Data = zn.encode(e.Data); else if (e.Data instanceof Uint8Array) t.Data = e.Data; else throw new TypeError("Invalid DAG-PB form"); if (e.Links !== void 0) if (Array.isArray(e.Links)) t.Links = e.Links.map(ti), t.Links.sort(ei); else throw new TypeError("Invalid DAG-PB form"); else t.Links = []; return t } function qn(e) { if (!e || typeof e != "object" || Array.isArray(e)) throw new TypeError("Invalid DAG-PB form"); if (!Ys(e, vm)) throw new TypeError("Invalid DAG-PB form (extraneous properties)"); if (e.Data !== void 0 && !(e.Data instanceof Uint8Array)) throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)"); if (!Array.isArray(e.Links)) throw new TypeError("Invalid DAG-PB form (Links must be an array)"); for (let t = 0; t < e.Links.length; t++) { let r = e.Links[t]; if (!r || typeof r != "object" || Array.isArray(r)) throw new TypeError("Invalid DAG-PB form (bad link object)"); if (!Ys(r, Bm)) throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)"); if (!r.Hash) throw new TypeError("Invalid DAG-PB form (link must have a Hash)"); if (r.Hash.asCID !== r.Hash) throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)"); if (r.Name !== void 0 && typeof r.Name != "string") throw new TypeError("Invalid DAG-PB form (link Name must be a string)"); if (r.Tsize !== void 0 && (typeof r.Tsize != "number" || r.Tsize % 1 !== 0)) throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)"); if (t > 0 && ei(r, e.Links[t - 1]) === -1) throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)") } } function ri(e, t = []) { return Mn({ Data: e, Links: t }) } function ni(e, t, r) { return ti({ Hash: r, Name: e, Tsize: t }) } var Im = "dag-pb", _m = 112; function km(e) { qn(e); let t = {}; return e.Links && (t.Links = e.Links.map(r => { let n = {}; return r.Hash && (n.Hash = r.Hash.bytes), r.Name !== void 0 && (n.Name = r.Name), r.Tsize !== void 0 && (n.Tsize = r.Tsize), n })), e.Data && (t.Data = e.Data), Zs(t) } function Um(e) { let t = Ks(e), r = {}; return t.Data && (r.Data = t.Data), t.Links && (r.Links = t.Links.map(n => { let o = {}; try { o.Hash = m.decode(n.Hash) } catch { } if (!o.Hash) throw new Error("Invalid Hash field found in link, expected CID"); return n.Name !== void 0 && (o.Name = n.Name), n.Tsize !== void 0 && (o.Tsize = n.Tsize), o })), r } var co = {}; F(co, { code: () => dh, decode: () => hh, encode: () => mh, name: () => ph }); qr(); C(); var fa = 42; function ah(e) { if (e.asCID !== e) return null; let t = m.asCID(e); if (!t) return null; let r = new Uint8Array(t.bytes.byteLength + 1); return r.set(t.bytes, 1), [new h(l.tag, fa), new h(l.bytes, r)] } function ch() { throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded") } function uh(e) { if (Number.isNaN(e)) throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded"); if (e === 1 / 0 || e === -1 / 0) throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded"); return null } var fh = { float64: !0, typeEncoders: { Object: ah, undefined: ch, number: uh } }; function lh(e) { if (e[0] !== 0) throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00"); return m.decode(e.subarray(1)) } var la = { allowIndefinite: !1, coerceUndefinedToNull: !0, allowNaN: !1, allowInfinity: !1, allowBigInt: !0, strict: !0, useMaps: !1, tags: [] }; la.tags[fa] = lh; var ph = "dag-cbor", dh = 113, mh = e => Yt(e, fh), hh = e => it(e, la); var yo = {}; F(yo, { code: () => Th, decode: () => vh, encode: () => Ah, name: () => Ph }); C(); Ar(); Me(); nt(); var fo = ({ name: e, code: t, encode: r }) => new uo(e, t, r), uo = class { constructor(t, r, n) { this.name = t, this.code = r, this.encode = n } digest(t) { if (t instanceof Uint8Array) { let r = this.encode(t); return r instanceof Uint8Array ? qe(this.code, r) : r.then(n => qe(this.code, n)) } else throw Error("Unknown type, must be binary type") } }; nt(); At(); qr(); Y(); so(); ne(); Ve(); var lo = class extends Array { constructor() { super(), this.inRecursive = [] } prefix(t) { let r = this.inRecursive[this.inRecursive.length - 1]; r && (r.type === l.array && (r.elements++, r.elements !== 1 && t.push([44])), r.type === l.map && (r.elements++, r.elements !== 1 && (r.elements % 2 === 1 ? t.push([44]) : t.push([58])))) } [l.uint.major](t, r) { this.prefix(t); let n = String(r.value), o = []; for (let s = 0; s < n.length; s++)o[s] = n.charCodeAt(s); t.push(o) } [l.negint.major](t, r) { this[l.uint.major](t, r) } [l.bytes.major](t, r) { throw new Error(`${Oe} unsupported type: Uint8Array`) } [l.string.major](t, r) { this.prefix(t); let n = kr(JSON.stringify(r.value)); t.push(n.length > 32 ? Jt(n) : n) } [l.array.major](t, r) { this.prefix(t), this.inRecursive.push({ type: l.array, elements: 0 }), t.push([91]) } [l.map.major](t, r) { this.prefix(t), this.inRecursive.push({ type: l.map, elements: 0 }), t.push([123]) } [l.tag.major](t, r) { } [l.float.major](t, r) { if (r.type.name === "break") { let i = this.inRecursive.pop(); if (i) { if (i.type === l.array) t.push([93]); else if (i.type === l.map) t.push([125]); else throw new Error("Unexpected recursive type; this should not happen!"); return } throw new Error("Unexpected break; this should not happen!") } if (r.value === void 0) throw new Error(`${Oe} unsupported type: undefined`); if (this.prefix(t), r.type.name === "true") { t.push([116, 114, 117, 101]); return } else if (r.type.name === "false") { t.push([102, 97, 108, 115, 101]); return } else if (r.type.name === "null") { t.push([110, 117, 108, 108]); return } let n = String(r.value), o = [], s = !1; for (let i = 0; i < n.length; i++)o[i] = n.charCodeAt(i), !s && (o[i] === 46 || o[i] === 101 || o[i] === 69) && (s = !0); s || (o.push(46), o.push(48)), t.push(o) } }; function wh(e, t) { if (Array.isArray(e[0]) || Array.isArray(t[0])) throw new Error(`${Oe} complex map keys are not supported`); let r = e[0], n = t[0]; if (r.type !== l.string || n.type !== l.string) throw new Error(`${Oe} non-string map keys are not supported`); if (r < n) return -1; if (r > n) return 1; throw new Error(`${Oe} unexpected duplicate map keys, this is not supported`) } var bh = { addBreakTokens: !0, mapSorter: wh }; function po(e, t) { return t = Object.assign({}, bh, t), oo(e, new lo, t) } ao(); Y(); Ve(); ne(); var vt = class { constructor(t, r = {}) { this.pos = 0, this.data = t, this.options = r, this.modeStack = ["value"], this.lastToken = "" } done() { return this.pos >= this.data.length } ch() { return this.data[this.pos] } currentMode() { return this.modeStack[this.modeStack.length - 1] } skipWhitespace() { let t = this.ch(); for (; t === 32 || t === 9 || t === 13 || t === 10;)t = this.data[++this.pos] } expect(t) { if (this.data.length - this.pos < t.length) throw new Error(`${w} unexpected end of input at position ${this.pos}`); for (let r = 0; r < t.length; r++)if (this.data[this.pos++] !== t[r]) throw new Error(`${w} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...t)}'`) } parseNumber() { let t = this.pos, r = !1, n = !1, o = a => { for (; !this.done();) { let c = this.ch(); if (a.includes(c)) this.pos++; else break } }; if (this.ch() === 45 && (r = !0, this.pos++), this.ch() === 48) if (this.pos++, this.ch() === 46) this.pos++, n = !0; else return new h(l.uint, 0, this.pos - t); if (o([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]), r && this.pos === t + 1) throw new Error(`${w} unexpected token at position ${this.pos}`); if (!this.done() && this.ch() === 46) { if (n) throw new Error(`${w} unexpected token at position ${this.pos}`); n = !0, this.pos++, o([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) } !this.done() && (this.ch() === 101 || this.ch() === 69) && (n = !0, this.pos++, !this.done() && (this.ch() === 43 || this.ch() === 45) && this.pos++, o([48, 49, 50, 51, 52, 53, 54, 55, 56, 57])); let s = String.fromCharCode.apply(null, this.data.subarray(t, this.pos)), i = parseFloat(s); return n ? new h(l.float, i, this.pos - t) : this.options.allowBigInt !== !0 || Number.isSafeInteger(i) ? new h(i >= 0 ? l.uint : l.negint, i, this.pos - t) : new h(i >= 0 ? l.uint : l.negint, BigInt(s), this.pos - t) } parseString() { if (this.ch() !== 34) throw new Error(`${w} unexpected character at position ${this.pos}; this shouldn't happen`); this.pos++; for (let s = this.pos, i = 0; s < this.data.length && i < 65536; s++, i++) { let a = this.data[s]; if (a === 92 || a < 32 || a >= 128) break; if (a === 34) { let c = String.fromCharCode.apply(null, this.data.subarray(this.pos, s)); return this.pos = s + 1, new h(l.string, c, i) } } let t = this.pos, r = [], n = () => { if (this.pos + 4 >= this.data.length) throw new Error(`${w} unexpected end of unicode escape sequence at position ${this.pos}`); let s = 0; for (let i = 0; i < 4; i++) { let a = this.ch(); if (a >= 48 && a <= 57) a -= 48; else if (a >= 97 && a <= 102) a = a - 97 + 10; else if (a >= 65 && a <= 70) a = a - 65 + 10; else throw new Error(`${w} unexpected unicode escape character at position ${this.pos}`); s = s * 16 + a, this.pos++ } return s }, o = () => { let s = this.ch(), i = null, a = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1; if (this.pos + a > this.data.length) throw new Error(`${w} unexpected unicode sequence at position ${this.pos}`); let c, p, d, g; switch (a) { case 1: s < 128 && (i = s); break; case 2: c = this.data[this.pos + 1], (c & 192) === 128 && (g = (s & 31) << 6 | c & 63, g > 127 && (i = g)); break; case 3: c = this.data[this.pos + 1], p = this.data[this.pos + 2], (c & 192) === 128 && (p & 192) === 128 && (g = (s & 15) << 12 | (c & 63) << 6 | p & 63, g > 2047 && (g < 55296 || g > 57343) && (i = g)); break; case 4: c = this.data[this.pos + 1], p = this.data[this.pos + 2], d = this.data[this.pos + 3], (c & 192) === 128 && (p & 192) === 128 && (d & 192) === 128 && (g = (s & 15) << 18 | (c & 63) << 12 | (p & 63) << 6 | d & 63, g > 65535 && g < 1114112 && (i = g)) }i === null ? (i = 65533, a = 1) : i > 65535 && (i -= 65536, r.push(i >>> 10 & 1023 | 55296), i = 56320 | i & 1023), r.push(i), this.pos += a }; for (; !this.done();) { let s = this.ch(), i; switch (s) { case 92: if (this.pos++, this.done()) throw new Error(`${w} unexpected string termination at position ${this.pos}`); switch (i = this.ch(), this.pos++, i) { case 34: case 39: case 92: case 47: r.push(i); break; case 98: r.push(8); break; case 116: r.push(9); break; case 110: r.push(10); break; case 102: r.push(12); break; case 114: r.push(13); break; case 117: r.push(n()); break; default: throw new Error(`${w} unexpected string escape character at position ${this.pos}`) }break; case 34: return this.pos++, new h(l.string, Vn(r), this.pos - t); default: if (s < 32) throw new Error(`${w} invalid control character at position ${this.pos}`); s < 128 ? (r.push(s), this.pos++) : o() } } throw new Error(`${w} unexpected end of string at position ${this.pos}`) } parseValue() { switch (this.ch()) { case 123: return this.modeStack.push("obj-start"), this.pos++, new h(l.map, 1 / 0, 1); case 91: return this.modeStack.push("array-start"), this.pos++, new h(l.array, 1 / 0, 1); case 34: return this.parseString(); case 110: return this.expect([110, 117, 108, 108]), new h(l.null, null, 4); case 102: return this.expect([102, 97, 108, 115, 101]), new h(l.false, !1, 5); case 116: return this.expect([116, 114, 117, 101]), new h(l.true, !0, 4); case 45: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: return this.parseNumber(); default: throw new Error(`${w} unexpected character at position ${this.pos}`) } } next() { switch (this.skipWhitespace(), this.currentMode()) { case "value": return this.modeStack.pop(), this.parseValue(); case "array-value": { if (this.modeStack.pop(), this.ch() === 93) return this.pos++, this.skipWhitespace(), new h(l.break, void 0, 1); if (this.ch() !== 44) throw new Error(`${w} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`); return this.pos++, this.modeStack.push("array-value"), this.skipWhitespace(), this.parseValue() } case "array-start": return this.modeStack.pop(), this.ch() === 93 ? (this.pos++, this.skipWhitespace(), new h(l.break, void 0, 1)) : (this.modeStack.push("array-value"), this.skipWhitespace(), this.parseValue()); case "obj-key": if (this.ch() === 125) return this.modeStack.pop(), this.pos++, this.skipWhitespace(), new h(l.break, void 0, 1); if (this.ch() !== 44) throw new Error(`${w} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`); this.pos++, this.skipWhitespace(); case "obj-start": { if (this.modeStack.pop(), this.ch() === 125) return this.pos++, this.skipWhitespace(), new h(l.break, void 0, 1); let t = this.parseString(); if (this.skipWhitespace(), this.ch() !== 58) throw new Error(`${w} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`); return this.pos++, this.modeStack.push("obj-value"), t } case "obj-value": return this.modeStack.pop(), this.modeStack.push("obj-key"), this.skipWhitespace(), this.parseValue(); default: throw new Error(`${w} unexpected parse state at position ${this.pos}; this shouldn't happen`) } } }; function mo(e, t) { return t = Object.assign({ tokenizer: new vt(e, t) }, t), it(e, t) } function Eh(e) { if (e.asCID !== e) return null; let t = m.asCID(e); if (!t) return null; let r = t.toString(); return [new h(l.map, 1 / 0, 1), new h(l.string, "/", 1), new h(l.string, r, r.length), new h(l.break, void 0, 1)] } function da(e) { let t = Tt.encode(e).slice(1); return [new h(l.map, 1 / 0, 1), new h(l.string, "/", 1), new h(l.map, 1 / 0, 1), new h(l.string, "bytes", 5), new h(l.string, t, t.length), new h(l.break, void 0, 1), new h(l.break, void 0, 1)] } function xh() { throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded") } function Sh(e) { if (Number.isNaN(e)) throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded"); if (e === 1 / 0 || e === -1 / 0) throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded"); return null } var Ch = { typeEncoders: { Object: Eh, Uint8Array: da, Buffer: da, undefined: xh, number: Sh } }, ho = class extends vt { constructor(t, r) { super(t, r), this.tokenBuffer = [] } done() { return this.tokenBuffer.length === 0 && super.done() } _next() { return this.tokenBuffer.length > 0 ? this.tokenBuffer.pop() : super.next() } next() { let t = this._next(); if (t.type === l.map) { let r = this._next(); if (r.type === l.string && r.value === "/") { let n = this._next(); if (n.type === l.string) { if (this._next().type !== l.break) throw new Error("Invalid encoded CID form"); return this.tokenBuffer.push(n), new h(l.tag, 42, 0) } if (n.type === l.map) { let o = this._next(); if (o.type === l.string && o.value === "bytes") { let s = this._next(); if (s.type === l.string) { for (let a = 0; a < 2; a++)if (this._next().type !== l.break) throw new Error("Invalid encoded Bytes form"); let i = Tt.decode(`m${s.value}`); return new h(l.bytes, i, s.value.length) } this.tokenBuffer.push(s) } this.tokenBuffer.push(o) } this.tokenBuffer.push(n) } this.tokenBuffer.push(r) } return t } }, go = { allowIndefinite: !1, allowUndefined: !1, allowNaN: !1, allowInfinity: !1, allowBigInt: !0, strict: !0, useMaps: !1, tags: [] }; go.tags[42] = m.parse; var Ph = "dag-json", Th = 297, Ah = e => po(e, Ch), vh = e => { let t = Object.assign(go, { tokenizer: new ho(e, go) }); return mo(e, t) }; var db = S(Ta(), 1); var Co = {}; F(Co, { identity: () => ct }); Me(); nt(); var Aa = 0, ng = "identity", va = De, og = e => qe(Aa, va(e)), ct = { code: Aa, name: ng, encode: va, digest: og }; var Po = {}; F(Po, { identity: () => sg }); Ee(); Me(); var sg = wt({ prefix: "\0", name: "identity", encode: e => $s(e), decode: e => Fs(e) }); var To = {}; F(To, { base2: () => ig }); Ee(); var ig = R({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }); var Ao = {}; F(Ao, { base8: () => ag }); Ee(); var ag = R({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 }); var vo = {}; F(vo, { base10: () => cg }); Ee(); var cg = He({ prefix: "9", name: "base10", alphabet: "0123456789" }); var Bo = {}; F(Bo, { base16: () => ug, base16upper: () => fg }); Ee(); var ug = R({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), fg = R({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 }); Vt(); var Io = {}; F(Io, { base36: () => lg, base36upper: () => pg }); Ee(); var lg = He({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), pg = He({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" }); ot(); At(); var _o = {}; F(_o, { base256emoji: () => yg }); Ee(); var Ba = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"), dg = Ba.reduce((e, t, r) => (e[r] = t, e), []), mg = Ba.reduce((e, t, r) => (e[t.codePointAt(0)] = r, e), []); function hg(e) { return e.reduce((t, r) => (t += dg[r], t), "") } function gg(e) { let t = []; for (let r of e) { let n = mg[r.codePointAt(0)]; if (n === void 0) throw new Error(`Non-base256emoji character: ${r}`); t.push(n) } return new Uint8Array(t) } var yg = wt({ prefix: "\u{1F680}", name: "base256emoji", encode: hg, decode: gg }); var ko = {}; F(ko, { sha256: () => Vr, sha512: () => wg }); var Ia = e => async t => new Uint8Array(await crypto.subtle.digest(e, t)), Vr = fo({ name: "sha2-256", code: 18, encode: Ia("SHA-256") }), wg = fo({ name: "sha2-512", code: 19, encode: Ia("SHA-512") }); var Uo = {}; F(Uo, { code: () => Dg, decode: () => xg, encode: () => Eg, name: () => bg }); Me(); var bg = "raw", Dg = 85, Eg = e => De(e), xg = e => De(e); var No = {}; F(No, { code: () => Tg, decode: () => vg, encode: () => Ag, name: () => Pg }); var Sg = new TextEncoder, Cg = new TextDecoder, Pg = "json", Tg = 512, Ag = e => Sg.encode(JSON.stringify(e)), vg = e => JSON.parse(Cg.decode(e)); var Je = { ...Po, ...To, ...Ao, ...vo, ...Bo, ...$n, ...Io, ...Fn, ...Hr, ..._o }, _a = { ...ko, ...Co }, ka = { raw: Uo, json: No }; C(); var Ua = "[a-fA-F\\d:]", Ke = e => e && e.includeBoundaries ? `(?:(?<=\\s|^)(?=${Ua})|(?<=${Ua})(?=\\s|$))` : "", Pe = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", j = "[a-fA-F\\d]{1,4}", Gr = `
(?:
(?:${j}:){7}(?:${j}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${j}:){6}(?:${Pe}|:${j}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${j}:){5}(?::${Pe}|(?::${j}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${j}:){4}(?:(?::${j}){0,1}:${Pe}|(?::${j}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${j}:){3}(?:(?::${j}){0,2}:${Pe}|(?::${j}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${j}:){2}(?:(?::${j}){0,3}:${Pe}|(?::${j}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${j}:){1}(?:(?::${j}){0,4}:${Pe}|(?::${j}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${j}){0,5}:${Pe}|(?::${j}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), Bg = new RegExp(`(?:^${Pe}$)|(?:^${Gr}$)`), Ig = new RegExp(`^${Pe}$`), _g = new RegExp(`^${Gr}$`), Ro = e => e && e.exact ? Bg : new RegExp(`(?:${Ke(e)}${Pe}${Ke(e)})|(?:${Ke(e)}${Gr}${Ke(e)})`, "g"); Ro.v4 = e => e && e.exact ? Ig : new RegExp(`${Ke(e)}${Pe}${Ke(e)}`, "g"); Ro.v6 = e => e && e.exact ? _g : new RegExp(`${Ke(e)}${Gr}${Ke(e)}`, "g"); var Wr = Ro; function Jr(e) { return Wr({ exact: !0 }).test(e) } function Na(e) { return Wr.v6({ exact: !0 }).test(e) } function Ra(e) { return Wr.v4({ exact: !0 }).test(e) } function La(e, t, r, n) { return { name: e, prefix: t, encoder: { name: e, prefix: t, encode: r }, decoder: { decode: n } } } var Oa = La("utf8", "u", e => { let t = new TextDecoder("utf8"); return "u" + t.decode(e) }, e => new TextEncoder().encode(e.substring(1))), Oo = La("ascii", "a", e => { let t = "a"; for (let r = 0; r < e.length; r++)t += String.fromCharCode(e[r]); return t }, e => { e = e.substring(1); let t = new Uint8Array(e.length); for (let r = 0; r < e.length; r++)t[r] = e.charCodeAt(r); return t }), kg = { utf8: Oa, "utf-8": Oa, hex: Je.base16, latin1: Oo, ascii: Oo, binary: Oo, ...Je }, Kr = kg; function O(e, t = "utf8") { let r = Kr[t]; if (!r) throw new Error(`Unsupported encoding "${t}"`); return r.encoder.encode(e).substring(1) } var Fa = Ra, Ug = Na, Lo = function (e) { let t = 0, r; if (Fa(e)) r = new Uint8Array(t + 4), e.split(/\./g).forEach(n => { r[t++] = parseInt(n, 10) & 255 }); else if (Ug(e)) { let n = e.split(":", 8), o; for (o = 0; o < n.length; o++) { let s = Fa(n[o]), i; s && (i = Lo(n[o]), n[o] = O(i.slice(0, 2), "base16")), i != null && ++o < 8 && n.splice(o, 0, O(i.slice(2, 4), "base16")) } if (n[0] === "") for (; n.length < 8;)n.unshift("0"); else if (n[n.length - 1] === "") for (; n.length < 8;)n.push("0"); else if (n.length < 8) { for (o = 0; o < n.length && n[o] !== ""; o++); let s = [o, 1]; for (o = 9 - n.length; o > 0; o--)s.push("0"); n.splice.apply(n, s) } for (r = new Uint8Array(t + 16), o = 0; o < n.length; o++) { let s = parseInt(n[o], 16); r[t++] = s >> 8 & 255, r[t++] = s & 255 } } if (r == null) throw Error("Invalid ip address: " + e); return r }, $a = function (e, t, r) { t = ~~t, r = r ?? e.length - t; let n = [], o = "", s = new DataView(e.buffer); if (r === 4) { for (let i = 0; i < r; i++)n.push(e[t + i]); o = n.join(".") } else if (r === 16) { for (let i = 0; i < r; i += 2)n.push(s.getUint16(t + i).toString(16)); o = n.join(":"), o = o.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3"), o = o.replace(/:{3,4}/, "::") } return o }; var nr = {}, Fo = {}, Rg = [[4, 32, "ip4"], [6, 16, "tcp"], [33, 16, "dccp"], [41, 128, "ip6"], [42, -1, "ip6zone"], [53, -1, "dns", !0], [54, -1, "dns4", !0], [55, -1, "dns6", !0], [56, -1, "dnsaddr", !0], [132, 16, "sctp"], [273, 16, "udp"], [275, 0, "p2p-webrtc-star"], [276, 0, "p2p-webrtc-direct"], [277, 0, "p2p-stardust"], [290, 0, "p2p-circuit"], [301, 0, "udt"], [302, 0, "utp"], [400, -1, "unix", !1, !0], [421, -1, "ipfs"], [421, -1, "p2p"], [443, 0, "https"], [444, 96, "onion"], [445, 296, "onion3"], [446, -1, "garlic64"], [460, 0, "quic"], [477, 0, "ws"], [478, 0, "wss"], [479, 0, "p2p-websocket-star"], [480, 0, "http"], [777, -1, "memory"]]; Rg.forEach(e => { let t = Og(...e); Fo[t.code] = t, nr[t.name] = t }); function Og(e, t, r, n, o) { return { code: e, size: t, name: r, resolvable: Boolean(n), path: Boolean(o) } } function Te(e) { if (typeof e == "number") { if (Fo[e] != null) return Fo[e]; throw new Error(`no protocol with code: ${e}`) } else if (typeof e == "string") { if (nr[e] != null) return nr[e]; throw new Error(`no protocol with name: ${e}`) } throw new Error(`invalid protocol id type: ${typeof e}`) } C(); Vt(); ot(); nt(); var ut = S(Xr(), 1); function ce(e, t = "utf8") { let r = Kr[t]; if (!r) throw new Error(`Unsupported encoding "${t}"`); return r.decoder.decode(`${r.prefix}${e}`) } function Xe(e, t) { t || (t = e.reduce((o, s) => o + s.length, 0)); let r = new Uint8Array(t), n = 0; for (let o of e) r.set(o, n), n += o.length; return r } function Qa(e, t) { switch (Te(e).code) { case 4: case 41: return Xg(t); case 6: case 273: case 33: case 132: return Ya(t).toString(); case 53: case 54: case 55: case 56: case 400: case 777: return Zg(t); case 421: return ey(t); case 444: return Xa(t); case 445: return Xa(t); default: return O(t, "base16") } } function Za(e, t) { switch (Te(e).code) { case 4: return Ka(t); case 41: return Ka(t); case 6: case 273: case 33: case 132: return zo(parseInt(t, 10)); case 53: case 54: case 55: case 56: case 400: case 777: return Qg(t); case 421: return Yg(t); case 444: return ty(t); case 445: return ry(t); default: return ce(t, "base16") } } function Ka(e) { if (!Jr(e)) throw new Error("invalid ip address"); return Lo(e) } function Xg(e) { let t = $a(e, 0, e.length); if (t == null || !Jr(t)) throw new Error("invalid ip address"); return t } function zo(e) { let t = new ArrayBuffer(2); return new DataView(t).setUint16(0, e), new Uint8Array(t) } function Ya(e) { return new DataView(e.buffer).getUint16(e.byteOffset) } function Qg(e) { let t = ce(e), r = Uint8Array.from(ut.default.encode(t.length)); return Xe([r, t], r.length + t.length) } function Zg(e) { let t = ut.default.decode(e); if (e = e.slice(ut.default.decode.bytes), e.length !== t) throw new Error("inconsistent lengths"); return O(e) } function Yg(e) { let t; e[0] === "Q" || e[0] === "1" ? t = tt(V.decode(`z${e}`)).bytes : t = m.parse(e).multihash.bytes; let r = Uint8Array.from(ut.default.encode(t.length)); return Xe([r, t], r.length + t.length) } function ey(e) { let t = ut.default.decode(e), r = e.slice(ut.default.decode.bytes); if (r.length !== t) throw new Error("inconsistent lengths"); return O(r, "base58btc") } function ty(e) { let t = e.split(":"); if (t.length !== 2) throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`); if (t[0].length !== 16) throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`); let r = xe.decode("b" + t[0]), n = parseInt(t[1], 10); if (n < 1 || n > 65536) throw new Error("Port number is not in range(1, 65536)"); let o = zo(n); return Xe([r, o], r.length + o.length) } function ry(e) { let t = e.split(":"); if (t.length !== 2) throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`); if (t[0].length !== 56) throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`); let r = xe.decode(`b${t[0]}`), n = parseInt(t[1], 10); if (n < 1 || n > 65536) throw new Error("Port number is not in range(1, 65536)"); let o = zo(n); return Xe([r, o], r.length + o.length) } function Xa(e) { let t = e.slice(0, e.length - 2), r = e.slice(e.length - 2), n = O(t, "base32"), o = Ya(r); return `${n}:${o}` } var It = S(Xr(), 1); function ny(e) { let t = [], r = e.split("/").slice(1); if (r.length === 1 && r[0] === "") return []; for (let n = 0; n < r.length; n++) { let o = r[n], s = Te(o); if (s.size === 0) { t.push([o]); continue } if (n++, n >= r.length) throw tc("invalid address: " + e); if (s.path === !0) { t.push([o, Vo(r.slice(n).join("/"))]); break } t.push([o, r[n]]) } return t } function oy(e) { let t = []; return e.map(r => { let n = Yr(r); return t.push(n.name), r.length > 1 && r[1] != null && t.push(r[1]), null }), Vo(t.join("/")) } function sy(e) { return e.map(t => { Array.isArray(t) || (t = [t]); let r = Yr(t); return t.length > 1 ? [r.code, Za(r.code, t[1])] : [r.code] }) } function Mo(e) { return e.map(t => { let r = Yr(t); return t[1] != null ? [r.code, Qa(r.code, t[1])] : [r.code] }) } function qo(e) { return Zr(Xe(e.map(t => { let r = Yr(t), n = Uint8Array.from(It.default.encode(r.code)); return t.length > 1 && t[1] != null && (n = Xe([n, t[1]])), n }))) } function Ho(e, t) { return e.size > 0 ? e.size / 8 : e.size === 0 ? 0 : It.default.decode(t) + It.default.decode.bytes } function or(e) { let t = [], r = 0; for (; r < e.length;) { let n = It.default.decode(e, r), o = It.default.decode.bytes, s = Te(n), i = Ho(s, e.slice(r + o)); if (i === 0) { t.push([n]), r += o; continue } let a = e.slice(r + o, r + o + i); if (r += i + o, r > e.length) throw tc("Invalid address Uint8Array: " + O(e, "base16")); t.push([n, a]) } return t } function Qr(e) { let t = or(e), r = Mo(t); return oy(r) } function iy(e) { e = Vo(e); let t = ny(e), r = sy(t); return qo(r) } function ec(e) { return iy(e) } function Zr(e) { let t = ay(e); if (t != null) throw t; return Uint8Array.from(e) } function ay(e) { try { or(e) } catch (t) { return t } } function Vo(e) { return "/" + e.trim().split("/").filter(t => t).join("/") } function tc(e) { return new Error("Error parsing address: " + e) } function Yr(e) { return Te(e[0]) } var Go = S(Xr(), 1); C(); ot(); var sc = S(ee(), 1); function sr(e, t) { if (e === t) return !0; if (e.byteLength !== t.byteLength) return !1; for (let r = 0; r < e.byteLength; r++)if (e[r] !== t[r]) return !1; return !0 } var fy = Symbol.for("nodejs.util.inspect.custom"), ic = new Map, oc = Symbol.for("@multiformats/js-multiaddr/multiaddr"), P = class { constructor(t) { if (t == null && (t = ""), Object.defineProperty(this, oc, { value: !0 }), t instanceof Uint8Array) this.bytes = Zr(t); else if (typeof t == "string") { if (t.length > 0 && t.charAt(0) !== "/") throw new Error(`multiaddr "${t}" must start with a "/"`); this.bytes = ec(t) } else if (P.isMultiaddr(t)) this.bytes = Zr(t.bytes); else throw new Error("addr must be a string, Buffer, or another Multiaddr") } toString() { return Qr(this.bytes) } toJSON() { return this.toString() } toOptions() { let t = this.toString().split("/"); return { family: t[1] === "ip4" ? 4 : 6, host: t[2], transport: t[3], port: parseInt(t[4]) } } protos() { return this.protoCodes().map(t => Object.assign({}, Te(t))) } protoCodes() { let t = [], r = this.bytes, n = 0; for (; n < r.length;) { let o = Go.default.decode(r, n), s = Go.default.decode.bytes, i = Te(o); n += Ho(i, r.slice(n + s)) + s, t.push(o) } return t } protoNames() { return this.protos().map(t => t.name) } tuples() { return or(this.bytes) } stringTuples() { let t = or(this.bytes); return Mo(t) } encapsulate(t) { return t = new P(t), new P(this.toString() + t.toString()) } decapsulate(t) { let r = t.toString(), n = this.toString(), o = n.lastIndexOf(r); if (o < 0) throw new Error(`Address ${this.toString()} does not contain subaddress: ${t.toString()}`); return new P(n.slice(0, o)) } decapsulateCode(t) { let r = this.tuples(); for (let n = r.length - 1; n >= 0; n--)if (r[n][0] === t) return new P(qo(r.slice(0, n))); return this } getPeerId() { try { let r = this.stringTuples().filter(n => n[0] === nr.ipfs.code).pop(); if (r?.[1] != null) { let n = r[1]; return n[0] === "Q" || n[0] === "1" ? O(V.decode(`z${n}`), "base58btc") : O(m.parse(n).multihash.bytes, "base58btc") } return null } catch { return null } } getPath() { let t = null; try { t = this.stringTuples().filter(r => Te(r[0]).path === !0)[0][1], t == null && (t = null) } catch { t = null } return t } equals(t) { return sr(this.bytes, t.bytes) } async resolve() { let t = this.protos().find(o => o.resolvable); if (t == null) return [this]; let r = ic.get(t.name); if (r == null) throw (0, sc.default)(new Error(`no available resolver for ${t.name}`), "ERR_NO_AVAILABLE_RESOLVER"); return (await r(this)).map(o => new P(o)) } nodeAddress() { let t = this.protoCodes(), r = this.protoNames(), n = this.toString().split("/").slice(1); if (n.length < 4) throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".'); if (t[0] !== 4 && t[0] !== 41 && t[0] !== 54 && t[0] !== 55) throw new Error(`no protocol with name: "'${r[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`); if (n[2] !== "tcp" && n[2] !== "udp") throw new Error(`no protocol with name: "'${r[1]}'". Must have a valid transport protocol: "{tcp, udp}".`); return { family: t[0] === 41 || t[0] === 55 ? 6 : 4, address: n[1], port: parseInt(n[3]) } } isThinWaistAddress(t) { let r = (t ?? this).protos(); return !(r.length !== 2 || r[0].code !== 4 && r[0].code !== 41 || r[1].code !== 6 && r[1].code !== 273) } static fromNodeAddress(t, r) { if (t == null) throw new Error("requires node address object"); if (r == null) throw new Error("requires transport protocol"); let n; switch (t.family) { case 4: n = "ip4"; break; case 6: n = "ip6"; break; default: throw Error("Invalid addr family, should be 4 or 6.") }return new P("/" + [n, t.address, r, t.port].join("/")) } static isName(t) { return P.isMultiaddr(t) ? t.protos().some(r => r.resolvable) : !1 } static isMultiaddr(t) { return Boolean(t?.[oc]) } [fy]() { return "<Multiaddr " + O(this.bytes, "base16") + " - " + Qr(this.bytes) + ">" } inspect() { return "<Multiaddr " + O(this.bytes, "base16") + " - " + Qr(this.bytes) + ">" } }; P.resolvers = ic; var Ue = S(fc(), 1); var Dy = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig; T.nanosecond = T.ns = 1 / 1e6; T.\u00B5s = T.\u03BCs = T.us = T.microsecond = 1 / 1e3; T.millisecond = T.ms = T[""] = 1; T.second = T.sec = T.s = T.ms * 1e3; T.minute = T.min = T.m = T.s * 60; T.hour = T.hr = T.h = T.m * 60; T.day = T.d = T.h * 24; T.week = T.wk = T.w = T.d * 7; T.month = T.b = T.d * (365.25 / 12); T.year = T.yr = T.y = T.d * 365.25; function T(e = "", t = "ms") { var r = null; return e = (e + "").replace(/(\d)[,_](\d)/g, "$1$2"), e.replace(Dy, function (n, o, s) { s = lc(s), s && (r = (r || 0) + parseFloat(o, 10) * s) }), r && r / (lc(t) || 1) } function lc(e) { return T[e] || T[e.toLowerCase().replace(/s$/, "")] } var pc = T; var ke = S(yc(), 1); ot(); Vt(); At(); ke.default.formatters.b = e => e == null ? "undefined" : V.baseEncode(e); ke.default.formatters.t = e => e == null ? "undefined" : xe.baseEncode(e); ke.default.formatters.m = e => e == null ? "undefined" : Tt.baseEncode(e); ke.default.formatters.p = e => e == null ? "undefined" : e.toString(); ke.default.formatters.c = e => e == null ? "undefined" : e.toString(); ke.default.formatters.k = e => e == null ? "undefined" : e.toString(); function nn(e) { return Object.assign((0, ke.default)(e), { error: (0, ke.default)(`${e}:error`), trace: (0, ke.default)(`${e}:trace`) }) } var lt = S(cn(), 1); var Gc = S(ts(), 1), Wc = Gc.default; var un = (e, t) => t, pw = (e, t, r, n) => { if (n != null && n.assumeHttp === !1) return `tcp://${e}:${t}`; let o = "tcp", s = `:${t}`; return r[r.length - 1].protocol === "tcp" && (o = t === "443" ? "https" : "http", s = t === "443" || t === "80" ? "" : s), `${o}://${e}${s}` }, dw = { ip4: un, ip6: (e, t, r, n) => n.length === 1 && n[0].protocol === "ip6" ? t : `[${t}]`, tcp: (e, t, r, n, o) => n.some(s => ["http", "https", "ws", "wss"].includes(s.protocol)) ? `${e}:${t}` : pw(e, t, n, o), udp: (e, t) => `udp://${e}:${t}`, dnsaddr: un, dns4: un, dns6: un, ipfs: (e, t) => `${e}/ipfs/${t}`, p2p: (e, t) => `${e}/p2p/${t}`, http: e => `http://${e}`, https: e => `https://${e}`, ws: e => `ws://${e}`, wss: e => `wss://${e}`, "p2p-websocket-star": e => `${e}/p2p-websocket-star`, "p2p-webrtc-star": e => `${e}/p2p-webrtc-star`, "p2p-webrtc-direct": e => `${e}/p2p-webrtc-direct` }; function Jc(e, t) { let r = new P(e), n = e.toString().split("/").slice(1); return r.tuples().map(o => ({ protocol: n.shift() ?? "", content: o[1] != null ? n.shift() ?? "" : "" })).reduce((o, s, i, a) => { let c = dw[s.protocol]; if (c == null) throw new Error(`Unsupported protocol ${s.protocol}`); return c(o, s.content, i, a, t) }, "") } function as(e) { try { e = Jc(new P(e)) } catch { } return e = e.toString(), e } var Kc = () => { }; var Xc = nn("ipfs-http-client:lib:error-handler"), mw = Wc.bind({ ignoreUndefined: !0 }), hw = Ue.isBrowser || Ue.isWebWorker ? location.protocol : "http", gw = Ue.isBrowser || Ue.isWebWorker ? location.hostname : "localhost", yw = Ue.isBrowser || Ue.isWebWorker ? location.port : "5001", ww = (e = {}) => { let t, r = {}, n; if (typeof e == "string" || P.isMultiaddr(e)) t = new URL(as(e)); else if (e instanceof URL) t = e; else if (typeof e.url == "string" || P.isMultiaddr(e.url)) t = new URL(as(e.url)), r = e; else if (e.url instanceof URL) t = e.url, r = e; else { r = e || {}; let o = (r.protocol || hw).replace(":", ""), s = (r.host || gw).split(":")[0], i = r.port || yw; t = new URL(`${o}://${s}:${i}`) } if (r.apiPath ? t.pathname = r.apiPath : (t.pathname === "/" || t.pathname === void 0) && (t.pathname = "api/v0"), Ue.isNode) { let o = Kc(t); n = r.agent || new o({ keepAlive: !0, maxSockets: 6 }) } return { ...r, host: t.host, protocol: t.protocol.replace(":", ""), port: Number(t.port), apiPath: t.pathname, url: t, agent: n } }, bw = async e => { let t; try { if ((e.headers.get("Content-Type") || "").startsWith("application/json")) { let n = await e.json(); Xc(n), t = n.Message || n.message } else t = await e.text() } catch (n) { Xc("Failed to parse error response", n), t = n.message } let r = new lt.default.HTTPError(e); throw t && (t.includes("deadline has elapsed") && (r = new lt.default.TimeoutError), t && t.includes("context deadline exceeded") && (r = new lt.default.TimeoutError)), t && t.includes("request timed out") && (r = new lt.default.TimeoutError), t && (r.message = t), r }, Dw = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, Qc = e => e.replace(Dw, function (t) { return "-" + t.toLowerCase() }), Ew = e => typeof e == "string" ? pc(e) : e, Qe = class extends lt.default { constructor(t = {}) { let r = ww(t); super({ timeout: Ew(r.timeout || 0) || void 0, headers: r.headers, base: `${r.url}`, handleError: bw, transformSearchParams: o => { let s = new URLSearchParams; for (let [i, a] of o) a !== "undefined" && a !== "null" && i !== "signal" && s.append(Qc(i), a), i === "timeout" && !isNaN(a) && s.append(Qc(i), a); return s }, agent: r.agent }), delete this.get, delete this.put, delete this.delete, delete this.options; let n = this.fetch; this.fetch = (o, s = {}) => (typeof o == "string" && !o.startsWith("/") && (o = `${r.url}/${o}`), n.call(this, o, mw(s, { method: "POST" }))) } }, F1 = lt.default.HTTPError; var u = e => t => e(new Qe(t), t); function fn(e) { if (e != null) return typeof e == "string" ? e : e.toString(8).padStart(4, "0") } var Zc = S(ee(), 1); function ln(e) { if (e == null) return; let t; if (e.secs != null && (t = { secs: e.secs, nsecs: e.nsecs }), e.Seconds != null && (t = { secs: e.Seconds, nsecs: e.FractionalNanoseconds }), Array.isArray(e) && (t = { secs: e[0], nsecs: e[1] }), e instanceof Date) { let r = e.getTime(), n = Math.floor(r / 1e3); t = { secs: n, nsecs: (r - n * 1e3) * 1e3 } } if (!!Object.prototype.hasOwnProperty.call(t, "secs")) { if (t != null && t.nsecs != null && (t.nsecs < 0 || t.nsecs > 999999999)) throw (0, Zc.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS"); return t } } function f({ arg: e, searchParams: t, hashAlg: r, mtime: n, mode: o, ...s } = {}) { t && (s = { ...s, ...t }), r && (s.hash = r), n != null && (n = ln(n), s.mtime = n.secs, s.mtimeNsecs = n.nsecs), o != null && (s.mode = fn(o)), s.timeout && !isNaN(s.timeout) && (s.timeout = `${s.timeout}ms`), e == null ? e = [] : Array.isArray(e) || (e = [e]); let i = new URLSearchParams(s); return e.forEach(a => i.append("arg", a)), i } var Yc = u(e => { async function t(r = {}) { return ((await (await e.post("bitswap/wantlist", { signal: r.signal, searchParams: f(r), headers: r.headers })).json()).Keys || []).map(o => m.parse(o["/"])) } return t }); C(); var eu = u(e => { async function t(r, n = {}) { return ((await (await e.post("bitswap/wantlist", { signal: n.signal, searchParams: f({ ...n, peer: r.toString() }), headers: n.headers })).json()).Keys || []).map(s => m.parse(s["/"])) } return t }); C(); C(); ot(); nt(); var xw = S(ee(), 1); var tu = Symbol.for("@libp2p/peer-id"); var ru = Object.values(Je).map(e => e.decoder).reduce((e, t) => e.or(t), Je.identity.decoder), nu = 114, ou = 36, su = 37, ur = class { constructor(t) { this.type = t.type, this.multihash = t.multihash, this.privateKey = t.privateKey, Object.defineProperty(this, "string", { enumerable: !1, writable: !0 }) } get [Symbol.toStringTag]() { return `PeerId(${this.toString()})` } get [tu]() { return !0 } toString() { return this.string == null && (this.string = V.encode(this.multihash.bytes).slice(1)), this.string } toCID() { return m.createV1(nu, this.multihash) } toBytes() { return this.multihash.bytes } toJSON() { return this.toString() } equals(t) { if (t instanceof Uint8Array) return sr(this.multihash.bytes, t); if (typeof t == "string") return z(t).equals(this); if (t?.multihash?.bytes != null) return sr(this.multihash.bytes, t.multihash.bytes); throw new Error("not valid Id") } }, fr = class extends ur { constructor(t) { super({ ...t, type: "RSA" }), this.type = "RSA", this.publicKey = t.publicKey } }, lr = class extends ur { constructor(t) { super({ ...t, type: "Ed25519" }), this.type = "Ed25519", this.publicKey = t.multihash.digest } }, pr = class extends ur { constructor(t) { super({ ...t, type: "secp256k1" }), this.type = "secp256k1", this.publicKey = t.multihash.digest } }; function z(e, t) { if (t = t ?? ru, e.charAt(0) === "1" || e.charAt(0) === "Q") { let r = tt(V.decode(`z${e}`)); return e.startsWith("12D") ? new lr({ multihash: r }) : e.startsWith("16U") ? new pr({ multihash: r }) : new fr({ multihash: r }) } return Sw(ru.decode(e)) } function Sw(e) { try { let t = tt(e); if (t.code === ct.code) { if (t.digest.length === ou) return new lr({ multihash: t }); if (t.digest.length === su) return new pr({ multihash: t }) } if (t.code === Vr.code) return new fr({ multihash: t }) } catch { return Cw(m.decode(e)) } throw new Error("Supplied PeerID CID is invalid") } function Cw(e) { if (e == null || e.multihash == null || e.version == null || e.version === 1 && e.code !== nu) throw new Error("Supplied PeerID CID is invalid"); let t = e.multihash; if (t.code === Vr.code) return new fr({ multihash: e.multihash }); if (t.code === ct.code) { if (t.digest.length === ou) return new lr({ multihash: e.multihash }); if (t.digest.length === su) return new pr({ multihash: e.multihash }) } throw new Error("Supplied PeerID CID is invalid") } var pn = u(e => { async function t(r = {}) { let n = await e.post("bitswap/stat", { searchParams: f(r), signal: r.signal, headers: r.headers }); return Pw(await n.json()) } return t }); function Pw(e) { return { provideBufLen: e.ProvideBufLen, wantlist: (e.Wantlist || []).map(t => m.parse(t["/"])), peers: (e.Peers || []).map(t => z(t)), blocksReceived: BigInt(e.BlocksReceived), dataReceived: BigInt(e.DataReceived), blocksSent: BigInt(e.BlocksSent), dataSent: BigInt(e.DataSent), dupBlksReceived: BigInt(e.DupBlksReceived), dupDataReceived: BigInt(e.DupDataReceived) } } var iu = u(e => { async function t(r, n = {}) { return (await e.post("bitswap/unwant", { signal: n.signal, searchParams: f({ arg: r.toString(), ...n }), headers: n.headers })).json() } return t }); function au(e) { return { wantlist: Yc(e), wantlistForPeer: eu(e), unwant: iu(e), stat: pn(e) } } var dn = u(e => { async function t(r, n = {}) { let o = await e.post("block/get", { signal: n.signal, searchParams: f({ arg: r.toString(), ...n }), headers: n.headers }); return new Uint8Array(await o.arrayBuffer()) } return t }); C(); var pu = S(ee(), 1), du = S(dr(), 1), mu = S(Lt(), 1), hu = S(cs(), 1); function ge(e) { return ArrayBuffer.isView(e) || e instanceof ArrayBuffer } function $e(e) { return e.constructor && (e.constructor.name === "Blob" || e.constructor.name === "File") && typeof e.stream == "function" } function mr(e) { return typeof e == "object" && (e.path || e.content) } var je = e => e && typeof e.getReader == "function"; async function gu(e) { if (ge(e)) return new Blob([e]); if (typeof e == "string" || e instanceof String) return new Blob([e.toString()]); if ($e(e)) return e; if (je(e) && (e = (0, mu.default)(e)), Symbol.iterator in e || Symbol.asyncIterator in e) { let t = (0, du.default)(e), { value: r, done: n } = await t.peek(); if (n) return lu(t); if (t.push(r), Number.isInteger(r)) return new Blob([Uint8Array.from(await (0, hu.default)(t))]); if (ge(r) || typeof r == "string" || r instanceof String) return lu(t) } throw (0, pu.default)(new Error(`Unexpected input: ${e}`), "ERR_UNEXPECTED_INPUT") } async function lu(e) { let t = []; for await (let r of e) t.push(r); return new Blob(t) } var wr = S(ee(), 1), yf = S(Lt(), 1), wf = S(dr(), 1), Ps = S(us(), 1); var gf = S(ee(), 1); var ze = S(hf(), 1), $t = ze.default.Reader, Ss = ze.default.Writer, E = ze.default.util, X = ze.default.roots["ipfs-unixfs"] || (ze.default.roots["ipfs-unixfs"] = {}), $w = X.Data = (() => { function e(t) { if (this.blocksizes = [], t) for (var r = Object.keys(t), n = 0; n < r.length; ++n)t[r[n]] != null && (this[r[n]] = t[r[n]]) } return e.prototype.Type = 0, e.prototype.Data = E.newBuffer([]), e.prototype.filesize = E.Long ? E.Long.fromBits(0, 0, !0) : 0, e.prototype.blocksizes = E.emptyArray, e.prototype.hashType = E.Long ? E.Long.fromBits(0, 0, !0) : 0, e.prototype.fanout = E.Long ? E.Long.fromBits(0, 0, !0) : 0, e.prototype.mode = 0, e.prototype.mtime = null, e.encode = function (r, n) { if (n || (n = Ss.create()), n.uint32(8).int32(r.Type), r.Data != null && Object.hasOwnProperty.call(r, "Data") && n.uint32(18).bytes(r.Data), r.filesize != null && Object.hasOwnProperty.call(r, "filesize") && n.uint32(24).uint64(r.filesize), r.blocksizes != null && r.blocksizes.length) for (var o = 0; o < r.blocksizes.length; ++o)n.uint32(32).uint64(r.blocksizes[o]); return r.hashType != null && Object.hasOwnProperty.call(r, "hashType") && n.uint32(40).uint64(r.hashType), r.fanout != null && Object.hasOwnProperty.call(r, "fanout") && n.uint32(48).uint64(r.fanout), r.mode != null && Object.hasOwnProperty.call(r, "mode") && n.uint32(56).uint32(r.mode), r.mtime != null && Object.hasOwnProperty.call(r, "mtime") && X.UnixTime.encode(r.mtime, n.uint32(66).fork()).ldelim(), n }, e.decode = function (r, n) { r instanceof $t || (r = $t.create(r)); for (var o = n === void 0 ? r.len : r.pos + n, s = new X.Data; r.pos < o;) { var i = r.uint32(); switch (i >>> 3) { case 1: s.Type = r.int32(); break; case 2: s.Data = r.bytes(); break; case 3: s.filesize = r.uint64(); break; case 4: if (s.blocksizes && s.blocksizes.length || (s.blocksizes = []), (i & 7) === 2) for (var a = r.uint32() + r.pos; r.pos < a;)s.blocksizes.push(r.uint64()); else s.blocksizes.push(r.uint64()); break; case 5: s.hashType = r.uint64(); break; case 6: s.fanout = r.uint64(); break; case 7: s.mode = r.uint32(); break; case 8: s.mtime = X.UnixTime.decode(r, r.uint32()); break; default: r.skipType(i & 7); break } } if (!s.hasOwnProperty("Type")) throw E.ProtocolError("missing required 'Type'", { instance: s }); return s }, e.fromObject = function (r) { if (r instanceof X.Data) return r; var n = new X.Data; switch (r.Type) { case "Raw": case 0: n.Type = 0; break; case "Directory": case 1: n.Type = 1; break; case "File": case 2: n.Type = 2; break; case "Metadata": case 3: n.Type = 3; break; case "Symlink": case 4: n.Type = 4; break; case "HAMTShard": case 5: n.Type = 5; break }if (r.Data != null && (typeof r.Data == "string" ? E.base64.decode(r.Data, n.Data = E.newBuffer(E.base64.length(r.Data)), 0) : r.Data.length && (n.Data = r.Data)), r.filesize != null && (E.Long ? (n.filesize = E.Long.fromValue(r.filesize)).unsigned = !0 : typeof r.filesize == "string" ? n.filesize = parseInt(r.filesize, 10) : typeof r.filesize == "number" ? n.filesize = r.filesize : typeof r.filesize == "object" && (n.filesize = new E.LongBits(r.filesize.low >>> 0, r.filesize.high >>> 0).toNumber(!0))), r.blocksizes) { if (!Array.isArray(r.blocksizes)) throw TypeError(".Data.blocksizes: array expected"); n.blocksizes = []; for (var o = 0; o < r.blocksizes.length; ++o)E.Long ? (n.blocksizes[o] = E.Long.fromValue(r.blocksizes[o])).unsigned = !0 : typeof r.blocksizes[o] == "string" ? n.blocksizes[o] = parseInt(r.blocksizes[o], 10) : typeof r.blocksizes[o] == "number" ? n.blocksizes[o] = r.blocksizes[o] : typeof r.blocksizes[o] == "object" && (n.blocksizes[o] = new E.LongBits(r.blocksizes[o].low >>> 0, r.blocksizes[o].high >>> 0).toNumber(!0)) } if (r.hashType != null && (E.Long ? (n.hashType = E.Long.fromValue(r.hashType)).unsigned = !0 : typeof r.hashType == "string" ? n.hashType = parseInt(r.hashType, 10) : typeof r.hashType == "number" ? n.hashType = r.hashType : typeof r.hashType == "object" && (n.hashType = new E.LongBits(r.hashType.low >>> 0, r.hashType.high >>> 0).toNumber(!0))), r.fanout != null && (E.Long ? (n.fanout = E.Long.fromValue(r.fanout)).unsigned = !0 : typeof r.fanout == "string" ? n.fanout = parseInt(r.fanout, 10) : typeof r.fanout == "number" ? n.fanout = r.fanout : typeof r.fanout == "object" && (n.fanout = new E.LongBits(r.fanout.low >>> 0, r.fanout.high >>> 0).toNumber(!0))), r.mode != null && (n.mode = r.mode >>> 0), r.mtime != null) { if (typeof r.mtime != "object") throw TypeError(".Data.mtime: object expected"); n.mtime = X.UnixTime.fromObject(r.mtime) } return n }, e.toObject = function (r, n) { n || (n = {}); var o = {}; if ((n.arrays || n.defaults) && (o.blocksizes = []), n.defaults) { if (o.Type = n.enums === String ? "Raw" : 0, n.bytes === String ? o.Data = "" : (o.Data = [], n.bytes !== Array && (o.Data = E.newBuffer(o.Data))), E.Long) { var s = new E.Long(0, 0, !0); o.filesize = n.longs === String ? s.toString() : n.longs === Number ? s.toNumber() : s } else o.filesize = n.longs === String ? "0" : 0; if (E.Long) { var s = new E.Long(0, 0, !0); o.hashType = n.longs === String ? s.toString() : n.longs === Number ? s.toNumber() : s } else o.hashType = n.longs === String ? "0" : 0; if (E.Long) { var s = new E.Long(0, 0, !0); o.fanout = n.longs === String ? s.toString() : n.longs === Number ? s.toNumber() : s } else o.fanout = n.longs === String ? "0" : 0; o.mode = 0, o.mtime = null } if (r.Type != null && r.hasOwnProperty("Type") && (o.Type = n.enums === String ? X.Data.DataType[r.Type] : r.Type), r.Data != null && r.hasOwnProperty("Data") && (o.Data = n.bytes === String ? E.base64.encode(r.Data, 0, r.Data.length) : n.bytes === Array ? Array.prototype.slice.call(r.Data) : r.Data), r.filesize != null && r.hasOwnProperty("filesize") && (typeof r.filesize == "number" ? o.filesize = n.longs === String ? String(r.filesize) : r.filesize : o.filesize = n.longs === String ? E.Long.prototype.toString.call(r.filesize) : n.longs === Number ? new E.LongBits(r.filesize.low >>> 0, r.filesize.high >>> 0).toNumber(!0) : r.filesize), r.blocksizes && r.blocksizes.length) { o.blocksizes = []; for (var i = 0; i < r.blocksizes.length; ++i)typeof r.blocksizes[i] == "number" ? o.blocksizes[i] = n.longs === String ? String(r.blocksizes[i]) : r.blocksizes[i] : o.blocksizes[i] = n.longs === String ? E.Long.prototype.toString.call(r.blocksizes[i]) : n.longs === Number ? new E.LongBits(r.blocksizes[i].low >>> 0, r.blocksizes[i].high >>> 0).toNumber(!0) : r.blocksizes[i] } return r.hashType != null && r.hasOwnProperty("hashType") && (typeof r.hashType == "number" ? o.hashType = n.longs === String ? String(r.hashType) : r.hashType : o.hashType = n.longs === String ? E.Long.prototype.toString.call(r.hashType) : n.longs === Number ? new E.LongBits(r.hashType.low >>> 0, r.hashType.high >>> 0).toNumber(!0) : r.hashType), r.fanout != null && r.hasOwnProperty("fanout") && (typeof r.fanout == "number" ? o.fanout = n.longs === String ? String(r.fanout) : r.fanout : o.fanout = n.longs === String ? E.Long.prototype.toString.call(r.fanout) : n.longs === Number ? new E.LongBits(r.fanout.low >>> 0, r.fanout.high >>> 0).toNumber(!0) : r.fanout), r.mode != null && r.hasOwnProperty("mode") && (o.mode = r.mode), r.mtime != null && r.hasOwnProperty("mtime") && (o.mtime = X.UnixTime.toObject(r.mtime, n)), o }, e.prototype.toJSON = function () { return this.constructor.toObject(this, ze.default.util.toJSONOptions) }, e.DataType = function () { let t = {}, r = Object.create(t); return r[t[0] = "Raw"] = 0, r[t[1] = "Directory"] = 1, r[t[2] = "File"] = 2, r[t[3] = "Metadata"] = 3, r[t[4] = "Symlink"] = 4, r[t[5] = "HAMTShard"] = 5, r }(), e })(), X2 = X.UnixTime = (() => { function e(t) { if (t) for (var r = Object.keys(t), n = 0; n < r.length; ++n)t[r[n]] != null && (this[r[n]] = t[r[n]]) } return e.prototype.Seconds = E.Long ? E.Long.fromBits(0, 0, !1) : 0, e.prototype.FractionalNanoseconds = 0, e.encode = function (r, n) { return n || (n = Ss.create()), n.uint32(8).int64(r.Seconds), r.FractionalNanoseconds != null && Object.hasOwnProperty.call(r, "FractionalNanoseconds") && n.uint32(21).fixed32(r.FractionalNanoseconds), n }, e.decode = function (r, n) { r instanceof $t || (r = $t.create(r)); for (var o = n === void 0 ? r.len : r.pos + n, s = new X.UnixTime; r.pos < o;) { var i = r.uint32(); switch (i >>> 3) { case 1: s.Seconds = r.int64(); break; case 2: s.FractionalNanoseconds = r.fixed32(); break; default: r.skipType(i & 7); break } } if (!s.hasOwnProperty("Seconds")) throw E.ProtocolError("missing required 'Seconds'", { instance: s }); return s }, e.fromObject = function (r) { if (r instanceof X.UnixTime) return r; var n = new X.UnixTime; return r.Seconds != null && (E.Long ? (n.Seconds = E.Long.fromValue(r.Seconds)).unsigned = !1 : typeof r.Seconds == "string" ? n.Seconds = parseInt(r.Seconds, 10) : typeof r.Seconds == "number" ? n.Seconds = r.Seconds : typeof r.Seconds == "object" && (n.Seconds = new E.LongBits(r.Seconds.low >>> 0, r.Seconds.high >>> 0).toNumber())), r.FractionalNanoseconds != null && (n.FractionalNanoseconds = r.FractionalNanoseconds >>> 0), n }, e.toObject = function (r, n) { n || (n = {}); var o = {}; if (n.defaults) { if (E.Long) { var s = new E.Long(0, 0, !1); o.Seconds = n.longs === String ? s.toString() : n.longs === Number ? s.toNumber() : s } else o.Seconds = n.longs === String ? "0" : 0; o.FractionalNanoseconds = 0 } return r.Seconds != null && r.hasOwnProperty("Seconds") && (typeof r.Seconds == "number" ? o.Seconds = n.longs === String ? String(r.Seconds) : r.Seconds : o.Seconds = n.longs === String ? E.Long.prototype.toString.call(r.Seconds) : n.longs === Number ? new E.LongBits(r.Seconds.low >>> 0, r.Seconds.high >>> 0).toNumber() : r.Seconds), r.FractionalNanoseconds != null && r.hasOwnProperty("FractionalNanoseconds") && (o.FractionalNanoseconds = r.FractionalNanoseconds), o }, e.prototype.toJSON = function () { return this.constructor.toObject(this, ze.default.util.toJSONOptions) }, e })(), Q2 = X.Metadata = (() => { function e(t) { if (t) for (var r = Object.keys(t), n = 0; n < r.length; ++n)t[r[n]] != null && (this[r[n]] = t[r[n]]) } return e.prototype.MimeType = "", e.encode = function (r, n) { return n || (n = Ss.create()), r.MimeType != null && Object.hasOwnProperty.call(r, "MimeType") && n.uint32(10).string(r.MimeType), n }, e.decode = function (r, n) { r instanceof $t || (r = $t.create(r)); for (var o = n === void 0 ? r.len : r.pos + n, s = new X.Metadata; r.pos < o;) { var i = r.uint32(); switch (i >>> 3) { case 1: s.MimeType = r.string(); break; default: r.skipType(i & 7); break } } return s }, e.fromObject = function (r) { if (r instanceof X.Metadata) return r; var n = new X.Metadata; return r.MimeType != null && (n.MimeType = String(r.MimeType)), n }, e.toObject = function (r, n) { n || (n = {}); var o = {}; return n.defaults && (o.MimeType = ""), r.MimeType != null && r.hasOwnProperty("MimeType") && (o.MimeType = r.MimeType), o }, e.prototype.toJSON = function () { return this.constructor.toObject(this, ze.default.util.toJSONOptions) }, e })(); var Z2 = parseInt("0644", 8), Y2 = parseInt("0755", 8); function wn(e) { if (e != null) return typeof e == "number" ? e & 4095 : (e = e.toString(), e.substring(0, 1) === "0" ? parseInt(e, 8) & 4095 : parseInt(e, 10) & 4095) } function bn(e) { if (e == null) return; let t; if (e.secs != null && (t = { secs: e.secs, nsecs: e.nsecs }), e.Seconds != null && (t = { secs: e.Seconds, nsecs: e.FractionalNanoseconds }), Array.isArray(e) && (t = { secs: e[0], nsecs: e[1] }), e instanceof Date) { let r = e.getTime(), n = Math.floor(r / 1e3); t = { secs: n, nsecs: (r - n * 1e3) * 1e3 } } if (!!Object.prototype.hasOwnProperty.call(t, "secs")) { if (t != null && t.nsecs != null && (t.nsecs < 0 || t.nsecs > 999999999)) throw (0, gf.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS"); return t } } async function* bf(e, t) { if (typeof e == "string" || e instanceof String || ge(e) || $e(e) || e._readableState) throw (0, wr.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT"); if (je(e) && (e = (0, yf.default)(e)), Symbol.iterator in e || Symbol.asyncIterator in e) { let r = (0, wf.default)(e), { value: n, done: o } = await r.peek(); if (o) { yield* []; return } if (r.push(n), Number.isInteger(n)) throw (0, wr.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT"); if (n._readableState) { yield* (0, Ps.default)(r, s => Cs({ content: s }, t)); return } if (ge(n)) { yield Cs({ content: r }, t); return } if (mr(n) || n[Symbol.iterator] || n[Symbol.asyncIterator] || je(n) || $e(n)) { yield* (0, Ps.default)(r, s => Cs(s, t)); return } } throw mr(e) ? (0, wr.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT") : (0, wr.default)(new Error("Unexpected input: " + typeof e), "ERR_UNEXPECTED_INPUT") } async function Cs(e, t) { let { path: r, mode: n, mtime: o, content: s } = e, i = { path: r || "", mode: wn(n), mtime: bn(o) }; return s ? i.content = await t(s) : r || (i.content = await t(e)), i } function Df(e) { return bf(e, gu, !0) } function Ef(e) { if (e != null) return typeof e == "string" ? e : e.toString(8).padStart(4, "0") } async function M(e, t, r = {}) { let n = [], o = new FormData, s = 0, i = 0; for await (let { content: a, path: c, mode: p, mtime: d } of Df(e)) { let g = "", x = a ? "file" : "dir"; s > 0 && (g = `-${s}`); let N = x + g, v = []; if (p != null && v.push(`mode=${Ef(p)}`), d != null) { let { secs: _, nsecs: U } = d; v.push(`mtime=${_}`), U != null && v.push(`mtime-nsecs=${U}`) } if (v.length && (N = `${N}?${v.join("&")}`), a) { o.set(N, a, c != null ? encodeURIComponent(c) : void 0); let _ = i + a.size; n.push({ name: c, start: i, end: _ }), i = _ } else if (c != null) o.set(N, new File([""], encodeURIComponent(c), { type: "application/x-directory" })); else throw new Error("path or content or both must be set"); s++ } return { total: i, parts: n, headers: r, body: o } } var xf = S(ss(), 1); function zw(e) { return e.filter(Boolean) } function q(...e) { return (0, xf.anySignal)(zw(e)) } var Sf = u(e => { async function t(r, n = {}) { let o = new AbortController, s = q(o.signal, n.signal), i; try { i = await (await e.post("block/put", { signal: s, searchParams: f(n), ...await M([r], o, n.headers) })).json() } catch (a) { if (n.format === "dag-pb") return t(r, { ...n, format: "protobuf" }); if (n.format === "dag-cbor") return t(r, { ...n, format: "cbor" }); throw a } return m.parse(i.Key) } return t }); C(); var Cf = u(e => { async function* t(r, n = {}) { Array.isArray(r) || (r = [r]); let o = await e.post("block/rm", { signal: n.signal, searchParams: f({ arg: r.map(s => s.toString()), "stream-channels": !0, ...n }), headers: n.headers }); for await (let s of o.ndjson()) yield Mw(s) } return t }); function Mw(e) { let t = { cid: m.parse(e.Hash) }; return e.Error && (t.error = new Error(e.Error)), t } C(); var Pf = u(e => { async function t(r, n = {}) { let s = await (await e.post("block/stat", { signal: n.signal, searchParams: f({ arg: r.toString(), ...n }), headers: n.headers })).json(); return { cid: m.parse(s.Key), size: s.Size } } return t }); function Tf(e) { return { get: dn(e), put: Sf(e), rm: Cf(e), stat: Pf(e) } } var Af = u(e => { async function t(r, n = {}) { let o = await e.post("bootstrap/add", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers }), { Peers: s } = await o.json(); return { Peers: s.map(i => new P(i)) } } return t }); var vf = u(e => { async function t(r = {}) { let n = await e.post("bootstrap/rm", { signal: r.signal, searchParams: f({ ...r, all: !0 }), headers: r.headers }), { Peers: o } = await n.json(); return { Peers: o.map(s => new P(s)) } } return t }); var Bf = u(e => { async function t(r = {}) { let n = await e.post("bootstrap/list", { signal: r.signal, searchParams: f(r), headers: r.headers }), { Peers: o } = await n.json(); return { Peers: o.map(s => new P(s)) } } return t }); var If = u(e => { async function t(r = {}) { let n = await e.post("bootstrap/add", { signal: r.signal, searchParams: f({ ...r, default: !0 }), headers: r.headers }), { Peers: o } = await n.json(); return { Peers: o.map(s => new P(s)) } } return t }); var _f = u(e => { async function t(r, n = {}) { let o = await e.post("bootstrap/rm", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers }), { Peers: s } = await o.json(); return { Peers: s.map(i => new P(i)) } } return t }); function kf(e) { return { add: Af(e), clear: vf(e), list: Bf(e), reset: If(e), rm: _f(e) } } var Uf = u(e => { async function t(r, n = {}) { let s = await (await e.post("config/profile/apply", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers })).json(); return { original: s.OldCfg, updated: s.NewCfg } } return t }); function A(e) { if (e == null) return e; let t = /^[A-Z]+$/, r = {}; return Object.keys(e).reduce((n, o) => (t.test(o) ? n[o.toLowerCase()] = e[o] : t.test(o[0]) ? n[o[0].toLowerCase() + o.slice(1)] = e[o] : n[o] = e[o], n), r) } var Nf = u(e => { async function t(r = {}) { return (await (await e.post("config/profile/list", { signal: r.signal, searchParams: f(r), headers: r.headers })).json()).map(s => A(s)) } return t }); function Rf(e) { return { apply: Uf(e), list: Nf(e) } } var Of = u(e => async (r, n = {}) => { if (!r) throw new Error("key argument is required"); return (await (await e.post("config", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers })).json()).Value }); var Lf = u(e => async (r = {}) => await (await e.post("config/show", { signal: r.signal, searchParams: f({ ...r }), headers: r.headers })).json()); var Ff = u(e => async (r, n = {}) => { let o = new AbortController, s = q(o.signal, n.signal); await (await e.post("config/replace", { signal: s, searchParams: f(n), ...await M([ce(JSON.stringify(r))], o, n.headers) })).text() }); var $f = u(e => async (r, n, o = {}) => { if (typeof r != "string") throw new Error("Invalid key type"); let s = { ...o, ...qw(r, n) }; await (await e.post("config", { signal: o.signal, searchParams: f(s), headers: o.headers })).text() }), qw = (e, t) => { switch (typeof t) { case "boolean": return { arg: [e, t.toString()], bool: !0 }; case "string": return { arg: [e, t] }; default: return { arg: [e, JSON.stringify(t)], json: !0 } } }; function jf(e) { return { getAll: Lf(e), get: Of(e), set: $f(e), replace: Ff(e), profiles: Rf(e) } } var zf = u(e => { async function* t(r, n = {}) { yield* (await e.post("dag/export", { signal: n.signal, searchParams: f({ arg: r.toString() }), headers: n.headers })).iterator() } return t }); C(); var Ts = S(ee(), 1); async function* As(e, t, r, n, o) { let s = async p => { let d = await r.getCodec(p.code), g = await n(p, o); return d.decode(g) }, i = t.split("/").filter(Boolean), a = await s(e), c = e; for (; i.length;) { let p = i.shift(); if (!p) throw (0, Ts.default)(new Error(`Could not resolve path "${t}"`), "ERR_INVALID_PATH"); if (Object.prototype.hasOwnProperty.call(a, p)) a = a[p], yield { value: a, remainderPath: i.join("/") }; else throw (0, Ts.default)(new Error(`no link named "${p}" under ${c}`), "ERR_NO_LINK"); let d = m.asCID(a); d && (c = d, a = await s(a)) } yield { value: a, remainderPath: "" } } var Vf = S(qf(), 1), Gf = S(br(), 1), Wf = S(ee(), 1); var Jf = (e, t) => u((n, o) => { let s = dn(o); return async (a, c = {}) => { if (c.path) { let N = c.localResolve ? await (0, Vf.default)(As(a, c.path, e, s, c)) : await (0, Gf.default)(As(a, c.path, e, s, c)); if (!N) throw (0, Wf.default)(new Error("Not found"), "ERR_NOT_FOUND"); return N } let p = await e.getCodec(a.code), d = await s(a, c); return { value: p.decode(d), remainderPath: "" } } })(t); C(); var Kf = u(e => { async function* t(r, n = {}) { let o = new AbortController, s = q(o.signal, n.signal), { headers: i, body: a } = await M(r, o, n.headers), c = await e.post("dag/import", { signal: s, headers: i, body: a, searchParams: f({ "pin-roots": n.pinRoots }) }); for await (let { Root: p } of c.ndjson()) if (p !== void 0) { let { Cid: { "/": d }, PinErrorMsg: g } = p; yield { root: { cid: m.parse(d), pinErrorMsg: g } } } } return t }); C(); var Dn = (e, t) => u(n => async (s, i = {}) => { let a = { storeCodec: "dag-cbor", hashAlg: "sha2-256", ...i }, c; if (a.inputCodec) { if (!(s instanceof Uint8Array)) throw new Error("Can only inputCodec on raw bytes that can be decoded"); c = s } else c = (await e.getCodec(a.storeCodec)).encode(s), a.inputCodec = a.storeCodec; let p = new AbortController, d = q(p.signal, a.signal), x = await (await n.post("dag/put", { timeout: a.timeout, signal: d, searchParams: f(a), ...await M([c], p, a.headers) })).json(); return m.parse(x.Cid["/"]) })(t); C(); var Xf = u(e => async (r, n = {}) => { let s = await (await e.post("dag/resolve", { signal: n.signal, searchParams: f({ arg: `${r}${n.path ? `/${n.path}`.replace(/\/[/]+/g, "/") : ""}`, ...n }), headers: n.headers })).json(); return { cid: m.parse(s.Cid["/"]), remainderPath: s.RemPath } }); function Qf(e, t) { return { export: zf(t), get: Jf(e, t), import: Kf(t), put: Dn(e, t), resolve: Xf(t) } } var we = e => { if (e.Type === 0) return { name: "SENDING_QUERY", type: e.Type }; if (e.Type === 1) return { from: z(e.ID), name: "PEER_RESPONSE", type: e.Type, messageType: 0, messageName: "PUT_VALUE", closer: (e.Responses || []).map(({ ID: t, Addrs: r }) => ({ id: z(t), multiaddrs: r.map(n => new P(n)), protocols: [] })), providers: (e.Responses || []).map(({ ID: t, Addrs: r }) => ({ id: z(t), multiaddrs: r.map(n => new P(n)), protocols: [] })) }; if (e.Type === 2) { let t = { id: e.ID ?? z(e.ID), multiaddrs: [], protocols: [] }; return e.Responses && e.Responses.length && (t = { id: z(e.Responses[0].ID), multiaddrs: e.Responses[0].Addrs.map(r => new P(r)), protocols: [] }), { name: "FINAL_PEER", type: e.Type, peer: t } } if (e.Type === 3) return { name: "QUERY_ERROR", type: e.Type, error: new Error(e.Extra) }; if (e.Type === 4) return { name: "PROVIDER", type: e.Type, providers: e.Responses.map(({ ID: t, Addrs: r }) => ({ id: z(t), multiaddrs: r.map(n => new P(n)), protocols: [] })) }; if (e.Type === 5) return { name: "VALUE", type: e.Type, value: ce(e.Extra, "base64pad") }; if (e.Type === 6) { let t = e.Responses.map(({ ID: r }) => z(r)); if (!t.length) throw new Error("No peer found"); return { name: "ADDING_PEER", type: e.Type, peer: t[0] } } if (e.Type === 7) return { name: "DIALING_PEER", type: e.Type, peer: z(e.ID) }; throw new Error("Unknown DHT event type") }; var Zf = u(e => { async function* t(r, n = {}) { let o = await e.post("dht/findpeer", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers }); for await (let s of o.ndjson()) yield we(s) } return t }); var Yf = u(e => { async function* t(r, n = {}) { let o = await e.post("dht/findprovs", { signal: n.signal, searchParams: f({ arg: r.toString(), ...n }), headers: n.headers }); for await (let s of o.ndjson()) yield we(s) } return t }); var el = u(e => { async function* t(r, n = {}) { let o = await e.post("dht/get", { signal: n.signal, searchParams: f({ arg: r instanceof Uint8Array ? O(r) : r.toString(), ...n }), headers: n.headers }); for await (let s of o.ndjson()) yield we(s) } return t }); var tl = u(e => { async function* t(r, n = { recursive: !1 }) { let o = Array.isArray(r) ? r : [r], s = await e.post("dht/provide", { signal: n.signal, searchParams: f({ arg: o.map(i => i.toString()), ...n }), headers: n.headers }); for await (let i of s.ndjson()) yield we(i) } return t }); var rl = u(e => { async function* t(r, n, o = {}) { let s = new AbortController, i = q(s.signal, o.signal), a = await e.post("dht/put", { signal: i, searchParams: f({ arg: r instanceof Uint8Array ? O(r) : r.toString(), ...o }), ...await M([n], s, o.headers) }); for await (let c of a.ndjson()) yield we(c) } return t }); var nl = u(e => { async function* t(r, n = {}) { let o = await e.post("dht/query", { signal: n.signal, searchParams: f({ arg: r.toString(), ...n }), headers: n.headers }); for await (let s of o.ndjson()) yield we(s) } return t }); function ol(e) { return { findPeer: Zf(e), findProvs: Yf(e), get: el(e), provide: tl(e), put: rl(e), query: nl(e) } } var sl = u(e => { async function t(r = {}) { return (await e.post("diag/cmds", { signal: r.signal, searchParams: f(r), headers: r.headers })).json() } return t }); var il = u(e => { async function t(r = {}) { return (await e.post("diag/net", { signal: r.signal, searchParams: f(r), headers: r.headers })).json() } return t }); var al = u(e => { async function t(r = {}) { return (await e.post("diag/sys", { signal: r.signal, searchParams: f(r), headers: r.headers })).json() } return t }); function cl(e) { return { cmds: sl(e), net: il(e), sys: al(e) } } var ul = u(e => { async function t(r, n, o = {}) { await (await e.post("files/chmod", { signal: o.signal, searchParams: f({ arg: r, mode: n, ...o }), headers: o.headers })).text() } return t }); C(); var fl = u(e => { async function t(r, n, o = {}) { let s = Array.isArray(r) ? r : [r]; await (await e.post("files/cp", { signal: o.signal, searchParams: f({ arg: s.concat(n).map(a => m.asCID(a) ? `/ipfs/${a}` : a), ...o }), headers: o.headers })).text() } return t }); C(); var ll = u(e => { async function t(r, n = {}) { if (!r || typeof r != "string") throw new Error("ipfs.files.flush requires a path"); let s = await (await e.post("files/flush", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers })).json(); return m.parse(s.Cid) } return t }); C(); function Dr(e) { let t = A(e); return Object.prototype.hasOwnProperty.call(t, "mode") && (t.mode = parseInt(t.mode, 8)), Object.prototype.hasOwnProperty.call(t, "mtime") && (t.mtime = { secs: t.mtime, nsecs: t.mtimeNsecs || 0 }, delete t.mtimeNsecs), t } var dl = u(e => { async function* t(r, n = {}) { if (!r) throw new Error("ipfs.files.ls requires a path"); let o = await e.post("files/ls", { signal: n.signal, searchParams: f({ arg: m.asCID(r) ? `/ipfs/${r}` : r, long: !0, ...n, stream: !0 }), headers: n.headers }); for await (let s of o.ndjson()) if ("Entries" in s) for (let i of s.Entries || []) yield pl(Dr(i)); else yield pl(Dr(s)) } return t }); function pl(e) { return e.hash && (e.cid = m.parse(e.hash)), delete e.hash, e.type = e.type === 1 ? "directory" : "file", e } var ml = u(e => { async function t(r, n = {}) { await (await e.post("files/mkdir", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers })).text() } return t }); var hl = u(e => { async function t(r, n, o = {}) { Array.isArray(r) || (r = [r]), await (await e.post("files/mv", { signal: o.signal, searchParams: f({ arg: r.concat(n), ...o }), headers: o.headers })).text() } return t }); var wl = S(yl(), 1), bl = u(e => { async function* t(r, n = {}) { let o = await e.post("files/read", { signal: n.signal, searchParams: f({ arg: r, count: n.length, ...n }), headers: n.headers }); yield* (0, wl.default)(o.body) } return t }); var Dl = S(cn(), 1), El = u(e => { async function t(r, n = {}) { let o = await e.post("files/rm", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers }), s = await o.text(); if (s !== "") { let i = new Dl.default.HTTPError(o); throw i.message = s, i } } return t }); C(); var En = u(e => { async function t(r, n = {}) { let s = await (await e.post("files/stat", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers })).json(); return s.WithLocality = s.WithLocality || !1, eb(Dr(s)) } return t }); function eb(e) { return e.cid = m.parse(e.hash), delete e.hash, e } var xl = u(e => { async function t(r, n = {}) { await (await e.post("files/touch", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers })).text() } return t }); var Sl = u(e => { async function t(r, n, o = {}) { let s = new AbortController, i = q(s.signal, o.signal); await (await e.post("files/write", { signal: i, searchParams: f({ arg: r, streamChannels: !0, count: o.length, ...o }), ...await M([{ content: n, path: "arg", mode: fn(o.mode), mtime: ln(o.mtime) }], s, o.headers) })).text() } return t }); function Cl(e) { return { chmod: ul(e), cp: fl(e), flush: ll(e), ls: dl(e), mkdir: ml(e), mv: hl(e), read: bl(e), rm: El(e), stat: En(e), touch: xl(e), write: Sl(e) } } var Pl = S(ee(), 1), Tl = u(e => async (r, n, o = {}) => { throw (0, Pl.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED") }); var Al = u(e => { async function t(r, n = { type: "Ed25519" }) { let s = await (await e.post("key/gen", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers })).json(); return A(s) } return t }); var vl = u(e => { async function t(r, n, o, s = {}) { let a = await (await e.post("key/import", { signal: s.signal, searchParams: f({ arg: r, pem: n, password: o, ...s }), headers: s.headers })).json(); return A(a) } return t }); var Bl = S(ee(), 1), Il = u(e => async (r, n = {}) => { throw (0, Bl.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED") }); var _l = u(e => { async function t(r = {}) { return ((await (await e.post("key/list", { signal: r.signal, searchParams: f(r), headers: r.headers })).json()).Keys || []).map(s => A(s)) } return t }); var kl = u(e => { async function t(r, n, o = {}) { let s = await e.post("key/rename", { signal: o.signal, searchParams: f({ arg: [r, n], ...o }), headers: o.headers }); return A(await s.json()) } return t }); var Ul = u(e => { async function t(r, n = {}) { let s = await (await e.post("key/rm", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers })).json(); return A(s.Keys[0]) } return t }); function Nl(e) { return { export: Tl(e), gen: Al(e), import: vl(e), info: Il(e), list: _l(e), rename: kl(e), rm: Ul(e) } } var Rl = u(e => { async function t(r, n, o = {}) { let s = await e.post("log/level", { signal: o.signal, searchParams: f({ arg: [r, n], ...o }), headers: o.headers }); return A(await s.json()) } return t }); var Ol = u(e => { async function t(r = {}) { return (await (await e.post("log/ls", { signal: r.signal, searchParams: f(r), headers: r.headers })).json()).Strings } return t }); var Ll = u(e => { async function* t(r = {}) { yield* (await e.post("log/tail", { signal: r.signal, searchParams: f(r), headers: r.headers })).ndjson() } return t }); function Fl(e) { return { level: Rl(e), ls: Ol(e), tail: Ll(e) } } var $l = u(e => { async function t(r, n = {}) { let o = await e.post("name/publish", { signal: n.signal, searchParams: f({ arg: `${r}`, ...n }), headers: n.headers }); return A(await o.json()) } return t }); var jl = u(e => { async function* t(r, n = {}) { let o = await e.post("name/resolve", { signal: n.signal, searchParams: f({ arg: r, stream: !0, ...n }), headers: n.headers }); for await (let s of o.ndjson()) yield s.Path } return t }); var zl = u(e => { async function t(r, n = {}) { let o = await e.post("name/pubsub/cancel", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers }); return A(await o.json()) } return t }); var Ml = u(e => { async function t(r = {}) { let n = await e.post("name/pubsub/state", { signal: r.signal, searchParams: f(r), headers: r.headers }); return A(await n.json()) } return t }); var ql = u(e => { async function t(r = {}) { return (await (await e.post("name/pubsub/subs", { signal: r.signal, searchParams: f(r), headers: r.headers })).json()).Strings || [] } return t }); function Hl(e) { return { cancel: zl(e), state: Ml(e), subs: ql(e) } } function Vl(e) { return { publish: $l(e), resolve: jl(e), pubsub: Hl(e) } } C(); var Gl = u(e => { async function t(r, n = {}) { let s = await (await e.post("object/data", { signal: n.signal, searchParams: f({ arg: `${r instanceof Uint8Array ? m.decode(r) : r}`, ...n }), headers: n.headers })).arrayBuffer(); return new Uint8Array(s, 0, s.byteLength) } return t }); C(); var Wl = u(e => { async function t(r, n = {}) { let s = await (await e.post("object/get", { signal: n.signal, searchParams: f({ arg: `${r instanceof Uint8Array ? m.decode(r) : r}`, dataEncoding: "base64", ...n }), headers: n.headers })).json(); return { Data: ce(s.Data, "base64pad"), Links: (s.Links || []).map(i => ({ Name: i.Name, Hash: m.parse(i.Hash), Tsize: i.Size })) } } return t }); C(); var Jl = u(e => { async function t(r, n = {}) { return ((await (await e.post("object/links", { signal: n.signal, searchParams: f({ arg: `${r instanceof Uint8Array ? m.decode(r) : r}`, ...n }), headers: n.headers })).json()).Links || []).map(i => ({ Name: i.Name, Tsize: i.Size, Hash: m.parse(i.Hash) })) } return t }); C(); var Kl = u(e => { async function t(r = {}) { let n = await e.post("object/new", { signal: r.signal, searchParams: f({ arg: r.template, ...r }), headers: r.headers }), { Hash: o } = await n.json(); return m.parse(o) } return t }); var Xl = (e, t) => u(n => { let o = Dn(e, t); async function s(i, a = {}) { return o(i, { ...a, storeCodec: "dag-pb", hashAlg: "sha2-256", version: 1 }) } return s })(t); C(); var Ql = u(e => { async function t(r, n = {}) { let s = await (await e.post("object/stat", { signal: n.signal, searchParams: f({ arg: `${r}`, ...n }), headers: n.headers })).json(); return { ...s, Hash: m.parse(s.Hash) } } return t }); C(); var Zl = u(e => { async function t(r, n, o = {}) { let s = await e.post("object/patch/add-link", { signal: o.signal, searchParams: f({ arg: [`${r}`, n.Name || n.name || "", (n.Hash || n.cid || "").toString() || null], ...o }), headers: o.headers }), { Hash: i } = await s.json(); return m.parse(i) } return t }); C(); var Yl = u(e => { async function t(r, n, o = {}) { let s = new AbortController, i = q(s.signal, o.signal), a = await e.post("object/patch/append-data", { signal: i, searchParams: f({ arg: `${r}`, ...o }), ...await M([n], s, o.headers) }), { Hash: c } = await a.json(); return m.parse(c) } return t }); C(); var ep = u(e => { async function t(r, n, o = {}) { let s = await e.post("object/patch/rm-link", { signal: o.signal, searchParams: f({ arg: [`${r}`, n.Name || n.name || null], ...o }), headers: o.headers }), { Hash: i } = await s.json(); return m.parse(i) } return t }); C(); var tp = u(e => { async function t(r, n, o = {}) { let s = new AbortController, i = q(s.signal, o.signal), a = await e.post("object/patch/set-data", { signal: i, searchParams: f({ arg: [`${r}`], ...o }), ...await M([n], s, o.headers) }), { Hash: c } = await a.json(); return m.parse(c) } return t }); function rp(e) { return { addLink: Zl(e), appendData: Yl(e), rmLink: ep(e), setData: tp(e) } } function np(e, t) { return { data: Gl(t), get: Wl(t), links: Jl(t), new: Kl(t), put: Xl(e, t), stat: Ql(t), patch: rp(t) } } C(); var jt = S(ee(), 1); C(); async function* xn(e) { if (e == null) throw (0, jt.default)(new Error(`Unexpected input: ${e}`), "ERR_UNEXPECTED_INPUT"); let t = m.asCID(e); if (t) { yield Be({ cid: t }); return } if (e instanceof String || typeof e == "string") { yield Be({ path: e }); return } if (e.cid != null || e.path != null) return yield Be(e); if (Symbol.iterator in e) { let r = e[Symbol.iterator](), n = r.next(); if (n.done) return r; if (m.asCID(n.value) || n.value instanceof String || typeof n.value == "string") { yield Be({ cid: n.value }); for (let o of r) yield Be({ cid: o }); return } if (n.value.cid != null || n.value.path != null) { yield Be(n.value); for (let o of r) yield Be(o); return } throw (0, jt.default)(new Error("Unexpected input: " + typeof e), "ERR_UNEXPECTED_INPUT") } if (Symbol.asyncIterator in e) { let r = e[Symbol.asyncIterator](), n = await r.next(); if (n.done) return r; if (m.asCID(n.value) || n.value instanceof String || typeof n.value == "string") { yield Be({ cid: n.value }); for await (let o of r) yield Be({ cid: o }); return } if (n.value.cid != null || n.value.path != null) { yield Be(n.value); for await (let o of r) yield Be(o); return } throw (0, jt.default)(new Error("Unexpected input: " + typeof e), "ERR_UNEXPECTED_INPUT") } throw (0, jt.default)(new Error("Unexpected input: " + typeof e), "ERR_UNEXPECTED_INPUT") } function Be(e) { let t = e.cid || `${e.path}`; if (!t) throw (0, jt.default)(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT"); let r = { path: t, recursive: e.recursive !== !1 }; return e.metadata != null && (r.metadata = e.metadata), r } var Sn = u(e => { async function* t(r, n = {}) { for await (let { path: o, recursive: s, metadata: i } of xn(r)) { let a = await e.post("pin/add", { signal: n.signal, searchParams: f({ ...n, arg: o, recursive: s, metadata: i ? JSON.stringify(i) : void 0, stream: !0 }), headers: n.headers }); for await (let c of a.ndjson()) { if (c.Pins) { for (let p of c.Pins) yield m.parse(p); continue } yield m.parse(c) } } } return t }); var op = S(br(), 1); function sp(e) { let t = Sn(e); return u(() => { async function r(n, o = {}) { return (0, op.default)(t([{ path: n, ...o }], o)) } return r })(e) } C(); function ip(e, t, r) { let n = { type: e, cid: m.parse(t) }; return r && (n.metadata = r), n } var ap = u(e => { async function* t(r = {}) { let n = []; r.paths && (n = Array.isArray(r.paths) ? r.paths : [r.paths]); let o = await e.post("pin/ls", { signal: r.signal, searchParams: f({ ...r, arg: n.map(s => `${s}`), stream: !0 }), headers: r.headers }); for await (let s of o.ndjson()) { if (s.Keys) { for (let i of Object.keys(s.Keys)) yield ip(s.Keys[i].Type, i, s.Keys[i].Metadata); return } yield ip(s.Type, s.Cid, s.Metadata) } } return t }); C(); var Cn = u(e => { async function* t(r, n = {}) { for await (let { path: o, recursive: s } of xn(r)) { let i = new URLSearchParams(n.searchParams); i.append("arg", `${o}`), s != null && i.set("recursive", String(s)); let a = await e.post("pin/rm", { signal: n.signal, headers: n.headers, searchParams: f({ ...n, arg: `${o}`, recursive: s }) }); for await (let c of a.ndjson()) { if (c.Pins) { yield* c.Pins.map(p => m.parse(p)); continue } yield m.parse(c) } } } return t }); var cp = S(br(), 1); var up = e => { let t = Cn(e); return u(() => { async function r(n, o = {}) { return (0, cp.default)(t([{ path: n, ...o }], o)) } return r })(e) }; C(); var Pn = ({ Name: e, Status: t, Cid: r }) => ({ cid: m.parse(r), name: e, status: t }), fp = e => { if (typeof e == "string" && e !== "") return e; throw new TypeError("service name must be passed") }, lp = e => { if (m.asCID(e)) return e.toString(); throw new TypeError(`CID instance expected instead of ${typeof e}`) }, zt = ({ service: e, cid: t, name: r, status: n, all: o }) => { let s = f({ service: fp(e), name: r, force: o ? !0 : void 0 }); if (t) for (let i of t) s.append("cid", lp(i)); if (n) for (let i of n) s.append("status", i); return s }, pp = ({ cid: e, service: t, background: r, name: n, origins: o }) => { let s = f({ arg: lp(e), service: fp(t), name: n, background: r ? !0 : void 0 }); if (o) for (let i of o) s.append("origin", i.toString()); return s }; function dp(e) { async function t(r, { timeout: n, signal: o, headers: s, ...i }) { let a = await e.post("pin/remote/add", { timeout: n, signal: o, headers: s, searchParams: pp({ cid: r, ...i }) }); return Pn(await a.json()) } return t } function mp(e) { async function* t({ timeout: r, signal: n, headers: o, ...s }) { let i = await e.post("pin/remote/ls", { timeout: r, signal: n, headers: o, searchParams: zt(s) }); for await (let a of i.ndjson()) yield Pn(a) } return t } function hp(e) { async function t({ timeout: r, signal: n, headers: o, ...s }) { await e.post("pin/remote/rm", { timeout: r, signal: n, headers: o, searchParams: zt({ ...s, all: !1 }) }) } return t } function gp(e) { async function t({ timeout: r, signal: n, headers: o, ...s }) { await e.post("pin/remote/rm", { timeout: r, signal: n, headers: o, searchParams: zt({ ...s, all: !0 }) }) } return t } function yp(e) { let t = String(e); if (t === "undefined") throw Error("endpoint is required"); return t[t.length - 1] === "/" ? t.slice(0, -1) : t } function wp(e) { return { service: e.Service, endpoint: new URL(e.ApiEndpoint), ...e.Stat && { stat: tb(e.Stat) } } } function tb(e) { switch (e.Status) { case "valid": { let { Pinning: t, Pinned: r, Queued: n, Failed: o } = e.PinCount; return { status: "valid", pinCount: { queued: n, pinning: t, pinned: r, failed: o } } } case "invalid": return { status: "invalid" }; default: return { status: e.Status } } } function bp(e) { async function t(r, n) { let { endpoint: o, key: s, headers: i, timeout: a, signal: c } = n; await e.post("pin/remote/service/add", { timeout: a, signal: c, searchParams: f({ arg: [r, yp(o), s] }), headers: i }) } return t } function Dp(e) { async function t(r = {}) { let { stat: n, headers: o, timeout: s, signal: i } = r, a = await e.post("pin/remote/service/ls", { timeout: s, signal: i, headers: o, searchParams: n === !0 ? f({ stat: n }) : void 0 }), { RemoteServices: c } = await a.json(); return c.map(wp) } return t } function Ep(e) { async function t(r, n = {}) { await e.post("pin/remote/service/rm", { signal: n.signal, headers: n.headers, searchParams: f({ arg: r }) }) } return t } function xp(e) { let t = new Qe(e); return { add: bp(t), ls: Dp(t), rm: Ep(t) } } function Sp(e) { let t = new Qe(e); return { add: dp(t), ls: mp(t), rm: hp(t), rmAll: gp(t), service: xp(e) } } function Cp(e) { return { addAll: Sn(e), add: sp(e), ls: ap(e), rmAll: Cn(e), rm: up(e), remote: Sp(e) } } At(); var Pp = e => Array.isArray(e) ? e.map(vs) : e, vs = e => O(Bs(e)), Bs = e => rr.decode(e), Tp = e => BigInt(`0x${O(rr.decode(e), "base16")}`), Mt = e => rr.encode(ce(e)); var Ap = u(e => { async function t(r = {}) { let { Strings: n } = await (await e.post("pubsub/ls", { signal: r.signal, searchParams: f(r), headers: r.headers })).json(); return Pp(n) || [] } return t }); var vp = u(e => { async function t(r, n = {}) { let o = await e.post("pubsub/peers", { signal: n.signal, searchParams: f({ arg: Mt(r), ...n }), headers: n.headers }), { Strings: s } = await o.json(); return s || [] } return t }); var Bp = u(e => { async function t(r, n, o = {}) { let s = f({ arg: Mt(r), ...o }), i = new AbortController, a = q(i.signal, o.signal); await (await e.post("pubsub/pub", { signal: a, searchParams: s, ...await M([n], i, o.headers) })).text() } return t }); var rb = nn("ipfs-http-client:pubsub:subscribe"), Ip = (e, t) => u(r => { async function n(o, s, i = {}) { i.signal = t.subscribe(o, s, i.signal); let a, c, p = new Promise((g, x) => { a = g, c = x }), d = setTimeout(() => a(), 1e3); return r.post("pubsub/sub", { signal: i.signal, searchParams: f({ arg: Mt(o), ...i }), headers: i.headers }).catch(g => { t.unsubscribe(o, s), c(g) }).then(g => { clearTimeout(d), g && (nb(g, { onMessage: x => { if (!!s) { if (typeof s == "function") { s(x); return } typeof s.handleEvent == "function" && s.handleEvent(x) } }, onEnd: () => t.unsubscribe(o, s), onError: i.onError }), a()) }), p } return n })(e); async function nb(e, { onMessage: t, onEnd: r, onError: n }) { n = n || rb; try { for await (let o of e.ndjson()) try { if (!o.from) continue; t({ from: z(o.from), data: Bs(o.data), sequenceNumber: Tp(o.seqno), topic: vs(o.topicIDs[0]) }) } catch (s) { s.message = `Failed to parse pubsub message: ${s.message}`, n(s, !1, o) } } catch (o) { ob(o) || n(o, !0) } finally { r() } } var ob = e => { switch (e.type) { case "aborted": return !0; case "abort": return !0; default: return e.name === "AbortError" } }; var _p = (e, t) => { async function r(n, o) { t.unsubscribe(n, o) } return r }; var Tn = class { constructor() { this._subs = new Map } subscribe(t, r, n) { let o = this._subs.get(t) || []; if (o.find(i => i.handler === r)) throw new Error(`Already subscribed to ${t} with this handler`); let s = new AbortController; return this._subs.set(t, [{ handler: r, controller: s }].concat(o)), n && n.addEventListener("abort", () => this.unsubscribe(t, r)), s.signal } unsubscribe(t, r) { let n = this._subs.get(t) || [], o; r ? (this._subs.set(t, n.filter(s => s.handler !== r)), o = n.filter(s => s.handler === r)) : (this._subs.set(t, []), o = n), (this._subs.get(t) || []).length || this._subs.delete(t), o.forEach(s => s.controller.abort()) } }; function kp(e) { let t = new Tn; return { ls: Ap(e), peers: vp(e), publish: Bp(e), subscribe: Ip(e, t), unsubscribe: _p(e, t) } } C(); var Up = u(e => { async function* t(r = {}) { yield* (await e.post("refs/local", { signal: r.signal, transform: A, searchParams: f(r), headers: r.headers })).ndjson() } return t }); var Np = u((e, t) => Object.assign(async function* (n, o = {}) { let s = Array.isArray(n) ? n : [n]; yield* (await e.post("refs", { signal: o.signal, searchParams: f({ arg: s.map(a => `${a instanceof Uint8Array ? m.decode(a) : a}`), ...o }), headers: o.headers, transform: A })).ndjson() }, { local: Up(t) })); C(); var Rp = u(e => { async function* t(r = {}) { yield* (await e.post("repo/gc", { signal: r.signal, searchParams: f(r), headers: r.headers, transform: o => ({ err: o.Error ? new Error(o.Error) : null, cid: (o.Key || {})["/"] ? m.parse(o.Key["/"]) : null }) })).ndjson() } return t }); var An = u(e => { async function t(r = {}) { let o = await (await e.post("repo/stat", { signal: r.signal, searchParams: f(r), headers: r.headers })).json(); return { numObjects: BigInt(o.NumObjects), repoSize: BigInt(o.RepoSize), repoPath: o.RepoPath, version: o.Version, storageMax: BigInt(o.StorageMax) } } return t }); var Op = u(e => { async function t(r = {}) { return (await (await e.post("repo/version", { signal: r.signal, searchParams: f(r), headers: r.headers })).json()).Version } return t }); function Lp(e) { return { gc: Rp(e), stat: An(e), version: Op(e) } } var Fp = u(e => { async function* t(r = {}) { yield* (await e.post("stats/bw", { signal: r.signal, searchParams: f(r), headers: r.headers, transform: o => ({ totalIn: BigInt(o.TotalIn), totalOut: BigInt(o.TotalOut), rateIn: parseFloat(o.RateIn), rateOut: parseFloat(o.RateOut) }) })).ndjson() } return t }); function $p(e) { return { bitswap: pn(e), repo: An(e), bw: Fp(e) } } var jp = u(e => { async function t(r = {}) { let n = await e.post("swarm/addrs", { signal: r.signal, searchParams: f(r), headers: r.headers }), { Addrs: o } = await n.json(); return Object.keys(o).map(s => ({ id: z(s), addrs: (o[s] || []).map(i => new P(i)) })) } return t }); var zp = u(e => { async function t(r, n = {}) { let o = await e.post("swarm/connect", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers }), { Strings: s } = await o.json(); return s || [] } return t }); var Mp = u(e => { async function t(r, n = {}) { let o = await e.post("swarm/disconnect", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers }), { Strings: s } = await o.json(); return s || [] } return t }); var qp = u(e => { async function t(r = {}) { let n = await e.post("swarm/addrs/local", { signal: r.signal, searchParams: f(r), headers: r.headers }), { Strings: o } = await n.json(); return (o || []).map(s => new P(s)) } return t }); var Hp = u(e => { async function t(r = {}) { let n = await e.post("swarm/peers", { signal: r.signal, searchParams: f(r), headers: r.headers }), { Peers: o } = await n.json(); return (o || []).map(s => ({ addr: new P(s.Addr), peer: z(s.Peer), muxer: s.Muxer, latency: s.Latency, streams: s.Streams, direction: s.Direction == null ? void 0 : s.Direction === 0 ? "inbound" : "outbound" })) } return t }); function Vp(e) { return { addrs: jp(e), connect: zp(e), disconnect: Mp(e), localAddrs: qp(e), peers: Hp(e) } } C(); var vn = u(e => { async function* t(r, n = {}) { let o = new AbortController, s = q(o.signal, n.signal), { headers: i, body: a, total: c, parts: p } = await M(r, o, n.headers), [d, g] = typeof n.progress == "function" ? sb(c, p, n.progress) : [void 0, void 0], x = await e.post("add", { searchParams: f({ "stream-channels": !0, ...n, progress: Boolean(d) }), onUploadProgress: g, signal: s, headers: i, body: a }); for await (let N of x.ndjson()) N = A(N), N.hash !== void 0 ? yield ab(N) : d && d(N.bytes || 0, N.name) } return t }), sb = (e, t, r) => t ? [void 0, ib(e, t, r)] : [r, void 0], ib = (e, t, r) => { let n = 0, o = t.length; return ({ loaded: s, total: i }) => { let a = Math.floor(s / i * e); for (; n < o;) { let { start: c, end: p, name: d } = t[n]; if (a < p) { r(a - c, d); break } else r(p - c, d), n += 1 } } }; function ab({ name: e, hash: t, size: r, mode: n, mtime: o, mtimeNsecs: s }) { let i = { path: e, cid: m.parse(t), size: parseInt(r) }; return n != null && (i.mode = parseInt(n, 8)), o != null && (i.mtime = { secs: o, nsecs: s || 0 }), i } var id = S(br(), 1); var Kp = S(ee(), 1); var Xp = S(Lt(), 1), Qp = S(Jp(), 1), Zp = S(dr(), 1), Yp = S(cs(), 1), ed = S(us(), 1); async function* Bn(e) { yield e } async function td(e) { if (ge(e)) return Bn(Is(e)); if (typeof e == "string" || e instanceof String) return Bn(Is(e.toString())); if ($e(e)) return (0, Qp.default)(e); if (je(e) && (e = (0, Xp.default)(e)), Symbol.iterator in e || Symbol.asyncIterator in e) { let t = (0, Zp.default)(e), { value: r, done: n } = await t.peek(); if (n) return Bn(new Uint8Array(0)); if (t.push(r), Number.isInteger(r)) return Bn(Uint8Array.from(await (0, Yp.default)(t))); if (ge(r) || typeof r == "string" || r instanceof String) return (0, ed.default)(t, Is) } throw (0, Kp.default)(new Error(`Unexpected input: ${e}`), "ERR_UNEXPECTED_INPUT") } function Is(e) { return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e instanceof ArrayBuffer ? new Uint8Array(e) : Array.isArray(e) ? Uint8Array.from(e) : ce(e.toString()) } var _n = S(ee(), 1), rd = S(Lt(), 1), nd = S(dr(), 1); async function* od(e, t) { if (e == null) throw (0, _n.default)(new Error(`Unexpected input: ${e}`), "ERR_UNEXPECTED_INPUT"); if (typeof e == "string" || e instanceof String) { yield In(e.toString(), t); return } if (ge(e) || $e(e)) { yield In(e, t); return } if (je(e) && (e = (0, rd.default)(e)), Symbol.iterator in e || Symbol.asyncIterator in e) { let r = (0, nd.default)(e), { value: n, done: o } = await r.peek(); if (o) { yield { content: [] }; return } if (r.push(n), Number.isInteger(n) || ge(n) || typeof n == "string" || n instanceof String) { yield In(r, t); return } throw (0, _n.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT") } if (mr(e)) { yield In(e, t); return } throw (0, _n.default)(new Error('Unexpected input: cannot convert "' + typeof e + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT") } async function In(e, t) { let { path: r, mode: n, mtime: o, content: s } = e, i = { path: r || "", mode: wn(n), mtime: bn(o) }; return s ? i.content = await t(s) : r || (i.content = await t(e)), i } function sd(e) { return od(e, td) } function ad(e) { let t = vn(e); return u(() => { async function r(n, o = {}) { return await (0, id.default)(t(sd(n), o)) } return r })(e) } var cd = u(e => { async function* t(r, n = {}) { yield* (await e.post("cat", { signal: n.signal, searchParams: f({ arg: r.toString(), ...n }), headers: n.headers })).iterator() } return t }); var ud = u(e => async (r = {}) => (await e.post("commands", { signal: r.signal, searchParams: f(r), headers: r.headers })).json()); var fd = u(e => async (r, n = {}) => (await (await e.post("dns", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers })).json()).Path); var ld = u(e => () => { let t = new URL(e.opts.base || ""); return { host: t.hostname, port: t.port, protocol: t.protocol, pathname: t.pathname, "api-path": t.pathname } }); C(); var pd = u(e => { async function* t(r, n = {}) { let o = { arg: `${r instanceof Uint8Array ? m.decode(r) : r}`, ...n }; o.compressionLevel && (o["compression-level"] = o.compressionLevel, delete o.compressionLevel), yield* (await e.post("get", { signal: n.signal, searchParams: f(o), headers: n.headers })).iterator() } return t }); var kn = u(e => { async function t(r = {}) { let o = await (await e.post("id", { signal: r.signal, searchParams: f({ arg: r.peerId ? r.peerId.toString() : void 0, ...r }), headers: r.headers })).json(), s = { ...A(o) }; return s.id = z(s.id), s.addresses && (s.addresses = s.addresses.map(i => new P(i))), s } return t }); var dd = e => { let t = kn(e); async function r(n = {}) { let o = await t(n); return Boolean(o && o.addresses && o.addresses.length) } return r }; C(); var md = u((e, t) => { async function* r(n, o = {}) { let s = `${n instanceof Uint8Array ? m.decode(n) : n}`; async function i(c) { let p = c.Hash; if (p.includes("/")) { let g = p.startsWith("/ipfs/") ? p : `/ipfs/${p}`; p = (await En(t)(g)).cid } else p = m.parse(p); let d = { name: c.Name, path: s + (c.Name ? `/${c.Name}` : ""), size: c.Size, cid: p, type: ub(c) }; return c.Mode && (d.mode = parseInt(c.Mode, 8)), c.Mtime !== void 0 && c.Mtime !== null && (d.mtime = { secs: c.Mtime }, c.MtimeNsecs !== void 0 && c.MtimeNsecs !== null && (d.mtime.nsecs = c.MtimeNsecs)), d } let a = await e.post("ls", { signal: o.signal, searchParams: f({ arg: s, ...o }), headers: o.headers }); for await (let c of a.ndjson()) { if (c = c.Objects, !c) throw new Error("expected .Objects in results"); if (c = c[0], !c) throw new Error("expected one array in results.Objects"); let p = c.Links; if (!Array.isArray(p)) throw new Error("expected one array in results.Objects[0].Links"); if (!p.length) { yield i(c); return } yield* p.map(i) } } return r }); function ub(e) { switch (e.Type) { case 1: case 5: return "dir"; case 2: return "file"; default: return "file" } } var hd = u(e => { async function t(r = {}) { let n = await e.post("dns", { signal: r.signal, searchParams: f(r), headers: r.headers }); return A(await n.json()) } return t }); var gd = u(e => { async function* t(r, n = {}) { yield* (await e.post("ping", { signal: n.signal, searchParams: f({ arg: `${r}`, ...n }), headers: n.headers, transform: A })).ndjson() } return t }); var yd = u(e => { async function t(r, n = {}) { let o = await e.post("resolve", { signal: n.signal, searchParams: f({ arg: r, ...n }), headers: n.headers }), { Path: s } = await o.json(); return s } return t }); var wd = S(ee(), 1), bd = u(e => async (r = {}) => { throw (0, wd.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED") }); var Dd = u(e => { async function t(r = {}) { await (await e.post("shutdown", { signal: r.signal, searchParams: f(r), headers: r.headers })).text() } return t }); var Ed = u(e => { async function t(r = {}) { let n = await e.post("version", { signal: r.signal, searchParams: f(r), headers: r.headers }); return { ...A(await n.json()), "ipfs-http-client": "1.0.0" } } return t }); var Pd = S(xd(), 1); C(); var Td = S(Cd(), 1); function mb(e = {}) { let t = { name: ct.name, code: ct.code, encode: p => p, decode: p => p }, r = Object.values(Je); (e.ipld && e.ipld.bases ? e.ipld.bases : []).forEach(p => r.push(p)); let n = new Sr({ bases: r, loadBase: e.ipld && e.ipld.loadBase }), o = Object.values(ka);[Hn, co, yo, db, t].concat(e.ipld && e.ipld.codecs || []).forEach(p => o.push(p)); let s = new Cr({ codecs: o, loadCodec: e.ipld && e.ipld.loadCodec }), i = Object.values(_a); (e.ipld && e.ipld.hashers ? e.ipld.hashers : []).forEach(p => i.push(p)); let a = new Pr({ hashers: i, loadHasher: e.ipld && e.ipld.loadHasher }); return { add: ad(e), addAll: vn(e), bitswap: au(e), block: Tf(e), bootstrap: kf(e), cat: cd(e), commands: ud(e), config: jf(e), dag: Qf(s, e), dht: ol(e), diag: cl(e), dns: fd(e), files: Cl(e), get: pd(e), getEndpointConfig: ld(e), id: kn(e), isOnline: dd(e), key: Nl(e), log: Fl(e), ls: md(e), mount: hd(e), name: Vl(e), object: np(s, e), pin: Cp(e), ping: gd(e), pubsub: kp(e), refs: Np(e), repo: Lp(e), resolve: yd(e), start: bd(e), stats: $p(e), stop: Dd(e), swarm: Vp(e), version: Ed(e), bases: n, codecs: s, hashers: a } } var hb = Pd.default; return xr(gb);
            })();
            return IpfsHttpClient
        }));
    </script>
    <script type="text/javascript">
        !function (e, t) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return t(e) } : t(e) }("undefined" != typeof window ? window : this, function (C, e) { "use strict"; var t = [], r = Object.getPrototypeOf, s = t.slice, g = t.flat ? function (e) { return t.flat.call(e) } : function (e) { return t.concat.apply([], e) }, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call(Object), y = {}, m = function (e) { return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item }, x = function (e) { return null != e && e === e.window }, E = C.document, c = { type: !0, src: !0, nonce: !0, noModule: !0 }; function b(e, t, n) { var r, i, o = (n = n || E).createElement("script"); if (o.text = e, t) for (r in c) (i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i); n.head.appendChild(o).parentNode.removeChild(o) } function w(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e } var f = "3.6.0", S = function (e, t) { return new S.fn.init(e, t) }; function p(e) { var t = !!e && "length" in e && e.length, n = w(e); return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e) } S.fn = S.prototype = { jquery: f, constructor: S, length: 0, toArray: function () { return s.call(this) }, get: function (e) { return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function (e) { var t = S.merge(this.constructor(), e); return t.prevObject = this, t }, each: function (e) { return S.each(this, e) }, map: function (n) { return this.pushStack(S.map(this, function (e, t) { return n.call(e, t, e) })) }, slice: function () { return this.pushStack(s.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, even: function () { return this.pushStack(S.grep(this, function (e, t) { return (t + 1) % 2 })) }, odd: function () { return this.pushStack(S.grep(this, function (e, t) { return t % 2 })) }, eq: function (e) { var t = this.length, n = +e + (e < 0 ? t : 0); return this.pushStack(0 <= n && n < t ? [this[n]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: u, sort: t.sort, splice: t.splice }, S.extend = S.fn.extend = function () { var e, t, n, r, i, o, a = arguments[0] || {}, s = 1, u = arguments.length, l = !1; for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++)if (null != (e = arguments[s])) for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r)); return a }, S.extend({ expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) { throw new Error(e) }, noop: function () { }, isPlainObject: function (e) { var t, n; return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof (n = v.call(t, "constructor") && t.constructor) && a.call(n) === l) }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0 }, globalEval: function (e, t, n) { b(e, { nonce: t && t.nonce }, n) }, each: function (e, t) { var n, r = 0; if (p(e)) { for (n = e.length; r < n; r++)if (!1 === t.call(e[r], r, e[r])) break } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e }, makeArray: function (e, t) { var n = t || []; return null != e && (p(Object(e)) ? S.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)), n }, inArray: function (e, t, n) { return null == t ? -1 : i.call(t, e, n) }, merge: function (e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++)e[i++] = t[r]; return e.length = i, e }, grep: function (e, t, n) { for (var r = [], i = 0, o = e.length, a = !n; i < o; i++)!t(e[i], i) !== a && r.push(e[i]); return r }, map: function (e, t, n) { var r, i, o = 0, a = []; if (p(e)) for (r = e.length; o < r; o++)null != (i = t(e[o], o, n)) && a.push(i); else for (o in e) null != (i = t(e[o], o, n)) && a.push(i); return g(a) }, guid: 1, support: y }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) { n["[object " + t + "]"] = t.toLowerCase() }); var d = function (n) { var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, S = "sizzle" + 1 * new Date, p = n.document, k = 0, r = 0, m = ue(), x = ue(), A = ue(), N = ue(), j = function (e, t) { return e === t && (l = !0), 0 }, D = {}.hasOwnProperty, t = [], q = t.pop, L = t.push, H = t.push, O = t.slice, P = function (e, t) { for (var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n; return -1 }, R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", M = "[\\x20\\t\\r\\n\\f]", I = "(?:\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]", F = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)", B = new RegExp(M + "+", "g"), $ = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"), _ = new RegExp("^" + M + "*," + M + "*"), z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"), U = new RegExp(M + "|>"), X = new RegExp(F), V = new RegExp("^" + I + "$"), G = { ID: new RegExp("^#(" + I + ")"), CLASS: new RegExp("^\\.(" + I + ")"), TAG: new RegExp("^(" + I + "|[*])"), ATTR: new RegExp("^" + W), PSEUDO: new RegExp("^" + F), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"), bool: new RegExp("^(?:" + R + ")$", "i"), needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i") }, Y = /HTML$/i, Q = /^(?:input|select|textarea|button)$/i, J = /^h\d$/i, K = /^[^{]+\{\s*\[native \w/, Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ee = /[+~]/, te = new RegExp("\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\([^\\r\\n\\f])", "g"), ne = function (e, t) { var n = "0x" + e.slice(1) - 65536; return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)) }, re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ie = function (e, t) { return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e }, oe = function () { T() }, ae = be(function (e) { return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase() }, { dir: "parentNode", next: "legend" }); try { H.apply(t = O.call(p.childNodes), p.childNodes), t[p.childNodes.length].nodeType } catch (e) { H = { apply: t.length ? function (e, t) { L.apply(e, O.call(t)) } : function (e, t) { var n = e.length, r = 0; while (e[n++] = t[r++]); e.length = n - 1 } } } function se(t, e, n, r) { var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e ? e.nodeType : 9; if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n; if (!r && (T(e), e = e || C, E)) { if (11 !== p && (u = Z.exec(t))) if (i = u[1]) { if (9 === p) { if (!(a = e.getElementById(i))) return n; if (a.id === i) return n.push(a), n } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n } else { if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n; if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n } if (d.qsa && !N[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) { if (c = t, f = e, 1 === p && (U.test(t) || z.test(t))) { (f = ee.test(t) && ye(e.parentNode) || e) === e && d.scope || ((s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = S)), o = (l = h(t)).length; while (o--) l[o] = (s ? "#" + s : ":scope") + " " + xe(l[o]); c = l.join(",") } try { return H.apply(n, f.querySelectorAll(c)), n } catch (e) { N(t, !0) } finally { s === S && e.removeAttribute("id") } } } return g(t.replace($, "$1"), e, n, r) } function ue() { var r = []; return function e(t, n) { return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n } } function le(e) { return e[S] = !0, e } function ce(e) { var t = C.createElement("fieldset"); try { return !!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } } function fe(e, t) { var n = e.split("|"), r = n.length; while (r--) b.attrHandle[n[r]] = t } function pe(e, t) { var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return -1; return e ? 1 : -1 } function de(t) { return function (e) { return "input" === e.nodeName.toLowerCase() && e.type === t } } function he(n) { return function (e) { var t = e.nodeName.toLowerCase(); return ("input" === t || "button" === t) && e.type === n } } function ge(t) { return function (e) { return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t } } function ve(a) { return le(function (o) { return o = +o, le(function (e, t) { var n, r = a([], e.length, o), i = r.length; while (i--) e[n = r[i]] && (e[n] = !(t[n] = e[n])) }) }) } function ye(e) { return e && "undefined" != typeof e.getElementsByTagName && e } for (e in d = se.support = {}, i = se.isXML = function (e) { var t = e && e.namespaceURI, n = e && (e.ownerDocument || e).documentElement; return !Y.test(t || n && n.nodeName || "HTML") }, T = se.setDocument = function (e) { var t, n, r = e ? e.ownerDocument || e : p; return r != C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), p != C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.scope = ce(function (e) { return a.appendChild(e).appendChild(C.createElement("div")), "undefined" != typeof e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length }), d.attributes = ce(function (e) { return e.className = "i", !e.getAttribute("className") }), d.getElementsByTagName = ce(function (e) { return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function (e) { return a.appendChild(e).id = S, !C.getElementsByName || !C.getElementsByName(S).length }), d.getById ? (b.filter.ID = function (e) { var t = e.replace(te, ne); return function (e) { return e.getAttribute("id") === t } }, b.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && E) { var n = t.getElementById(e); return n ? [n] : [] } }) : (b.filter.ID = function (e) { var n = e.replace(te, ne); return function (e) { var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id"); return t && t.value === n } }, b.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && E) { var n, r, i, o = t.getElementById(e); if (o) { if ((n = o.getAttributeNode("id")) && n.value === e) return [o]; i = t.getElementsByName(e), r = 0; while (o = i[r++]) if ((n = o.getAttributeNode("id")) && n.value === e) return [o] } return [] } }), b.find.TAG = d.getElementsByTagName ? function (e, t) { return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0 } : function (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName(e); if ("*" === e) { while (n = o[i++]) 1 === n.nodeType && r.push(n); return r } return o }, b.find.CLASS = d.getElementsByClassName && function (e, t) { if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e) }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function (e) { var t; a.appendChild(e).innerHTML = "<a id='" + S + "'></a><select id='" + S + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + S + "-]").length || v.push("~="), (t = C.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || v.push("\\[" + M + "*name" + M + "*=" + M + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + S + "+*").length || v.push(".#.+[+~]"), e.querySelectorAll("\\\f"), v.push("[\\r\\n\\f]") }), ce(function (e) { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var t = C.createElement("input"); t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:") })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function (e) { d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", F) }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function (e, t) { var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode; return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))) } : function (e, t) { if (t) while (t = t.parentNode) if (t === e) return !0; return !1 }, j = t ? function (e, t) { if (e === t) return l = !0, 0; var n = !e.compareDocumentPosition - !t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e == C || e.ownerDocument == p && y(p, e) ? -1 : t == C || t.ownerDocument == p && y(p, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1) } : function (e, t) { if (e === t) return l = !0, 0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (!i || !o) return e == C ? -1 : t == C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0; if (i === o) return pe(e, t); n = e; while (n = n.parentNode) a.unshift(n); n = t; while (n = n.parentNode) s.unshift(n); while (a[r] === s[r]) r++; return r ? pe(a[r], s[r]) : a[r] == p ? -1 : s[r] == p ? 1 : 0 }), C }, se.matches = function (e, t) { return se(e, null, null, t) }, se.matchesSelector = function (e, t) { if (T(e), d.matchesSelector && E && !N[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try { var n = c.call(e, t); if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n } catch (e) { N(t, !0) } return 0 < se(t, C, null, [e]).length }, se.contains = function (e, t) { return (e.ownerDocument || e) != C && T(e), y(e, t) }, se.attr = function (e, t) { (e.ownerDocument || e) != C && T(e); var n = b.attrHandle[t.toLowerCase()], r = n && D.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0; return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }, se.escape = function (e) { return (e + "").replace(re, ie) }, se.error = function (e) { throw new Error("Syntax error, unrecognized expression: " + e) }, se.uniqueSort = function (e) { var t, n = [], r = 0, i = 0; if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(j), l) { while (t = e[i++]) t === e[i] && (r = n.push(i)); while (r--) e.splice(n[r], 1) } return u = null, e }, o = se.getText = function (e) { var t, n = "", r = 0, i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += o(e) } else if (3 === i || 4 === i) return e.nodeValue } else while (t = e[r++]) n += o(t); return n }, (b = se.selectors = { cacheLength: 50, createPseudo: le, match: G, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e }, PSEUDO: function (e) { var t, n = !e[6] && e[2]; return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function (e) { var t = e.replace(te, ne).toLowerCase(); return "*" === e ? function () { return !0 } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t } }, CLASS: function (e) { var t = m[e + " "]; return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && m(e, function (e) { return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "") }) }, ATTR: function (n, r, i) { return function (e) { var t = se.attr(e, n); return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(B, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-")) } }, CHILD: function (h, e, t, g, v) { var y = "nth" !== h.slice(0, 3), m = "last" !== h.slice(-4), x = "of-type" === e; return 1 === g && 0 === v ? function (e) { return !!e.parentNode } : function (e, t, n) { var r, i, o, a, s, u, l = y !== m ? "nextSibling" : "previousSibling", c = e.parentNode, f = x && e.nodeName.toLowerCase(), p = !n && !x, d = !1; if (c) { if (y) { while (l) { a = e; while (a = a[l]) if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1; u = l = "only" === h && !u && "nextSibling" } return !0 } if (u = [m ? c.firstChild : c.lastChild], m && p) { d = (s = (r = (i = (o = (a = c)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]) && r[2], a = s && c.childNodes[s]; while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if (1 === a.nodeType && ++d && a === e) { i[h] = [k, s, d]; break } } else if (p && (d = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]), !1 === d) while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [k, d]), a === e)) break; return (d -= v) === g || d % g == 0 && 0 <= d / g } } }, PSEUDO: function (e, o) { var t, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e); return a[S] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function (e, t) { var n, r = a(e, o), i = r.length; while (i--) e[n = P(e, r[i])] = !(t[n] = r[i]) }) : function (e) { return a(e, 0, t) }) : a } }, pseudos: { not: le(function (e) { var r = [], i = [], s = f(e.replace($, "$1")); return s[S] ? le(function (e, t, n, r) { var i, o = s(e, null, r, []), a = e.length; while (a--) (i = o[a]) && (e[a] = !(t[a] = i)) }) : function (e, t, n) { return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop() } }), has: le(function (t) { return function (e) { return 0 < se(t, e).length } }), contains: le(function (t) { return t = t.replace(te, ne), function (e) { return -1 < (e.textContent || o(e)).indexOf(t) } }), lang: le(function (n) { return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(), function (e) { var t; do { if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-") } while ((e = e.parentNode) && 1 === e.nodeType); return !1 } }), target: function (e) { var t = n.location && n.location.hash; return t && t.slice(1) === e.id }, root: function (e) { return e === a }, focus: function (e) { return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) }, enabled: ge(!1), disabled: ge(!0), checked: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1; return !0 }, parent: function (e) { return !b.pseudos.empty(e) }, header: function (e) { return J.test(e.nodeName) }, input: function (e) { return Q.test(e.nodeName) }, button: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t }, text: function (e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()) }, first: ve(function () { return [0] }), last: ve(function (e, t) { return [t - 1] }), eq: ve(function (e, t, n) { return [n < 0 ? n + t : n] }), even: ve(function (e, t) { for (var n = 0; n < t; n += 2)e.push(n); return e }), odd: ve(function (e, t) { for (var n = 1; n < t; n += 2)e.push(n); return e }), lt: ve(function (e, t, n) { for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;)e.push(r); return e }), gt: ve(function (e, t, n) { for (var r = n < 0 ? n + t : n; ++r < t;)e.push(r); return e }) } }).pseudos.nth = b.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) b.pseudos[e] = de(e); for (e in { submit: !0, reset: !0 }) b.pseudos[e] = he(e); function me() { } function xe(e) { for (var t = 0, n = e.length, r = ""; t < n; t++)r += e[t].value; return r } function be(s, e, t) { var u = e.dir, l = e.next, c = l || u, f = t && "parentNode" === c, p = r++; return e.first ? function (e, t, n) { while (e = e[u]) if (1 === e.nodeType || f) return s(e, t, n); return !1 } : function (e, t, n) { var r, i, o, a = [k, p]; if (n) { while (e = e[u]) if ((1 === e.nodeType || f) && s(e, t, n)) return !0 } else while (e = e[u]) if (1 === e.nodeType || f) if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e; else { if ((r = i[c]) && r[0] === k && r[1] === p) return a[2] = r[2]; if ((i[c] = a)[2] = s(e, t, n)) return !0 } return !1 } } function we(i) { return 1 < i.length ? function (e, t, n) { var r = i.length; while (r--) if (!i[r](e, t, n)) return !1; return !0 } : i[0] } function Te(e, t, n, r, i) { for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s))); return a } function Ce(d, h, g, v, y, e) { return v && !v[S] && (v = Ce(v)), y && !y[S] && (y = Ce(y, e)), le(function (e, t, n, r) { var i, o, a, s = [], u = [], l = t.length, c = e || function (e, t, n) { for (var r = 0, i = t.length; r < i; r++)se(e, t[r], n); return n }(h || "*", n.nodeType ? [n] : n, []), f = !d || !e && h ? c : Te(c, s, d, n, r), p = g ? y || (e ? d : l || v) ? [] : t : f; if (g && g(f, p, n, r), v) { i = Te(p, u), v(i, [], n, r), o = i.length; while (o--) (a = i[o]) && (p[u[o]] = !(f[u[o]] = a)) } if (e) { if (y || d) { if (y) { i = [], o = p.length; while (o--) (a = p[o]) && i.push(f[o] = a); y(null, p = [], i, r) } o = p.length; while (o--) (a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a)) } } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p) }) } function Ee(e) { for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function (e) { return e === i }, a, !0), l = be(function (e) { return -1 < P(i, e) }, a, !0), c = [function (e, t, n) { var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n)); return i = null, r }]; s < r; s++)if (t = b.relative[e[s].type]) c = [be(we(c), t)]; else { if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) { for (n = ++s; n < r; n++)if (b.relative[e[n].type]) break; return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({ value: " " === e[s - 2].type ? "*" : "" })).replace($, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e)) } c.push(t) } return we(c) } return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function (e, t) { var n, r, i, o, a, s, u, l = x[e + " "]; if (l) return t ? 0 : l.slice(0); a = e, s = [], u = b.preFilter; while (a) { for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({ value: n, type: r[0].replace($, " ") }), a = a.slice(n.length)), b.filter) !(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({ value: n, type: o, matches: r }), a = a.slice(n.length)); if (!n) break } return t ? a.length : a ? se.error(e) : x(e, s).slice(0) }, f = se.compile = function (e, t) { var n, v, y, m, x, r, i = [], o = [], a = A[e + " "]; if (!a) { t || (t = h(e)), n = t.length; while (n--) (a = Ee(t[n]))[S] ? i.push(a) : o.push(a); (a = A(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function (e, t, n, r, i) { var o, a, s, u = 0, l = "0", c = e && [], f = [], p = w, d = e || x && b.find.TAG("*", i), h = k += null == p ? 1 : Math.random() || .1, g = d.length; for (i && (w = t == C || t || i); l !== g && null != (o = d[l]); l++) { if (x && o) { a = 0, t || o.ownerDocument == C || (T(o), n = !E); while (s = v[a++]) if (s(o, t || C, n)) { r.push(o); break } i && (k = h) } m && ((o = !s && o) && u--, e && c.push(o)) } if (u += l, m && l !== u) { a = 0; while (s = y[a++]) s(c, f, t, n); if (e) { if (0 < u) while (l--) c[l] || f[l] || (f[l] = q.call(r)); f = Te(f) } H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r) } return i && (k = h, w = p), c }, m ? le(r) : r))).selector = e } return a }, g = se.select = function (e, t, n, r) { var i, o, a, s, u, l = "function" == typeof e && e, c = !r && h(e = l.selector || e); if (n = n || [], 1 === c.length) { if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) { if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n; l && (t = t.parentNode), e = e.slice(o.shift().value.length) } i = G.needsContext.test(e) ? 0 : o.length; while (i--) { if (a = o[i], b.relative[s = a.type]) break; if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) { if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n; break } } } return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n }, d.sortStable = S.split("").sort(j).join("") === S, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function (e) { return 1 & e.compareDocumentPosition(C.createElement("fieldset")) }), ce(function (e) { return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href") }) || fe("type|href|height|width", function (e, t, n) { if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2) }), d.attributes && ce(function (e) { return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value") }) || fe("value", function (e, t, n) { if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue }), ce(function (e) { return null == e.getAttribute("disabled") }) || fe(R, function (e, t, n) { var r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }), se }(C); S.find = d, S.expr = d.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape; var h = function (e, t, n) { var r = [], i = void 0 !== n; while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) { if (i && S(e).is(n)) break; r.push(e) } return r }, T = function (e, t) { for (var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e); return n }, k = S.expr.match.needsContext; function A(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() } var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; function j(e, n, r) { return m(n) ? S.grep(e, function (e, t) { return !!n.call(e, t, e) !== r }) : n.nodeType ? S.grep(e, function (e) { return e === n !== r }) : "string" != typeof n ? S.grep(e, function (e) { return -1 < i.call(n, e) !== r }) : S.filter(n, e, r) } S.filter = function (e, t, n) { var r = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ? [r] : [] : S.find.matches(e, S.grep(t, function (e) { return 1 === e.nodeType })) }, S.fn.extend({ find: function (e) { var t, n, r = this.length, i = this; if ("string" != typeof e) return this.pushStack(S(e).filter(function () { for (t = 0; t < r; t++)if (S.contains(i[t], this)) return !0 })); for (n = this.pushStack([]), t = 0; t < r; t++)S.find(e, i[t], n); return 1 < r ? S.uniqueSort(n) : n }, filter: function (e) { return this.pushStack(j(this, e || [], !1)) }, not: function (e) { return this.pushStack(j(this, e || [], !0)) }, is: function (e) { return !!j(this, "string" == typeof e && k.test(e) ? S(e) : e || [], !1).length } }); var D, q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (S.fn.init = function (e, t, n) { var r, i; if (!e) return this; if (n = n || D, "string" == typeof e) { if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : q.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (r[1]) { if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), N.test(r[1]) && S.isPlainObject(t)) for (r in t) m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]); return this } return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this } return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this) }).prototype = S.fn, D = S(E); var L = /^(?:parents|prev(?:Until|All))/, H = { children: !0, contents: !0, next: !0, prev: !0 }; function O(e, t) { while ((e = e[t]) && 1 !== e.nodeType); return e } S.fn.extend({ has: function (e) { var t = S(e, this), n = t.length; return this.filter(function () { for (var e = 0; e < n; e++)if (S.contains(this, t[e])) return !0 }) }, closest: function (e, t) { var n, r = 0, i = this.length, o = [], a = "string" != typeof e && S(e); if (!k.test(e)) for (; r < i; r++)for (n = this[r]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) { o.push(n); break } return this.pushStack(1 < o.length ? S.uniqueSort(o) : o) }, index: function (e) { return e ? "string" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (e, t) { return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t)))) }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }), S.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function (e) { return h(e, "parentNode") }, parentsUntil: function (e, t, n) { return h(e, "parentNode", n) }, next: function (e) { return O(e, "nextSibling") }, prev: function (e) { return O(e, "previousSibling") }, nextAll: function (e) { return h(e, "nextSibling") }, prevAll: function (e) { return h(e, "previousSibling") }, nextUntil: function (e, t, n) { return h(e, "nextSibling", n) }, prevUntil: function (e, t, n) { return h(e, "previousSibling", n) }, siblings: function (e) { return T((e.parentNode || {}).firstChild, e) }, children: function (e) { return T(e.firstChild) }, contents: function (e) { return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (A(e, "template") && (e = e.content || e), S.merge([], e.childNodes)) } }, function (r, i) { S.fn[r] = function (e, t) { var n = S.map(this, i, e); return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = S.filter(t, n)), 1 < this.length && (H[r] || S.uniqueSort(n), L.test(r) && n.reverse()), this.pushStack(n) } }); var P = /[^\x20\t\r\n\f]+/g; function R(e) { return e } function M(e) { throw e } function I(e, t, n, r) { var i; try { e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r)) } catch (e) { n.apply(void 0, [e]) } } S.Callbacks = function (r) { var e, n; r = "string" == typeof r ? (e = r, n = {}, S.each(e.match(P) || [], function (e, t) { n[t] = !0 }), n) : S.extend({}, r); var i, t, o, a, s = [], u = [], l = -1, c = function () { for (a = a || r.once, o = i = !0; u.length; l = -1) { t = u.shift(); while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1) } r.memory || (t = !1), i = !1, a && (s = t ? [] : "") }, f = { add: function () { return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) { S.each(e, function (e, t) { m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t) }) }(arguments), t && !i && c()), this }, remove: function () { return S.each(arguments, function (e, t) { var n; while (-1 < (n = S.inArray(t, s, n))) s.splice(n, 1), n <= l && l-- }), this }, has: function (e) { return e ? -1 < S.inArray(e, s) : 0 < s.length }, empty: function () { return s && (s = []), this }, disable: function () { return a = u = [], s = t = "", this }, disabled: function () { return !s }, lock: function () { return a = u = [], t || i || (s = t = ""), this }, locked: function () { return !!a }, fireWith: function (e, t) { return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this }, fire: function () { return f.fireWith(this, arguments), this }, fired: function () { return !!o } }; return f }, S.extend({ Deferred: function (e) { var o = [["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2], ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]], i = "pending", a = { state: function () { return i }, always: function () { return s.done(arguments).fail(arguments), this }, "catch": function (e) { return a.then(null, e) }, pipe: function () { var i = arguments; return S.Deferred(function (r) { S.each(o, function (e, t) { var n = m(i[t[4]]) && i[t[4]]; s[t[1]](function () { var e = n && n.apply(this, arguments); e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments) }) }), i = null }).promise() }, then: function (t, n, r) { var u = 0; function l(i, o, a, s) { return function () { var n = this, r = arguments, e = function () { var e, t; if (!(i < u)) { if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution"); t = e && ("object" == typeof e || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, R, s), l(u, o, M, s)) : (u++, t.call(e, l(u, o, R, s), l(u, o, M, s), l(u, o, R, o.notifyWith))) : (a !== R && (n = void 0, r = [e]), (s || o.resolveWith)(n, r)) } }, t = s ? e : function () { try { e() } catch (e) { S.Deferred.exceptionHook && S.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== M && (n = void 0, r = [e]), o.rejectWith(n, r)) } }; i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t)) } } return S.Deferred(function (e) { o[0][3].add(l(0, e, m(r) ? r : R, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : R)), o[2][3].add(l(0, e, m(n) ? n : M)) }).promise() }, promise: function (e) { return null != e ? S.extend(e, a) : a } }, s = {}; return S.each(o, function (e, t) { var n = t[2], r = t[5]; a[t[1]] = n.add, r && n.add(function () { i = r }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function () { return s[t[0] + "With"](this === s ? void 0 : this, arguments), this }, s[t[0] + "With"] = n.fireWith }), a.promise(s), e && e.call(s, s), s }, when: function (e) { var n = arguments.length, t = n, r = Array(t), i = s.call(arguments), o = S.Deferred(), a = function (t) { return function (e) { r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i) } }; if (n <= 1 && (I(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then(); while (t--) I(i[t], a(t), o.reject); return o.promise() } }); var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; S.Deferred.exceptionHook = function (e, t) { C.console && C.console.warn && e && W.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t) }, S.readyException = function (e) { C.setTimeout(function () { throw e }) }; var F = S.Deferred(); function B() { E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), S.ready() } S.fn.ready = function (e) { return F.then(e)["catch"](function (e) { S.readyException(e) }), this }, S.extend({ isReady: !1, readyWait: 1, ready: function (e) { (!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || F.resolveWith(E, [S]) } }), S.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B)); var $ = function (e, t, n, r, i, o, a) { var s = 0, u = e.length, l = null == n; if ("object" === w(n)) for (s in i = !0, n) $(e, t, s, n[s], !0, o, a); else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) { return l.call(S(e), n) })), t)) for (; s < u; s++)t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : l ? t.call(e) : u ? t(e[0], n) : o }, _ = /^-ms-/, z = /-([a-z])/g; function U(e, t) { return t.toUpperCase() } function X(e) { return e.replace(_, "ms-").replace(z, U) } var V = function (e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType }; function G() { this.expando = S.expando + G.uid++ } G.uid = 1, G.prototype = { cache: function (e) { var t = e[this.expando]; return t || (t = {}, V(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t }, set: function (e, t, n) { var r, i = this.cache(e); if ("string" == typeof t) i[X(t)] = n; else for (r in t) i[X(r)] = t[r]; return i }, get: function (e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)] }, access: function (e, t, n) { return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t) }, remove: function (e, t) { var n, r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in r ? [t] : t.match(P) || []).length; while (n--) delete r[t[n]] } (void 0 === t || S.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]) } }, hasData: function (e) { var t = e[this.expando]; return void 0 !== t && !S.isEmptyObject(t) } }; var Y = new G, Q = new G, J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, K = /[A-Z]/g; function Z(e, t, n) { var r, i; if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(K, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) { try { n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : J.test(i) ? JSON.parse(i) : i) } catch (e) { } Q.set(e, t, n) } else n = void 0; return n } S.extend({ hasData: function (e) { return Q.hasData(e) || Y.hasData(e) }, data: function (e, t, n) { return Q.access(e, t, n) }, removeData: function (e, t) { Q.remove(e, t) }, _data: function (e, t, n) { return Y.access(e, t, n) }, _removeData: function (e, t) { Y.remove(e, t) } }), S.fn.extend({ data: function (n, e) { var t, r, i, o = this[0], a = o && o.attributes; if (void 0 === n) { if (this.length && (i = Q.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) { t = a.length; while (t--) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = X(r.slice(5)), Z(o, r, i[r])); Y.set(o, "hasDataAttrs", !0) } return i } return "object" == typeof n ? this.each(function () { Q.set(this, n) }) : $(this, function (e) { var t; if (o && void 0 === e) return void 0 !== (t = Q.get(o, n)) ? t : void 0 !== (t = Z(o, n)) ? t : void 0; this.each(function () { Q.set(this, n, e) }) }, null, e, 1 < arguments.length, null, !0) }, removeData: function (e) { return this.each(function () { Q.remove(this, e) }) } }), S.extend({ queue: function (e, t, n) { var r; if (e) return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, S.makeArray(n)) : r.push(n)), r || [] }, dequeue: function (e, t) { t = t || "fx"; var n = S.queue(e, t), r = n.length, i = n.shift(), o = S._queueHooks(e, t); "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function () { S.dequeue(e, t) }, o)), !r && o && o.empty.fire() }, _queueHooks: function (e, t) { var n = t + "queueHooks"; return Y.get(e, n) || Y.access(e, n, { empty: S.Callbacks("once memory").add(function () { Y.remove(e, [t + "queue", n]) }) }) } }), S.fn.extend({ queue: function (t, n) { var e = 2; return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? S.queue(this[0], t) : void 0 === n ? this : this.each(function () { var e = S.queue(this, t, n); S._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && S.dequeue(this, t) }) }, dequeue: function (e) { return this.each(function () { S.dequeue(this, e) }) }, clearQueue: function (e) { return this.queue(e || "fx", []) }, promise: function (e, t) { var n, r = 1, i = S.Deferred(), o = this, a = this.length, s = function () { --r || i.resolveWith(o, [o]) }; "string" != typeof e && (t = e, e = void 0), e = e || "fx"; while (a--) (n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t) } }); var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"), ne = ["Top", "Right", "Bottom", "Left"], re = E.documentElement, ie = function (e) { return S.contains(e.ownerDocument, e) }, oe = { composed: !0 }; re.getRootNode && (ie = function (e) { return S.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument }); var ae = function (e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === S.css(e, "display") }; function se(e, t, n, r) { var i, o, a = 20, s = r ? function () { return r.cur() } : function () { return S.css(e, t, "") }, u = s(), l = n && n[3] || (S.cssNumber[t] ? "" : "px"), c = e.nodeType && (S.cssNumber[t] || "px" !== l && +u) && te.exec(S.css(e, t)); if (c && c[3] !== l) { u /= 2, l = l || c[3], c = +u || 1; while (a--) S.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o; c *= 2, S.style(e, t, c + l), n = n || [] } return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i } var ue = {}; function le(e, t) { for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)(r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Y.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && ae(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ue[s]) || (o = a.body.appendChild(a.createElement(s)), u = S.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ue[s] = u)))) : "none" !== n && (l[c] = "none", Y.set(r, "display", n))); for (c = 0; c < f; c++)null != l[c] && (e[c].style.display = l[c]); return e } S.fn.extend({ show: function () { return le(this, !0) }, hide: function () { return le(this) }, toggle: function (e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () { ae(this) ? S(this).show() : S(this).hide() }) } }); var ce, fe, pe = /^(?:checkbox|radio)$/i, de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, he = /^$|^module$|\/(?:java|ecma)script/i; ce = E.createDocumentFragment().appendChild(E.createElement("div")), (fe = E.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), ce.appendChild(fe), y.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked, ce.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue, ce.innerHTML = "<option></option>", y.option = !!ce.lastChild; var ge = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; function ve(e, t) { var n; return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? S.merge([e], n) : n } function ye(e, t) { for (var n = 0, r = e.length; n < r; n++)Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval")) } ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]); var me = /<|&#?\w+;/; function xe(e, t, n, r, i) { for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)if ((o = e[d]) || 0 === o) if ("object" === w(o)) S.merge(p, o.nodeType ? [o] : o); else if (me.test(o)) { a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + S.htmlPrefilter(o) + u[2], c = u[0]; while (c--) a = a.lastChild; S.merge(p, a.childNodes), (a = f.firstChild).textContent = "" } else p.push(t.createTextNode(o)); f.textContent = "", d = 0; while (o = p[d++]) if (r && -1 < S.inArray(o, r)) i && i.push(o); else if (l = ie(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) { c = 0; while (o = a[c++]) he.test(o.type || "") && n.push(o) } return f } var be = /^([^.]*)(?:\.(.+)|)/; function we() { return !0 } function Te() { return !1 } function Ce(e, t) { return e === function () { try { return E.activeElement } catch (e) { } }() == ("focus" === t) } function Ee(e, t, n, r, i, o) { var a, s; if ("object" == typeof t) { for (s in "string" != typeof n && (r = r || n, n = void 0), t) Ee(e, s, n, r, t[s], o); return e } if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Te; else if (!i) return e; return 1 === o && (a = i, (i = function (e) { return S().off(e), a.apply(this, arguments) }).guid = a.guid || (a.guid = S.guid++)), e.each(function () { S.event.add(this, t, i, r, n) }) } function Se(e, i, o) { o ? (Y.set(e, i, !1), S.event.add(e, i, { namespace: !1, handler: function (e) { var t, n, r = Y.get(this, i); if (1 & e.isTrigger && this[i]) { if (r.length) (S.event.special[i] || {}).delegateType && e.stopPropagation(); else if (r = s.call(arguments), Y.set(this, i, r), t = o(this, i), this[i](), r !== (n = Y.get(this, i)) || t ? Y.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n && n.value } else r.length && (Y.set(this, i, { value: S.event.trigger(S.extend(r[0], S.Event.prototype), r.slice(1), this) }), e.stopImmediatePropagation()) } })) : void 0 === Y.get(e, i) && S.event.add(e, i, we) } S.event = { global: {}, add: function (t, e, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Y.get(t); if (V(t)) { n.handler && (n = (o = n).handler, i = o.selector), i && S.find.matchesSelector(re, i), n.guid || (n.guid = S.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function (e) { return "undefined" != typeof S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0 }), l = (e = (e || "").match(P) || [""]).length; while (l--) d = g = (s = be.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = S.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = S.event.special[d] || {}, c = S.extend({ type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && S.expr.match.needsContext.test(i), namespace: h.join(".") }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), S.event.global[d] = !0) } }, remove: function (e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Y.hasData(e) && Y.get(e); if (v && (u = v.events)) { l = (t = (t || "").match(P) || [""]).length; while (l--) if (d = g = (s = be.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) { f = S.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length; while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c)); a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || S.removeEvent(e, d, v.handle), delete u[d]) } else for (d in u) S.event.remove(e, d + t[l], n, r, !0); S.isEmptyObject(u) && Y.remove(e, "handle events") } }, dispatch: function (e) { var t, n, r, i, o, a, s = new Array(arguments.length), u = S.event.fix(e), l = (Y.get(this, "events") || Object.create(null))[u.type] || [], c = S.event.special[u.type] || {}; for (s[0] = u, t = 1; t < arguments.length; t++)s[t] = arguments[t]; if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) { a = S.event.handlers.call(this, u, l), t = 0; while ((i = a[t++]) && !u.isPropagationStopped()) { u.currentTarget = i.elem, n = 0; while ((o = i.handlers[n++]) && !u.isImmediatePropagationStopped()) u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation())) } return c.postDispatch && c.postDispatch.call(this, u), u.result } }, handlers: function (e, t) { var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType && !("click" === e.type && 1 <= e.button)) for (; l !== this; l = l.parentNode || this)if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) { for (o = [], a = {}, n = 0; n < u; n++)void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [l]).length), a[i] && o.push(r); o.length && s.push({ elem: l, handlers: o }) } return l = this, u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s }, addProp: function (t, e) { Object.defineProperty(S.Event.prototype, t, { enumerable: !0, configurable: !0, get: m(e) ? function () { if (this.originalEvent) return e(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[t] }, set: function (e) { Object.defineProperty(this, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) } }) }, fix: function (e) { return e[S.expando] ? e : new S.Event(e) }, special: { load: { noBubble: !0 }, click: { setup: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click", we), !1 }, trigger: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click"), !0 }, _default: function (e) { var t = e.target; return pe.test(t.type) && t.click && A(t, "input") && Y.get(t, "click") || A(t, "a") } }, beforeunload: { postDispatch: function (e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } } }, S.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n) }, S.Event = function (e, t) { if (!(this instanceof S.Event)) return new S.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? we : Te, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && S.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[S.expando] = !0 }, S.Event.prototype = { constructor: S.Event, isDefaultPrevented: Te, isPropagationStopped: Te, isImmediatePropagationStopped: Te, isSimulated: !1, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = we, e && !this.isSimulated && e.preventDefault() }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = we, e && !this.isSimulated && e.stopPropagation() }, stopImmediatePropagation: function () { var e = this.originalEvent; this.isImmediatePropagationStopped = we, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation() } }, S.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, "char": !0, code: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: !0 }, S.event.addProp), S.each({ focus: "focusin", blur: "focusout" }, function (e, t) { S.event.special[e] = { setup: function () { return Se(this, e, Ce), !1 }, trigger: function () { return Se(this, e), !0 }, _default: function () { return !0 }, delegateType: t } }), S.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (e, i) { S.event.special[e] = { delegateType: i, bindType: i, handle: function (e) { var t, n = e.relatedTarget, r = e.handleObj; return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t } } }), S.fn.extend({ on: function (e, t, n, r) { return Ee(this, e, t, n, r) }, one: function (e, t, n, r) { return Ee(this, e, t, n, r, 1) }, off: function (e, t, n) { var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this; if ("object" == typeof e) { for (i in e) this.off(i, t, e[i]); return this } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Te), this.each(function () { S.event.remove(this, e, n, t) }) } }); var ke = /<script|<style|<link/i, Ae = /checked\s*(?:[^=]|=\s*.checked.)/i, Ne = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; function je(e, t) { return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && S(e).children("tbody")[0] || e } function De(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e } function qe(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e } function Le(e, t) { var n, r, i, o, a, s; if (1 === t.nodeType) { if (Y.hasData(e) && (s = Y.get(e).events)) for (i in Y.remove(t, "handle events"), s) for (n = 0, r = s[i].length; n < r; n++)S.event.add(t, i, s[i][n]); Q.hasData(e) && (o = Q.access(e), a = S.extend({}, o), Q.set(t, a)) } } function He(n, r, i, o) { r = g(r); var e, t, a, s, u, l, c = 0, f = n.length, p = f - 1, d = r[0], h = m(d); if (h || 1 < f && "string" == typeof d && !y.checkClone && Ae.test(d)) return n.each(function (e) { var t = n.eq(e); h && (r[0] = d.call(this, e, t.html())), He(t, r, i, o) }); if (f && (t = (e = xe(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) { for (s = (a = S.map(ve(e, "script"), De)).length; c < f; c++)u = e, c !== p && (u = S.clone(u, !0, !0), s && S.merge(a, ve(u, "script"))), i.call(n[c], u, c); if (s) for (l = a[a.length - 1].ownerDocument, S.map(a, qe), c = 0; c < s; c++)u = a[c], he.test(u.type || "") && !Y.access(u, "globalEval") && S.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? S._evalUrl && !u.noModule && S._evalUrl(u.src, { nonce: u.nonce || u.getAttribute("nonce") }, l) : b(u.textContent.replace(Ne, ""), u, l)) } return n } function Oe(e, t, n) { for (var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++)n || 1 !== r.nodeType || S.cleanData(ve(r)), r.parentNode && (n && ie(r) && ye(ve(r, "script")), r.parentNode.removeChild(r)); return e } S.extend({ htmlPrefilter: function (e) { return e }, clone: function (e, t, n) { var r, i, o, a, s, u, l, c = e.cloneNode(!0), f = ie(e); if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e))) for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++)s = o[r], u = a[r], void 0, "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue); if (t) if (n) for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++)Le(o[r], a[r]); else Le(e, c); return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c }, cleanData: function (e) { for (var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++)if (V(n)) { if (t = n[Y.expando]) { if (t.events) for (r in t.events) i[r] ? S.event.remove(n, r) : S.removeEvent(n, r, t.handle); n[Y.expando] = void 0 } n[Q.expando] && (n[Q.expando] = void 0) } } }), S.fn.extend({ detach: function (e) { return Oe(this, e, !0) }, remove: function (e) { return Oe(this, e) }, text: function (e) { return $(this, function (e) { return void 0 === e ? S.text(this) : this.empty().each(function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) }) }, null, e, arguments.length) }, append: function () { return He(this, arguments, function (e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || je(this, e).appendChild(e) }) }, prepend: function () { return He(this, arguments, function (e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = je(this, e); t.insertBefore(e, t.firstChild) } }) }, before: function () { return He(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this) }) }, after: function () { return He(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) }) }, empty: function () { for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (S.cleanData(ve(e, !1)), e.textContent = ""); return this }, clone: function (e, t) { return e = null != e && e, t = null == t ? e : t, this.map(function () { return S.clone(this, e, t) }) }, html: function (e) { return $(this, function (e) { var t = this[0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !ke.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) { e = S.htmlPrefilter(e); try { for (; n < r; n++)1 === (t = this[n] || {}).nodeType && (S.cleanData(ve(t, !1)), t.innerHTML = e); t = 0 } catch (e) { } } t && this.empty().append(e) }, null, e, arguments.length) }, replaceWith: function () { var n = []; return He(this, arguments, function (e) { var t = this.parentNode; S.inArray(this, n) < 0 && (S.cleanData(ve(this)), t && t.replaceChild(e, this)) }, n) } }), S.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (e, a) { S.fn[e] = function (e) { for (var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++)t = o === i ? this : this.clone(!0), S(r[o])[a](t), u.apply(n, t.get()); return this.pushStack(n) } }); var Pe = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"), Re = function (e) { var t = e.ownerDocument.defaultView; return t && t.opener || (t = C), t.getComputedStyle(e) }, Me = function (e, t, n) { var r, i, o = {}; for (i in t) o[i] = e.style[i], e.style[i] = t[i]; for (i in r = n.call(e), t) e.style[i] = o[i]; return r }, Ie = new RegExp(ne.join("|"), "i"); function We(e, t, n) { var r, i, o, a, s = e.style; return (n = n || Re(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = S.style(e, t)), !y.pixelBoxStyles() && Pe.test(a) && Ie.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a } function Fe(e, t) { return { get: function () { if (!e()) return (this.get = t).apply(this, arguments); delete this.get } } } !function () { function e() { if (l) { u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", re.appendChild(u).appendChild(l); var e = C.getComputedStyle(l); n = "1%" !== e.top, s = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), l.style.position = "absolute", i = 12 === t(l.offsetWidth / 3), re.removeChild(u), l = null } } function t(e) { return Math.round(parseFloat(e)) } var n, r, i, o, a, s, u = E.createElement("div"), l = E.createElement("div"); l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend(y, { boxSizingReliable: function () { return e(), r }, pixelBoxStyles: function () { return e(), o }, pixelPosition: function () { return e(), n }, reliableMarginLeft: function () { return e(), s }, scrollboxSize: function () { return e(), i }, reliableTrDimensions: function () { var e, t, n, r; return null == a && (e = E.createElement("table"), t = E.createElement("tr"), n = E.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", re.appendChild(e).appendChild(t).appendChild(n), r = C.getComputedStyle(t), a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, re.removeChild(e)), a } })) }(); var Be = ["Webkit", "Moz", "ms"], $e = E.createElement("div").style, _e = {}; function ze(e) { var t = S.cssProps[e] || _e[e]; return t || (e in $e ? e : _e[e] = function (e) { var t = e[0].toUpperCase() + e.slice(1), n = Be.length; while (n--) if ((e = Be[n] + t) in $e) return e }(e) || e) } var Ue = /^(none|table(?!-c[ea]).+)/, Xe = /^--/, Ve = { position: "absolute", visibility: "hidden", display: "block" }, Ge = { letterSpacing: "0", fontWeight: "400" }; function Ye(e, t, n) { var r = te.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t } function Qe(e, t, n, r, i, o) { var a = "width" === t ? 1 : 0, s = 0, u = 0; if (n === (r ? "border" : "content")) return 0; for (; a < 4; a += 2)"margin" === n && (u += S.css(e, n + ne[a], !0, i)), r ? ("content" === n && (u -= S.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (u -= S.css(e, "border" + ne[a] + "Width", !0, i))) : (u += S.css(e, "padding" + ne[a], !0, i), "padding" !== n ? u += S.css(e, "border" + ne[a] + "Width", !0, i) : s += S.css(e, "border" + ne[a] + "Width", !0, i)); return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u } function Je(e, t, n) { var r = Re(e), i = (!y.boxSizingReliable() || n) && "border-box" === S.css(e, "boxSizing", !1, r), o = i, a = We(e, t, r), s = "offset" + t[0].toUpperCase() + t.slice(1); if (Pe.test(a)) { if (!n) return a; a = "auto" } return (!y.boxSizingReliable() && i || !y.reliableTrDimensions() && A(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === S.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === S.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + Qe(e, t, n || (i ? "border" : "content"), o, r, a) + "px" } function Ke(e, t, n, r, i) { return new Ke.prototype.init(e, t, n, r, i) } S.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = We(e, "opacity"); return "" === n ? "1" : n } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function (e, t, n, r) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var i, o, a, s = X(t), u = Xe.test(t), l = e.style; if (u || (t = ze(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t]; "string" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (S.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n)) } }, css: function (e, t, n, r) { var i, o, a, s = X(t); return Xe.test(t) || (t = ze(s)), (a = S.cssHooks[t] || S.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = We(e, t, r)), "normal" === i && t in Ge && (i = Ge[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i } }), S.each(["height", "width"], function (e, u) { S.cssHooks[u] = { get: function (e, t, n) { if (t) return !Ue.test(S.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Je(e, u, n) : Me(e, Ve, function () { return Je(e, u, n) }) }, set: function (e, t, n) { var r, i = Re(e), o = !y.scrollboxSize() && "absolute" === i.position, a = (o || n) && "border-box" === S.css(e, "boxSizing", !1, i), s = n ? Qe(e, u, n, a, i) : 0; return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - Qe(e, u, "border", !1, i) - .5)), s && (r = te.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = S.css(e, u)), Ye(0, t, s) } } }), S.cssHooks.marginLeft = Fe(y.reliableMarginLeft, function (e, t) { if (t) return (parseFloat(We(e, "marginLeft")) || e.getBoundingClientRect().left - Me(e, { marginLeft: 0 }, function () { return e.getBoundingClientRect().left })) + "px" }), S.each({ margin: "", padding: "", border: "Width" }, function (i, o) { S.cssHooks[i + o] = { expand: function (e) { for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++)n[i + ne[t] + o] = r[t] || r[t - 2] || r[0]; return n } }, "margin" !== i && (S.cssHooks[i + o].set = Ye) }), S.fn.extend({ css: function (e, t) { return $(this, function (e, t, n) { var r, i, o = {}, a = 0; if (Array.isArray(t)) { for (r = Re(e), i = t.length; a < i; a++)o[t[a]] = S.css(e, t[a], !1, r); return o } return void 0 !== n ? S.style(e, t, n) : S.css(e, t) }, e, t, 1 < arguments.length) } }), ((S.Tween = Ke).prototype = { constructor: Ke, init: function (e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (S.cssNumber[n] ? "" : "px") }, cur: function () { var e = Ke.propHooks[this.prop]; return e && e.get ? e.get(this) : Ke.propHooks._default.get(this) }, run: function (e) { var t, n = Ke.propHooks[this.prop]; return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Ke.propHooks._default.set(this), this } }).init.prototype = Ke.prototype, (Ke.propHooks = { _default: { get: function (e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0 }, set: function (e) { S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !S.cssHooks[e.prop] && null == e.elem.style[ze(e.prop)] ? e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit) } } }).scrollTop = Ke.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, S.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: "swing" }, S.fx = Ke.prototype.init, S.fx.step = {}; var Ze, et, tt, nt, rt = /^(?:toggle|show|hide)$/, it = /queueHooks$/; function ot() { et && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(ot) : C.setTimeout(ot, S.fx.interval), S.fx.tick()) } function at() { return C.setTimeout(function () { Ze = void 0 }), Ze = Date.now() } function st(e, t) { var n, r = 0, i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t)i["margin" + (n = ne[r])] = i["padding" + n] = e; return t && (i.opacity = i.width = e), i } function ut(e, t, n) { for (var r, i = (lt.tweeners[t] || []).concat(lt.tweeners["*"]), o = 0, a = i.length; o < a; o++)if (r = i[o].call(n, t, e)) return r } function lt(o, e, t) { var n, a, r = 0, i = lt.prefilters.length, s = S.Deferred().always(function () { delete u.elem }), u = function () { if (a) return !1; for (var e = Ze || at(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++)l.tweens[r].run(n); return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1) }, l = s.promise({ elem: o, props: S.extend({}, e), opts: S.extend(!0, { specialEasing: {}, easing: S.easing._default }, t), originalProperties: e, originalOptions: t, startTime: Ze || at(), duration: t.duration, tweens: [], createTween: function (e, t) { var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing); return l.tweens.push(n), n }, stop: function (e) { var t = 0, n = e ? l.tweens.length : 0; if (a) return this; for (a = !0; t < n; t++)l.tweens[t].run(1); return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this } }), c = l.props; for (!function (e, t) { var n, r, i, o, a; for (n in e) if (i = t[r = X(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && "expand" in a) for (n in o = a.expand(o), delete e[r], o) n in e || (e[n] = o[n], t[n] = i); else t[r] = i }(c, l.opts.specialEasing); r < i; r++)if (n = lt.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n; return S.map(c, ut, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), S.fx.timer(S.extend(u, { elem: o, anim: l, queue: l.opts.queue })), l } S.Animation = S.extend(lt, { tweeners: { "*": [function (e, t) { var n = this.createTween(e, t); return se(n.elem, e, te.exec(t), n), n }] }, tweener: function (e, t) { m(e) ? (t = e, e = ["*"]) : e = e.match(P); for (var n, r = 0, i = e.length; r < i; r++)n = e[r], lt.tweeners[n] = lt.tweeners[n] || [], lt.tweeners[n].unshift(t) }, prefilters: [function (e, t, n) { var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t, p = this, d = {}, h = e.style, g = e.nodeType && ae(e), v = Y.get(e, "fxshow"); for (r in n.queue || (null == (a = S._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () { a.unqueued || s() }), a.unqueued++, p.always(function () { p.always(function () { a.unqueued--, S.queue(e, "fx").length || a.empty.fire() }) })), t) if (i = t[r], rt.test(i)) { if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) { if ("show" !== i || !v || void 0 === v[r]) continue; g = !0 } d[r] = v && v[r] || S.style(e, r) } if ((u = !S.isEmptyObject(t)) || !S.isEmptyObject(d)) for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y.get(e, "display")), "none" === (c = S.css(e, "display")) && (l ? c = l : (le([e], !0), l = e.style.display || l, c = S.css(e, "display"), le([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === S.css(e, "float") && (u || (p.done(function () { h.display = l }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2] })), u = !1, d) u || (v ? "hidden" in v && (g = v.hidden) : v = Y.access(e, "fxshow", { display: l }), o && (v.hidden = !g), g && le([e], !0), p.done(function () { for (r in g || le([e]), Y.remove(e, "fxshow"), d) S.style(e, r, d[r]) })), u = ut(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0)) }], prefilter: function (e, t) { t ? lt.prefilters.unshift(e) : lt.prefilters.push(e) } }), S.speed = function (e, t, n) { var r = e && "object" == typeof e ? S.extend({}, e) : { complete: n || !n && t || m(e) && e, duration: e, easing: n && t || t && !m(t) && t }; return S.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () { m(r.old) && r.old.call(this), r.queue && S.dequeue(this, r.queue) }, r }, S.fn.extend({ fadeTo: function (e, t, n, r) { return this.filter(ae).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r) }, animate: function (t, e, n, r) { var i = S.isEmptyObject(t), o = S.speed(e, n, r), a = function () { var e = lt(this, S.extend({}, t), o); (i || Y.get(this, "finish")) && e.stop(!0) }; return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a) }, stop: function (i, e, o) { var a = function (e) { var t = e.stop; delete e.stop, t(o) }; return "string" != typeof i && (o = e, e = i, i = void 0), e && this.queue(i || "fx", []), this.each(function () { var e = !0, t = null != i && i + "queueHooks", n = S.timers, r = Y.get(this); if (t) r[t] && r[t].stop && a(r[t]); else for (t in r) r[t] && r[t].stop && it.test(t) && a(r[t]); for (t = n.length; t--;)n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1)); !e && o || S.dequeue(this, i) }) }, finish: function (a) { return !1 !== a && (a = a || "fx"), this.each(function () { var e, t = Y.get(this), n = t[a + "queue"], r = t[a + "queueHooks"], i = S.timers, o = n ? n.length : 0; for (t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;)i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1)); for (e = 0; e < o; e++)n[e] && n[e].finish && n[e].finish.call(this); delete t.finish }) } }), S.each(["toggle", "show", "hide"], function (e, r) { var i = S.fn[r]; S.fn[r] = function (e, t, n) { return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(st(r, !0), e, t, n) } }), S.each({ slideDown: st("show"), slideUp: st("hide"), slideToggle: st("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (e, r) { S.fn[e] = function (e, t, n) { return this.animate(r, e, t, n) } }), S.timers = [], S.fx.tick = function () { var e, t = 0, n = S.timers; for (Ze = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || S.fx.stop(), Ze = void 0 }, S.fx.timer = function (e) { S.timers.push(e), S.fx.start() }, S.fx.interval = 13, S.fx.start = function () { et || (et = !0, ot()) }, S.fx.stop = function () { et = null }, S.fx.speeds = { slow: 600, fast: 200, _default: 400 }, S.fn.delay = function (r, e) { return r = S.fx && S.fx.speeds[r] || r, e = e || "fx", this.queue(e, function (e, t) { var n = C.setTimeout(e, r); t.stop = function () { C.clearTimeout(n) } }) }, tt = E.createElement("input"), nt = E.createElement("select").appendChild(E.createElement("option")), tt.type = "checkbox", y.checkOn = "" !== tt.value, y.optSelected = nt.selected, (tt = E.createElement("input")).value = "t", tt.type = "radio", y.radioValue = "t" === tt.value; var ct, ft = S.expr.attrHandle; S.fn.extend({ attr: function (e, t) { return $(this, S.attr, e, t, 1 < arguments.length) }, removeAttr: function (e) { return this.each(function () { S.removeAttr(this, e) }) } }), S.extend({ attr: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? ct : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ? void 0 : r) }, attrHooks: { type: { set: function (e, t) { if (!y.radioValue && "radio" === t && A(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } }, removeAttr: function (e, t) { var n, r = 0, i = t && t.match(P); if (i && 1 === e.nodeType) while (n = i[r++]) e.removeAttribute(n) } }), ct = { set: function (e, t, n) { return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n), n } }, S.each(S.expr.match.bool.source.match(/\w+/g), function (e, t) { var a = ft[t] || S.find.attr; ft[t] = function (e, t, n) { var r, i, o = t.toLowerCase(); return n || (i = ft[o], ft[o] = r, r = null != a(e, t, n) ? o : null, ft[o] = i), r } }); var pt = /^(?:input|select|textarea|button)$/i, dt = /^(?:a|area)$/i; function ht(e) { return (e.match(P) || []).join(" ") } function gt(e) { return e.getAttribute && e.getAttribute("class") || "" } function vt(e) { return Array.isArray(e) ? e : "string" == typeof e && e.match(P) || [] } S.fn.extend({ prop: function (e, t) { return $(this, S.prop, e, t, 1 < arguments.length) }, removeProp: function (e) { return this.each(function () { delete this[S.propFix[e] || e] }) } }), S.extend({ prop: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t] }, propHooks: { tabIndex: { get: function (e) { var t = S.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : pt.test(e.nodeName) || dt.test(e.nodeName) && e.href ? 0 : -1 } } }, propFix: { "for": "htmlFor", "class": "className" } }), y.optSelected || (S.propHooks.selected = { get: function (e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null }, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex) } }), S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { S.propFix[this.toLowerCase()] = this }), S.fn.extend({ addClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { S(this).addClass(t.call(this, e, gt(this))) }); if ((e = vt(t)).length) while (n = this[u++]) if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") { a = 0; while (o = e[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " "); i !== (s = ht(r)) && n.setAttribute("class", s) } return this }, removeClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { S(this).removeClass(t.call(this, e, gt(this))) }); if (!arguments.length) return this.attr("class", ""); if ((e = vt(t)).length) while (n = this[u++]) if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") { a = 0; while (o = e[a++]) while (-1 < r.indexOf(" " + o + " ")) r = r.replace(" " + o + " ", " "); i !== (s = ht(r)) && n.setAttribute("class", s) } return this }, toggleClass: function (i, t) { var o = typeof i, a = "string" === o || Array.isArray(i); return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function (e) { S(this).toggleClass(i.call(this, e, gt(this), t), t) }) : this.each(function () { var e, t, n, r; if (a) { t = 0, n = S(this), r = vt(i); while (e = r[t++]) n.hasClass(e) ? n.removeClass(e) : n.addClass(e) } else void 0 !== i && "boolean" !== o || ((e = gt(this)) && Y.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Y.get(this, "__className__") || "")) }) }, hasClass: function (e) { var t, n, r = 0; t = " " + e + " "; while (n = this[r++]) if (1 === n.nodeType && -1 < (" " + ht(gt(n)) + " ").indexOf(t)) return !0; return !1 } }); var yt = /\r/g; S.fn.extend({ val: function (n) { var r, e, i, t = this[0]; return arguments.length ? (i = m(n), this.each(function (e) { var t; 1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = S.map(t, function (e) { return null == e ? "" : e + "" })), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t)) })) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(yt, "") : null == e ? "" : e : void 0 } }), S.extend({ valHooks: { option: { get: function (e) { var t = S.find.attr(e, "value"); return null != t ? t : ht(S.text(e)) } }, select: { get: function (e) { var t, n, r, i = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a ? null : [], u = a ? o + 1 : i.length; for (r = o < 0 ? u : a ? o : 0; r < u; r++)if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) { if (t = S(n).val(), a) return t; s.push(t) } return s }, set: function (e, t) { var n, r, i = e.options, o = S.makeArray(t), a = i.length; while (a--) ((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0); return n || (e.selectedIndex = -1), o } } } }), S.each(["radio", "checkbox"], function () { S.valHooks[this] = { set: function (e, t) { if (Array.isArray(t)) return e.checked = -1 < S.inArray(S(e).val(), t) } }, y.checkOn || (S.valHooks[this].get = function (e) { return null === e.getAttribute("value") ? "on" : e.value }) }), y.focusin = "onfocusin" in C; var mt = /^(?:focusinfocus|focusoutblur)$/, xt = function (e) { e.stopPropagation() }; S.extend(S.event, { trigger: function (e, t, n, r) { var i, o, a, s, u, l, c, f, p = [n || E], d = v.call(e, "type") ? e.type : e, h = v.call(e, "namespace") ? e.namespace.split(".") : []; if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !mt.test(d + S.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[S.expando] ? e : new S.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : S.makeArray(t, [e]), c = S.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) { if (!r && !c.noBubble && !x(n)) { for (s = c.delegateType || d, mt.test(s + d) || (o = o.parentNode); o; o = o.parentNode)p.push(o), a = o; a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C) } i = 0; while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Y.get(o, "events") || Object.create(null))[e.type] && Y.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && V(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault()); return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !V(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), S.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, xt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, xt), S.event.triggered = void 0, a && (n[u] = a)), e.result } }, simulate: function (e, t, n) { var r = S.extend(new S.Event, n, { type: e, isSimulated: !0 }); S.event.trigger(r, null, t) } }), S.fn.extend({ trigger: function (e, t) { return this.each(function () { S.event.trigger(e, t, this) }) }, triggerHandler: function (e, t) { var n = this[0]; if (n) return S.event.trigger(e, t, n, !0) } }), y.focusin || S.each({ focus: "focusin", blur: "focusout" }, function (n, r) { var i = function (e) { S.event.simulate(r, e.target, S.event.fix(e)) }; S.event.special[r] = { setup: function () { var e = this.ownerDocument || this.document || this, t = Y.access(e, r); t || e.addEventListener(n, i, !0), Y.access(e, r, (t || 0) + 1) }, teardown: function () { var e = this.ownerDocument || this.document || this, t = Y.access(e, r) - 1; t ? Y.access(e, r, t) : (e.removeEventListener(n, i, !0), Y.remove(e, r)) } } }); var bt = C.location, wt = { guid: Date.now() }, Tt = /\?/; S.parseXML = function (e) { var t, n; if (!e || "string" != typeof e) return null; try { t = (new C.DOMParser).parseFromString(e, "text/xml") } catch (e) { } return n = t && t.getElementsByTagName("parsererror")[0], t && !n || S.error("Invalid XML: " + (n ? S.map(n.childNodes, function (e) { return e.textContent }).join("\n") : e)), t }; var Ct = /\[\]$/, Et = /\r?\n/g, St = /^(?:submit|button|image|reset|file)$/i, kt = /^(?:input|select|textarea|keygen)/i; function At(n, e, r, i) { var t; if (Array.isArray(e)) S.each(e, function (e, t) { r || Ct.test(n) ? i(n, t) : At(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i) }); else if (r || "object" !== w(e)) i(n, e); else for (t in e) At(n + "[" + t + "]", e[t], r, i) } S.param = function (e, t) { var n, r = [], i = function (e, t) { var n = m(t) ? t() : t; r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n) }; if (null == e) return ""; if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function () { i(this.name, this.value) }); else for (n in e) At(n, e[n], t, i); return r.join("&") }, S.fn.extend({ serialize: function () { return S.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var e = S.prop(this, "elements"); return e ? S.makeArray(e) : this }).filter(function () { var e = this.type; return this.name && !S(this).is(":disabled") && kt.test(this.nodeName) && !St.test(e) && (this.checked || !pe.test(e)) }).map(function (e, t) { var n = S(this).val(); return null == n ? null : Array.isArray(n) ? S.map(n, function (e) { return { name: t.name, value: e.replace(Et, "\r\n") } }) : { name: t.name, value: n.replace(Et, "\r\n") } }).get() } }); var Nt = /%20/g, jt = /#.*$/, Dt = /([?&])_=[^&]*/, qt = /^(.*?):[ \t]*([^\r\n]*)$/gm, Lt = /^(?:GET|HEAD)$/, Ht = /^\/\//, Ot = {}, Pt = {}, Rt = "*/".concat("*"), Mt = E.createElement("a"); function It(o) { return function (e, t) { "string" != typeof e && (t = e, e = "*"); var n, r = 0, i = e.toLowerCase().match(P) || []; if (m(t)) while (n = i[r++]) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t) } } function Wt(t, i, o, a) { var s = {}, u = t === Pt; function l(e) { var r; return s[e] = !0, S.each(t[e] || [], function (e, t) { var n = t(i, o, a); return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1) }), r } return l(i.dataTypes[0]) || !s["*"] && l("*") } function Ft(e, t) { var n, r, i = S.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && S.extend(!0, e, r), e } Mt.href = bt.href, S.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: bt.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Rt, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": S.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? Ft(Ft(e, S.ajaxSettings), t) : Ft(S.ajaxSettings, e) }, ajaxPrefilter: It(Ot), ajaxTransport: It(Pt), ajax: function (e, t) { "object" == typeof e && (t = e, e = void 0), t = t || {}; var c, f, p, n, d, r, h, g, i, o, v = S.ajaxSetup({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event, x = S.Deferred(), b = S.Callbacks("once memory"), w = v.statusCode || {}, a = {}, s = {}, u = "canceled", T = { readyState: 0, getResponseHeader: function (e) { var t; if (h) { if (!n) { n = {}; while (t = qt.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2]) } t = n[e.toLowerCase() + " "] } return null == t ? null : t.join(", ") }, getAllResponseHeaders: function () { return h ? p : null }, setRequestHeader: function (e, t) { return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this }, overrideMimeType: function (e) { return null == h && (v.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (h) T.always(e[T.status]); else for (t in e) w[t] = [w[t], e[t]]; return this }, abort: function (e) { var t = e || u; return c && c.abort(t), l(0, t), this } }; if (x.promise(T), v.url = ((e || v.url || bt.href) + "").replace(Ht, bt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(P) || [""], null == v.crossDomain) { r = E.createElement("a"); try { r.href = v.url, r.href = r.href, v.crossDomain = Mt.protocol + "//" + Mt.host != r.protocol + "//" + r.host } catch (e) { v.crossDomain = !0 } } if (v.data && v.processData && "string" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Wt(Ot, v, t, T), h) return T; for (i in (g = S.event && v.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Lt.test(v.type), f = v.url.replace(jt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Nt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (Tt.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Dt, "$1"), o = (Tt.test(f) ? "&" : "?") + "_=" + wt.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader("If-Modified-Since", S.lastModified[f]), S.etag[f] && T.setRequestHeader("If-None-Match", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + Rt + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]); if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort(); if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Wt(Pt, v, t, T)) { if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T; v.async && 0 < v.timeout && (d = C.setTimeout(function () { T.abort("timeout") }, v.timeout)); try { h = !1, c.send(a, l) } catch (e) { if (h) throw e; l(-1, e) } } else l(-1, "No Transport"); function l(e, t, n, r) { var i, o, a, s, u, l = t; h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function (e, t, n) { var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type")); if (r) for (i in s) if (s[i] && s[i].test(r)) { u.unshift(i); break } if (u[0] in n) o = u[0]; else { for (i in n) { if (!u[0] || e.converters[i + " " + u[0]]) { o = i; break } a || (a = i) } o = o || a } if (o) return o !== u[0] && u.unshift(o), n[o] }(v, T, n)), !i && -1 < S.inArray("script", v.dataTypes) && S.inArray("json", v.dataTypes) < 0 && (v.converters["text script"] = function () { }), s = function (e, t, n, r) { var i, o, a, s, u, l = {}, c = e.dataTypes.slice(); if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a]; o = c.shift(); while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u; else if ("*" !== u && u !== o) { if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) { !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break } if (!0 !== a) if (a && e["throws"]) t = a(t); else try { t = a(t) } catch (e) { return { state: "parsererror", error: a ? e : "No conversion from " + u + " to " + o } } } return { state: "success", data: t } }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (S.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (S.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --S.active || S.event.trigger("ajaxStop"))) } return T }, getJSON: function (e, t, n) { return S.get(e, t, n, "json") }, getScript: function (e, t) { return S.get(e, void 0, t, "script") } }), S.each(["get", "post"], function (e, i) { S[i] = function (e, t, n, r) { return m(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({ url: e, type: i, dataType: r, data: t, success: n }, S.isPlainObject(e) && e)) } }), S.ajaxPrefilter(function (e) { var t; for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "") }), S._evalUrl = function (e, t, n) { return S.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, converters: { "text script": function () { } }, dataFilter: function (e) { S.globalEval(e, t, n) } }) }, S.fn.extend({ wrapAll: function (e) { var t; return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () { var e = this; while (e.firstElementChild) e = e.firstElementChild; return e }).append(this)), this }, wrapInner: function (n) { return m(n) ? this.each(function (e) { S(this).wrapInner(n.call(this, e)) }) : this.each(function () { var e = S(this), t = e.contents(); t.length ? t.wrapAll(n) : e.append(n) }) }, wrap: function (t) { var n = m(t); return this.each(function (e) { S(this).wrapAll(n ? t.call(this, e) : t) }) }, unwrap: function (e) { return this.parent(e).not("body").each(function () { S(this).replaceWith(this.childNodes) }), this } }), S.expr.pseudos.hidden = function (e) { return !S.expr.pseudos.visible(e) }, S.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, S.ajaxSettings.xhr = function () { try { return new C.XMLHttpRequest } catch (e) { } }; var Bt = { 0: 200, 1223: 204 }, $t = S.ajaxSettings.xhr(); y.cors = !!$t && "withCredentials" in $t, y.ajax = $t = !!$t, S.ajaxTransport(function (i) { var o, a; if (y.cors || $t && !i.crossDomain) return { send: function (e, t) { var n, r = i.xhr(); if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields) for (n in i.xhrFields) r[n] = i.xhrFields[n]; for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]); o = function (e) { return function () { o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Bt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? { binary: r.response } : { text: r.responseText }, r.getAllResponseHeaders())) } }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function () { 4 === r.readyState && C.setTimeout(function () { o && a() }) }, o = o("abort"); try { r.send(i.hasContent && i.data || null) } catch (e) { if (o) throw e } }, abort: function () { o && o() } } }), S.ajaxPrefilter(function (e) { e.crossDomain && (e.contents.script = !1) }), S.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (e) { return S.globalEval(e), e } } }), S.ajaxPrefilter("script", function (e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") }), S.ajaxTransport("script", function (n) { var r, i; if (n.crossDomain || n.scriptAttrs) return { send: function (e, t) { r = S("<script>").attr(n.scriptAttrs || {}).prop({ charset: n.scriptCharset, src: n.url }).on("load error", i = function (e) { r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type) }), E.head.appendChild(r[0]) }, abort: function () { i && i() } } }); var _t, zt = [], Ut = /(=)\?(?=&|$)|\?\?/; S.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = zt.pop() || S.expando + "_" + wt.guid++; return this[e] = !0, e } }), S.ajaxPrefilter("json jsonp", function (e, t, n) { var r, i, o, a = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data"); if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Ut, "$1" + r) : !1 !== e.jsonp && (e.url += (Tt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () { return o || S.error(r + " was not called"), o[0] }, e.dataTypes[0] = "json", i = C[r], C[r] = function () { o = arguments }, n.always(function () { void 0 === i ? S(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, zt.push(r)), o && m(i) && i(o[0]), o = i = void 0 }), "script" }), y.createHTMLDocument = ((_t = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === _t.childNodes.length), S.parseHTML = function (e, t, n) { return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ? [t.createElement(i[1])] : (i = xe([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes))); var r, i, o }, S.fn.load = function (e, t, n) { var r, i, o, a = this, s = e.indexOf(" "); return -1 < s && (r = ht(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && S.ajax({ url: e, type: i || "GET", dataType: "html", data: t }).done(function (e) { o = arguments, a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e) }).always(n && function (e, t) { a.each(function () { n.apply(this, o || [e.responseText, t, e]) }) }), this }, S.expr.pseudos.animated = function (t) { return S.grep(S.timers, function (e) { return t === e.elem }).length }, S.offset = { setOffset: function (e, t, n) { var r, i, o, a, s, u, l = S.css(e, "position"), c = S(e), f = {}; "static" === l && (e.style.position = "relative"), s = c.offset(), o = S.css(e, "top"), u = S.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f) } }, S.fn.extend({ offset: function (t) { if (arguments.length) return void 0 === t ? this : this.each(function (e) { S.offset.setOffset(this, t, e) }); var e, n, r = this[0]; return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: e.top + n.pageYOffset, left: e.left + n.pageXOffset }) : { top: 0, left: 0 } : void 0 }, position: function () { if (this[0]) { var e, t, n, r = this[0], i = { top: 0, left: 0 }; if ("fixed" === S.css(r, "position")) t = r.getBoundingClientRect(); else { t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position")) e = e.parentNode; e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0)) } return { top: t.top - i.top - S.css(r, "marginTop", !0), left: t.left - i.left - S.css(r, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { var e = this.offsetParent; while (e && "static" === S.css(e, "position")) e = e.offsetParent; return e || re }) } }), S.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (t, i) { var o = "pageYOffset" === i; S.fn[t] = function (e) { return $(this, function (e, t, n) { var r; if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t]; r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n }, t, e, arguments.length) } }), S.each(["top", "left"], function (e, n) { S.cssHooks[n] = Fe(y.pixelPosition, function (e, t) { if (t) return t = We(e, n), Pe.test(t) ? S(e).position()[n] + "px" : t }) }), S.each({ Height: "height", Width: "width" }, function (a, s) { S.each({ padding: "inner" + a, content: s, "": "outer" + a }, function (r, o) { S.fn[o] = function (e, t) { var n = arguments.length && (r || "boolean" != typeof e), i = r || (!0 === e || !0 === t ? "margin" : "border"); return $(this, function (e, t, n) { var r; return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i) }, s, n ? e : void 0, n) } }) }), S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) { S.fn[t] = function (e) { return this.on(t, e) } }), S.fn.extend({ bind: function (e, t, n) { return this.on(e, null, t, n) }, unbind: function (e, t) { return this.off(e, null, t) }, delegate: function (e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function (e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) }, hover: function (e, t) { return this.mouseenter(e).mouseleave(t || e) } }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, n) { S.fn[n] = function (e, t) { return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n) } }); var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; S.proxy = function (e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function () { return e.apply(t || this, r.concat(s.call(arguments))) }).guid = e.guid = e.guid || S.guid++, i }, S.holdReady = function (e) { e ? S.readyWait++ : S.ready(!0) }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (e) { var t = S.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, S.trim = function (e) { return null == e ? "" : (e + "").replace(Xt, "") }, "function" == typeof define && define.amd && define("jquery", [], function () { return S }); var Vt = C.jQuery, Gt = C.$; return S.noConflict = function (e) { return C.$ === S && (C.$ = Gt), e && C.jQuery === S && (C.jQuery = Vt), S }, "undefined" == typeof e && (C.jQuery = C.$ = S), S });
    </script>
    <script type="text/javascript">
        (() => {
            var rw = Object.create; var Qr = Object.defineProperty; var iw = Object.getOwnPropertyDescriptor; var sw = Object.getOwnPropertyNames; var nw = Object.getPrototypeOf, aw = Object.prototype.hasOwnProperty; var hl = r => Qr(r, "__esModule", { value: !0 }); var Cs = r => { if (typeof require != "undefined") return require(r); throw new Error('Dynamic require of "' + r + '" is not supported') }; var C = (r, e) => () => (r && (e = r(r = 0)), e); var w = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports), de = (r, e) => { hl(r); for (var t in e) Qr(r, t, { get: e[t], enumerable: !0 }) }, ow = (r, e, t) => { if (e && typeof e == "object" || typeof e == "function") for (let i of sw(e)) !aw.call(r, i) && i !== "default" && Qr(r, i, { get: () => e[i], enumerable: !(t = iw(e, i)) || t.enumerable }); return r }, H = r => ow(hl(Qr(r != null ? rw(nw(r)) : {}, "default", r && r.__esModule && "default" in r ? { get: () => r.default, enumerable: !0 } : { value: r, enumerable: !0 })), r); var m, l = C(() => { m = { platform: "", env: {}, versions: { node: "14.17.6" } } }); var lw, xe, ct = C(() => { l(); lw = 0, xe = { readFileSync: r => self[r] || "", statSync: () => ({ mtimeMs: lw++ }) } }); var ml = {}; de(ml, { default: () => ie }); var ie, tt = C(() => { l(); ie = { resolve: r => r, extname: r => "." + r.split(".").pop() } }); var gl, yl = C(() => { l(); gl = { sync: r => [].concat(r) } }); var _s = w((FA, bl) => { l(); "use strict"; var wl = class { constructor(e = {}) { if (!(e.maxSize && e.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0"); this.maxSize = e.maxSize, this.onEviction = e.onEviction, this.cache = new Map, this.oldCache = new Map, this._size = 0 } _set(e, t) { if (this.cache.set(e, t), this._size++, this._size >= this.maxSize) { if (this._size = 0, typeof this.onEviction == "function") for (let [i, s] of this.oldCache.entries()) this.onEviction(i, s); this.oldCache = this.cache, this.cache = new Map } } get(e) { if (this.cache.has(e)) return this.cache.get(e); if (this.oldCache.has(e)) { let t = this.oldCache.get(e); return this.oldCache.delete(e), this._set(e, t), t } } set(e, t) { return this.cache.has(e) ? this.cache.set(e, t) : this._set(e, t), this } has(e) { return this.cache.has(e) || this.oldCache.has(e) } peek(e) { if (this.cache.has(e)) return this.cache.get(e); if (this.oldCache.has(e)) return this.oldCache.get(e) } delete(e) { let t = this.cache.delete(e); return t && this._size--, this.oldCache.delete(e) || t } clear() { this.cache.clear(), this.oldCache.clear(), this._size = 0 } *keys() { for (let [e] of this) yield e } *values() { for (let [, e] of this) yield e } *[Symbol.iterator]() { for (let e of this.cache) yield e; for (let e of this.oldCache) { let [t] = e; this.cache.has(t) || (yield e) } } get size() { let e = 0; for (let t of this.oldCache.keys()) this.cache.has(t) || e++; return Math.min(this._size + e, this.maxSize) } }; bl.exports = wl }); var xl, vl = C(() => { l(); xl = r => r }); var kl, Sl = C(() => { l(); kl = r => r && r._hash }); function Jr(r) { return kl(r, { ignoreUnknown: !0 }) } var Cl = C(() => { l(); Sl() }); var pt, Xr = C(() => { l(); pt = {} }); function _l(r) { let e = xe.readFileSync(r, "utf-8"), t = pt(e); return { file: r, requires: t } } function As(r) { let t = [_l(r)]; for (let i of t) i.requires.filter(s => s.startsWith("./") || s.startsWith("../")).forEach(s => { try { let n = ie.dirname(i.file), a = pt.sync(s, { basedir: n }), o = _l(a); t.push(o) } catch (n) { } }); return t } var Al = C(() => { l(); ct(); tt(); Xr(); Xr() }); function rt(r) { if (r = `${r}`, r === "0") return "0"; if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(r)) return r.replace(/^[+-]?/, e => e === "-" ? "" : "-"); if (r.includes("var(") || r.includes("calc(")) return `calc(${r} * -1)` } var Kr = C(() => { l() }); var Ol, El = C(() => { l(); Ol = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"] }); function Tl(r, e) { return r === void 0 ? e : Array.isArray(r) ? r : [...new Set(e.filter(i => r !== !1 && r[i] !== !1).concat(Object.keys(r).filter(i => r[i] !== !1)))] } var Pl = C(() => { l() }); var Ht = w((KA, Dl) => { l(); Dl.exports = { content: [], presets: [], darkMode: "media", theme: { screens: { sm: "640px", md: "768px", lg: "1024px", xl: "1280px", "2xl": "1536px" }, colors: ({ colors: r }) => ({ inherit: r.inherit, current: r.current, transparent: r.transparent, black: r.black, white: r.white, slate: r.slate, gray: r.gray, zinc: r.zinc, neutral: r.neutral, stone: r.stone, red: r.red, orange: r.orange, amber: r.amber, yellow: r.yellow, lime: r.lime, green: r.green, emerald: r.emerald, teal: r.teal, cyan: r.cyan, sky: r.sky, blue: r.blue, indigo: r.indigo, violet: r.violet, purple: r.purple, fuchsia: r.fuchsia, pink: r.pink, rose: r.rose }), columns: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem" }, spacing: { px: "1px", 0: "0px", .5: "0.125rem", 1: "0.25rem", 1.5: "0.375rem", 2: "0.5rem", 2.5: "0.625rem", 3: "0.75rem", 3.5: "0.875rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem", 11: "2.75rem", 12: "3rem", 14: "3.5rem", 16: "4rem", 20: "5rem", 24: "6rem", 28: "7rem", 32: "8rem", 36: "9rem", 40: "10rem", 44: "11rem", 48: "12rem", 52: "13rem", 56: "14rem", 60: "15rem", 64: "16rem", 72: "18rem", 80: "20rem", 96: "24rem" }, animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite", pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite", bounce: "bounce 1s infinite" }, aspectRatio: { auto: "auto", square: "1 / 1", video: "16 / 9" }, backdropBlur: ({ theme: r }) => r("blur"), backdropBrightness: ({ theme: r }) => r("brightness"), backdropContrast: ({ theme: r }) => r("contrast"), backdropGrayscale: ({ theme: r }) => r("grayscale"), backdropHueRotate: ({ theme: r }) => r("hueRotate"), backdropInvert: ({ theme: r }) => r("invert"), backdropOpacity: ({ theme: r }) => r("opacity"), backdropSaturate: ({ theme: r }) => r("saturate"), backdropSepia: ({ theme: r }) => r("sepia"), backgroundColor: ({ theme: r }) => r("colors"), backgroundImage: { none: "none", "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))", "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))", "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))", "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))", "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))", "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))", "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))", "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))" }, backgroundOpacity: ({ theme: r }) => r("opacity"), backgroundPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { 0: "0", none: "0", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, brightness: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5", 200: "2" }, borderColor: ({ theme: r }) => ({ ...r("colors"), DEFAULT: r("colors.gray.200", "currentColor") }), borderOpacity: ({ theme: r }) => r("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", full: "9999px" }, borderSpacing: ({ theme: r }) => ({ ...r("spacing") }), borderWidth: { DEFAULT: "1px", 0: "0px", 2: "2px", 4: "4px", 8: "8px" }, boxShadow: { sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)", DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)", md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)", lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)", xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)", "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)", inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)", none: "none" }, boxShadowColor: ({ theme: r }) => r("colors"), caretColor: ({ theme: r }) => r("colors"), accentColor: ({ theme: r }) => ({ ...r("colors"), auto: "auto" }), contrast: { 0: "0", 50: ".5", 75: ".75", 100: "1", 125: "1.25", 150: "1.5", 200: "2" }, container: {}, content: { none: "none" }, cursor: { auto: "auto", default: "default", pointer: "pointer", wait: "wait", text: "text", move: "move", help: "help", "not-allowed": "not-allowed", none: "none", "context-menu": "context-menu", progress: "progress", cell: "cell", crosshair: "crosshair", "vertical-text": "vertical-text", alias: "alias", copy: "copy", "no-drop": "no-drop", grab: "grab", grabbing: "grabbing", "all-scroll": "all-scroll", "col-resize": "col-resize", "row-resize": "row-resize", "n-resize": "n-resize", "e-resize": "e-resize", "s-resize": "s-resize", "w-resize": "w-resize", "ne-resize": "ne-resize", "nw-resize": "nw-resize", "se-resize": "se-resize", "sw-resize": "sw-resize", "ew-resize": "ew-resize", "ns-resize": "ns-resize", "nesw-resize": "nesw-resize", "nwse-resize": "nwse-resize", "zoom-in": "zoom-in", "zoom-out": "zoom-out" }, divideColor: ({ theme: r }) => r("borderColor"), divideOpacity: ({ theme: r }) => r("borderOpacity"), divideWidth: ({ theme: r }) => r("borderWidth"), dropShadow: { sm: "0 1px 1px rgb(0 0 0 / 0.05)", DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"], md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"], lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"], xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"], "2xl": "0 25px 25px rgb(0 0 0 / 0.15)", none: "0 0 #0000" }, fill: ({ theme: r }) => r("colors"), grayscale: { 0: "0", DEFAULT: "100%" }, hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg" }, invert: { 0: "0", DEFAULT: "100%" }, flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: r }) => ({ auto: "auto", ...r("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%" }), flexGrow: { 0: "0", DEFAULT: "1" }, flexShrink: { 0: "0", DEFAULT: "1" }, fontFamily: { sans: ["ui-sans-serif", "system-ui", "-apple-system", "BlinkMacSystemFont", '"Segoe UI"', "Roboto", '"Helvetica Neue"', "Arial", '"Noto Sans"', "sans-serif", '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'], serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"], mono: ["ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", '"Liberation Mono"', '"Courier New"', "monospace"] }, fontSize: { xs: ["0.75rem", { lineHeight: "1rem" }], sm: ["0.875rem", { lineHeight: "1.25rem" }], base: ["1rem", { lineHeight: "1.5rem" }], lg: ["1.125rem", { lineHeight: "1.75rem" }], xl: ["1.25rem", { lineHeight: "1.75rem" }], "2xl": ["1.5rem", { lineHeight: "2rem" }], "3xl": ["1.875rem", { lineHeight: "2.25rem" }], "4xl": ["2.25rem", { lineHeight: "2.5rem" }], "5xl": ["3rem", { lineHeight: "1" }], "6xl": ["3.75rem", { lineHeight: "1" }], "7xl": ["4.5rem", { lineHeight: "1" }], "8xl": ["6rem", { lineHeight: "1" }], "9xl": ["8rem", { lineHeight: "1" }] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: ({ theme: r }) => r("spacing"), gradientColorStops: ({ theme: r }) => r("colors"), gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridColumn: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridColumnEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridColumnStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridRow: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-full": "1 / -1" }, gridRowStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridRowEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridTemplateColumns: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))" }, gridTemplateRows: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))" }, height: ({ theme: r }) => ({ auto: "auto", ...r("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), inset: ({ theme: r }) => ({ auto: "auto", ...r("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), keyframes: { spin: { to: { transform: "rotate(360deg)" } }, ping: { "75%, 100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2", 3: ".75rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem" }, listStyleType: { none: "none", disc: "disc", decimal: "decimal" }, margin: ({ theme: r }) => ({ auto: "auto", ...r("spacing") }), maxHeight: ({ theme: r }) => ({ ...r("spacing"), full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), maxWidth: ({ theme: r, breakpoints: e }) => ({ none: "none", 0: "0rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch", ...e(r("screens")) }), minHeight: { 0: "0px", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }, minWidth: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }, objectPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, opacity: { 0: "0", 5: "0.05", 10: "0.1", 20: "0.2", 25: "0.25", 30: "0.3", 40: "0.4", 50: "0.5", 60: "0.6", 70: "0.7", 75: "0.75", 80: "0.8", 90: "0.9", 95: "0.95", 100: "1" }, order: { first: "-9999", last: "9999", none: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12" }, padding: ({ theme: r }) => r("spacing"), placeholderColor: ({ theme: r }) => r("colors"), placeholderOpacity: ({ theme: r }) => r("opacity"), outlineColor: ({ theme: r }) => r("colors"), outlineOffset: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, outlineWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, ringColor: ({ theme: r }) => ({ DEFAULT: r("colors.blue.500", "#3b82f6"), ...r("colors") }), ringOffsetColor: ({ theme: r }) => r("colors"), ringOffsetWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, ringOpacity: ({ theme: r }) => ({ DEFAULT: "0.5", ...r("opacity") }), ringWidth: { DEFAULT: "3px", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, rotate: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg", 45: "45deg", 90: "90deg", 180: "180deg" }, saturate: { 0: "0", 50: ".5", 100: "1", 150: "1.5", 200: "2" }, scale: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5" }, scrollMargin: ({ theme: r }) => ({ ...r("spacing") }), scrollPadding: ({ theme: r }) => r("spacing"), sepia: { 0: "0", DEFAULT: "100%" }, skew: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg" }, space: ({ theme: r }) => ({ ...r("spacing") }), stroke: ({ theme: r }) => r("colors"), strokeWidth: { 0: "0", 1: "1", 2: "2" }, textColor: ({ theme: r }) => r("colors"), textDecorationColor: ({ theme: r }) => r("colors"), textDecorationThickness: { auto: "auto", "from-font": "from-font", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, textUnderlineOffset: { auto: "auto", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, textIndent: ({ theme: r }) => ({ ...r("spacing") }), textOpacity: ({ theme: r }) => r("opacity"), transformOrigin: { center: "center", top: "top", "top-right": "top right", right: "right", "bottom-right": "bottom right", bottom: "bottom", "bottom-left": "bottom left", left: "left", "top-left": "top left" }, transitionDelay: { 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionDuration: { DEFAULT: "150ms", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionProperty: { none: "none", all: "all", DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter", colors: "color, background-color, border-color, text-decoration-color, fill, stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)", linear: "linear", in: "cubic-bezier(0.4, 0, 1, 1)", out: "cubic-bezier(0, 0, 0.2, 1)", "in-out": "cubic-bezier(0.4, 0, 0.2, 1)" }, translate: ({ theme: r }) => ({ ...r("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), width: ({ theme: r }) => ({ auto: "auto", ...r("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", screen: "100vw", min: "min-content", max: "max-content", fit: "fit-content" }), willChange: { auto: "auto", scroll: "scroll-position", contents: "contents", transform: "transform" }, zIndex: { auto: "auto", 0: "0", 10: "10", 20: "20", 30: "30", 40: "40", 50: "50" } }, variantOrder: ["first", "last", "odd", "even", "visited", "checked", "empty", "read-only", "group-hover", "group-focus", "focus-within", "hover", "focus", "focus-visible", "active", "disabled"], plugins: [] } }); var ql = {}; de(ql, { default: () => he }); var he, Zr = C(() => { l(); he = new Proxy({}, { get: () => String }) }); function Os(r, e, t) { typeof m != "undefined" && m.env.JEST_WORKER_ID || t && Il.has(t) || (t && Il.add(t), console.warn(""), e.forEach(i => console.warn(r, "-", i))) } function Es(r) { return he.dim(r) } var Il, V, ve = C(() => { l(); Zr(); Il = new Set; V = { info(r, e) { Os(he.bold(he.cyan("info")), ...Array.isArray(r) ? [r] : [e, r]) }, warn(r, e) { Os(he.bold(he.yellow("warn")), ...Array.isArray(r) ? [r] : [e, r]) }, risk(r, e) { Os(he.bold(he.magenta("risk")), ...Array.isArray(r) ? [r] : [e, r]) } } }); var Rl = {}; de(Rl, { default: () => Ts }); function Yt({ version: r, from: e, to: t }) { V.warn(`${e}-color-renamed`, [`As of Tailwind CSS ${r}, \`${e}\` has been renamed to \`${t}\`.`, "Update your configuration file to silence this warning."]) } var Ts, Ps = C(() => { l(); ve(); Ts = { inherit: "inherit", current: "currentColor", transparent: "transparent", black: "#000", white: "#fff", slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a" }, gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827" }, zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b" }, neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717" }, stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917" }, red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d" }, orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12" }, amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f" }, yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12" }, lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314" }, green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d" }, emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b" }, teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a" }, cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63" }, sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e" }, blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a" }, indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81" }, violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95" }, purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87" }, fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75" }, pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843" }, rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337" }, get lightBlue() { return Yt({ version: "v2.2", from: "lightBlue", to: "sky" }), this.sky }, get warmGray() { return Yt({ version: "v3.0", from: "warmGray", to: "stone" }), this.stone }, get trueGray() { return Yt({ version: "v3.0", from: "trueGray", to: "neutral" }), this.neutral }, get coolGray() { return Yt({ version: "v3.0", from: "coolGray", to: "gray" }), this.gray }, get blueGray() { return Yt({ version: "v3.0", from: "blueGray", to: "slate" }), this.slate } } }); function Ds(r, ...e) { for (let t of e) { for (let i in t) r?.hasOwnProperty?.(i) || (r[i] = t[i]); for (let i of Object.getOwnPropertySymbols(t)) r?.hasOwnProperty?.(i) || (r[i] = t[i]) } return r } var Ml = C(() => { l() }); function Be(r) { if (Array.isArray(r)) return r; let e = r.split("[").length - 1, t = r.split("]").length - 1; if (e !== t) throw new Error(`Path is invalid. Has unbalanced brackets: ${r}`); return r.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean) } var ei = C(() => { l() }); function Ll(r) { (() => { if (r.purge || !r.content || !Array.isArray(r.content) && !(typeof r.content == "object" && r.content !== null)) return !1; if (Array.isArray(r.content)) return r.content.every(t => typeof t == "string" ? !0 : !(typeof t?.raw != "string" || t?.extension && typeof t?.extension != "string")); if (typeof r.content == "object" && r.content !== null) { if (Object.keys(r.content).some(t => !["files", "extract", "transform"].includes(t))) return !1; if (Array.isArray(r.content.files)) { if (!r.content.files.every(t => typeof t == "string" ? !0 : !(typeof t?.raw != "string" || t?.extension && typeof t?.extension != "string"))) return !1; if (typeof r.content.extract == "object") { for (let t of Object.values(r.content.extract)) if (typeof t != "function") return !1 } else if (!(r.content.extract === void 0 || typeof r.content.extract == "function")) return !1; if (typeof r.content.transform == "object") { for (let t of Object.values(r.content.transform)) if (typeof t != "function") return !1 } else if (!(r.content.transform === void 0 || typeof r.content.transform == "function")) return !1 } return !0 } return !1 })() || V.warn("purge-deprecation", ["The `purge`/`content` options have changed in Tailwind CSS v3.0.", "Update your configuration file to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"]), r.safelist = (() => { let { content: t, purge: i, safelist: s } = r; return Array.isArray(s) ? s : Array.isArray(t?.safelist) ? t.safelist : Array.isArray(i?.safelist) ? i.safelist : Array.isArray(i?.options?.safelist) ? i.options.safelist : [] })(), typeof r.prefix == "function" ? (V.warn("prefix-function", ["As of Tailwind CSS v3.0, `prefix` cannot be a function.", "Update `prefix` in your configuration to be a string to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"]), r.prefix = "") : r.prefix = r.prefix ?? "", r.content = { files: (() => { let { content: t, purge: i } = r; return Array.isArray(i) ? i : Array.isArray(i?.content) ? i.content : Array.isArray(t) ? t : Array.isArray(t?.content) ? t.content : Array.isArray(t?.files) ? t.files : [] })(), extract: (() => { let t = (() => r.purge?.extract ? r.purge.extract : r.content?.extract ? r.content.extract : r.purge?.extract?.DEFAULT ? r.purge.extract.DEFAULT : r.content?.extract?.DEFAULT ? r.content.extract.DEFAULT : r.purge?.options?.extractors ? r.purge.options.extractors : r.content?.options?.extractors ? r.content.options.extractors : {})(), i = {}, s = (() => { if (r.purge?.options?.defaultExtractor) return r.purge.options.defaultExtractor; if (r.content?.options?.defaultExtractor) return r.content.options.defaultExtractor })(); if (s !== void 0 && (i.DEFAULT = s), typeof t == "function") i.DEFAULT = t; else if (Array.isArray(t)) for (let { extensions: n, extractor: a } of t ?? []) for (let o of n) i[o] = a; else typeof t == "object" && t !== null && Object.assign(i, t); return i })(), transform: (() => { let t = (() => r.purge?.transform ? r.purge.transform : r.content?.transform ? r.content.transform : r.purge?.transform?.DEFAULT ? r.purge.transform.DEFAULT : r.content?.transform?.DEFAULT ? r.content.transform.DEFAULT : {})(), i = {}; return typeof t == "function" && (i.DEFAULT = t), typeof t == "object" && t !== null && Object.assign(i, t), i })() }; for (let t of r.content.files) if (typeof t == "string" && /{([^,]*?)}/g.test(t)) { V.warn("invalid-glob-braces", [`The glob pattern ${Es(t)} in your Tailwind CSS configuration is invalid.`, `Update it to ${Es(t.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`]); break } return r } var Nl = C(() => { l(); ve() }); function Pe(r) { if (Object.prototype.toString.call(r) !== "[object Object]") return !1; let e = Object.getPrototypeOf(r); return e === null || e === Object.prototype } var Qt = C(() => { l() }); function ze(r) { return Array.isArray(r) ? r.map(e => ze(e)) : typeof r == "object" && r !== null ? Object.fromEntries(Object.entries(r).map(([e, t]) => [e, ze(t)])) : r } var ti = C(() => { l() }); var ii = w((ri, Fl) => { l(); "use strict"; ri.__esModule = !0; ri.default = cw; function uw(r) { for (var e = r.toLowerCase(), t = "", i = !1, s = 0; s < 6 && e[s] !== void 0; s++) { var n = e.charCodeAt(s), a = n >= 97 && n <= 102 || n >= 48 && n <= 57; if (i = n === 32, !a) break; t += e[s] } if (t.length !== 0) { var o = parseInt(t, 16), u = o >= 55296 && o <= 57343; return u || o === 0 || o > 1114111 ? ["\uFFFD", t.length + (i ? 1 : 0)] : [String.fromCodePoint(o), t.length + (i ? 1 : 0)] } } var fw = /\\/; function cw(r) { var e = fw.test(r); if (!e) return r; for (var t = "", i = 0; i < r.length; i++) { if (r[i] === "\\") { var s = uw(r.slice(i + 1, i + 7)); if (s !== void 0) { t += s[0], i += s[1]; continue } if (r[i + 1] === "\\") { t += "\\", i++; continue } r.length === i + 1 && (t += r[i]); continue } t += r[i] } return t } Fl.exports = ri.default }); var zl = w((si, Bl) => { l(); "use strict"; si.__esModule = !0; si.default = pw; function pw(r) { for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)t[i - 1] = arguments[i]; for (; t.length > 0;) { var s = t.shift(); if (!r[s]) return; r = r[s] } return r } Bl.exports = si.default }); var jl = w((ni, $l) => { l(); "use strict"; ni.__esModule = !0; ni.default = dw; function dw(r) { for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)t[i - 1] = arguments[i]; for (; t.length > 0;) { var s = t.shift(); r[s] || (r[s] = {}), r = r[s] } } $l.exports = ni.default }); var Vl = w((ai, Ul) => { l(); "use strict"; ai.__esModule = !0; ai.default = hw; function hw(r) { for (var e = "", t = r.indexOf("/*"), i = 0; t >= 0;) { e = e + r.slice(i, t); var s = r.indexOf("*/", t + 2); if (s < 0) return e; i = s + 2, t = r.indexOf("/*", i) } return e = e + r.slice(i), e } Ul.exports = ai.default }); var Jt = w(ke => { l(); "use strict"; ke.__esModule = !0; ke.stripComments = ke.ensureObject = ke.getProp = ke.unesc = void 0; var mw = oi(ii()); ke.unesc = mw.default; var gw = oi(zl()); ke.getProp = gw.default; var yw = oi(jl()); ke.ensureObject = yw.default; var ww = oi(Vl()); ke.stripComments = ww.default; function oi(r) { return r && r.__esModule ? r : { default: r } } }); var De = w((Xt, Hl) => { l(); "use strict"; Xt.__esModule = !0; Xt.default = void 0; var Wl = Jt(); function Gl(r, e) { for (var t = 0; t < e.length; t++) { var i = e[t]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, i.key, i) } } function bw(r, e, t) { return e && Gl(r.prototype, e), t && Gl(r, t), r } var xw = function r(e, t) { if (typeof e != "object" || e === null) return e; var i = new e.constructor; for (var s in e) if (!!e.hasOwnProperty(s)) { var n = e[s], a = typeof n; s === "parent" && a === "object" ? t && (i[s] = t) : n instanceof Array ? i[s] = n.map(function (o) { return r(o, i) }) : i[s] = r(n, i) } return i }, vw = function () { function r(t) { t === void 0 && (t = {}), Object.assign(this, t), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "" } var e = r.prototype; return e.remove = function () { return this.parent && this.parent.removeChild(this), this.parent = void 0, this }, e.replaceWith = function () { if (this.parent) { for (var i in arguments) this.parent.insertBefore(this, arguments[i]); this.remove() } return this }, e.next = function () { return this.parent.at(this.parent.index(this) + 1) }, e.prev = function () { return this.parent.at(this.parent.index(this) - 1) }, e.clone = function (i) { i === void 0 && (i = {}); var s = xw(this); for (var n in i) s[n] = i[n]; return s }, e.appendToPropertyAndEscape = function (i, s, n) { this.raws || (this.raws = {}); var a = this[i], o = this.raws[i]; this[i] = a + s, o || n !== s ? this.raws[i] = (o || a) + n : delete this.raws[i] }, e.setPropertyAndEscape = function (i, s, n) { this.raws || (this.raws = {}), this[i] = s, this.raws[i] = n }, e.setPropertyWithoutEscape = function (i, s) { this[i] = s, this.raws && delete this.raws[i] }, e.isAtPosition = function (i, s) { if (this.source && this.source.start && this.source.end) return !(this.source.start.line > i || this.source.end.line < i || this.source.start.line === i && this.source.start.column > s || this.source.end.line === i && this.source.end.column < s) }, e.stringifyProperty = function (i) { return this.raws && this.raws[i] || this[i] }, e.valueToString = function () { return String(this.stringifyProperty("value")) }, e.toString = function () { return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("") }, bw(r, [{ key: "rawSpaceBefore", get: function () { var i = this.raws && this.raws.spaces && this.raws.spaces.before; return i === void 0 && (i = this.spaces && this.spaces.before), i || "" }, set: function (i) { (0, Wl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = i } }, { key: "rawSpaceAfter", get: function () { var i = this.raws && this.raws.spaces && this.raws.spaces.after; return i === void 0 && (i = this.spaces.after), i || "" }, set: function (i) { (0, Wl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = i } }]), r }(); Xt.default = vw; Hl.exports = Xt.default }); var X = w(z => { l(); "use strict"; z.__esModule = !0; z.UNIVERSAL = z.ATTRIBUTE = z.CLASS = z.COMBINATOR = z.COMMENT = z.ID = z.NESTING = z.PSEUDO = z.ROOT = z.SELECTOR = z.STRING = z.TAG = void 0; var kw = "tag"; z.TAG = kw; var Sw = "string"; z.STRING = Sw; var Cw = "selector"; z.SELECTOR = Cw; var _w = "root"; z.ROOT = _w; var Aw = "pseudo"; z.PSEUDO = Aw; var Ow = "nesting"; z.NESTING = Ow; var Ew = "id"; z.ID = Ew; var Tw = "comment"; z.COMMENT = Tw; var Pw = "combinator"; z.COMBINATOR = Pw; var Dw = "class"; z.CLASS = Dw; var qw = "attribute"; z.ATTRIBUTE = qw; var Iw = "universal"; z.UNIVERSAL = Iw }); var li = w((Kt, Xl) => {
                l(); "use strict"; Kt.__esModule = !0; Kt.default = void 0; var Rw = Lw(De()), qe = Mw(X()); function Yl() { if (typeof WeakMap != "function") return null; var r = new WeakMap; return Yl = function () { return r }, r } function Mw(r) { if (r && r.__esModule) return r; if (r === null || typeof r != "object" && typeof r != "function") return { default: r }; var e = Yl(); if (e && e.has(r)) return e.get(r); var t = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var s in r) if (Object.prototype.hasOwnProperty.call(r, s)) { var n = i ? Object.getOwnPropertyDescriptor(r, s) : null; n && (n.get || n.set) ? Object.defineProperty(t, s, n) : t[s] = r[s] } return t.default = r, e && e.set(r, t), t } function Lw(r) { return r && r.__esModule ? r : { default: r } } function Nw(r, e) {
                    var t; if (typeof Symbol == "undefined" || r[Symbol.iterator] == null) {
                        if (Array.isArray(r) || (t = Fw(r)) || e && r && typeof r.length == "number") { t && (r = t); var i = 0; return function () { return i >= r.length ? { done: !0 } : { done: !1, value: r[i++] } } } throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                    } return t = r[Symbol.iterator](), t.next.bind(t)
                } function Fw(r, e) { if (!!r) { if (typeof r == "string") return Ql(r, e); var t = Object.prototype.toString.call(r).slice(8, -1); if (t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set") return Array.from(r); if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return Ql(r, e) } } function Ql(r, e) { (e == null || e > r.length) && (e = r.length); for (var t = 0, i = new Array(e); t < e; t++)i[t] = r[t]; return i } function Jl(r, e) { for (var t = 0; t < e.length; t++) { var i = e[t]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, i.key, i) } } function Bw(r, e, t) { return e && Jl(r.prototype, e), t && Jl(r, t), r } function zw(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, qs(r, e) } function qs(r, e) { return qs = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, qs(r, e) } var $w = function (r) { zw(e, r); function e(i) { var s; return s = r.call(this, i) || this, s.nodes || (s.nodes = []), s } var t = e.prototype; return t.append = function (s) { return s.parent = this, this.nodes.push(s), this }, t.prepend = function (s) { return s.parent = this, this.nodes.unshift(s), this }, t.at = function (s) { return this.nodes[s] }, t.index = function (s) { return typeof s == "number" ? s : this.nodes.indexOf(s) }, t.removeChild = function (s) { s = this.index(s), this.at(s).parent = void 0, this.nodes.splice(s, 1); var n; for (var a in this.indexes) n = this.indexes[a], n >= s && (this.indexes[a] = n - 1); return this }, t.removeAll = function () { for (var s = Nw(this.nodes), n; !(n = s()).done;) { var a = n.value; a.parent = void 0 } return this.nodes = [], this }, t.empty = function () { return this.removeAll() }, t.insertAfter = function (s, n) { n.parent = this; var a = this.index(s); this.nodes.splice(a + 1, 0, n), n.parent = this; var o; for (var u in this.indexes) o = this.indexes[u], a <= o && (this.indexes[u] = o + 1); return this }, t.insertBefore = function (s, n) { n.parent = this; var a = this.index(s); this.nodes.splice(a, 0, n), n.parent = this; var o; for (var u in this.indexes) o = this.indexes[u], o <= a && (this.indexes[u] = o + 1); return this }, t._findChildAtPosition = function (s, n) { var a = void 0; return this.each(function (o) { if (o.atPosition) { var u = o.atPosition(s, n); if (u) return a = u, !1 } else if (o.isAtPosition(s, n)) return a = o, !1 }), a }, t.atPosition = function (s, n) { if (this.isAtPosition(s, n)) return this._findChildAtPosition(s, n) || this }, t._inferEndPosition = function () { this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end)) }, t.each = function (s) { this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++; var n = this.lastEach; if (this.indexes[n] = 0, !!this.length) { for (var a, o; this.indexes[n] < this.length && (a = this.indexes[n], o = s(this.at(a), a), o !== !1);)this.indexes[n] += 1; if (delete this.indexes[n], o === !1) return !1 } }, t.walk = function (s) { return this.each(function (n, a) { var o = s(n, a); if (o !== !1 && n.length && (o = n.walk(s)), o === !1) return !1 }) }, t.walkAttributes = function (s) { var n = this; return this.walk(function (a) { if (a.type === qe.ATTRIBUTE) return s.call(n, a) }) }, t.walkClasses = function (s) { var n = this; return this.walk(function (a) { if (a.type === qe.CLASS) return s.call(n, a) }) }, t.walkCombinators = function (s) { var n = this; return this.walk(function (a) { if (a.type === qe.COMBINATOR) return s.call(n, a) }) }, t.walkComments = function (s) { var n = this; return this.walk(function (a) { if (a.type === qe.COMMENT) return s.call(n, a) }) }, t.walkIds = function (s) { var n = this; return this.walk(function (a) { if (a.type === qe.ID) return s.call(n, a) }) }, t.walkNesting = function (s) { var n = this; return this.walk(function (a) { if (a.type === qe.NESTING) return s.call(n, a) }) }, t.walkPseudos = function (s) { var n = this; return this.walk(function (a) { if (a.type === qe.PSEUDO) return s.call(n, a) }) }, t.walkTags = function (s) { var n = this; return this.walk(function (a) { if (a.type === qe.TAG) return s.call(n, a) }) }, t.walkUniversals = function (s) { var n = this; return this.walk(function (a) { if (a.type === qe.UNIVERSAL) return s.call(n, a) }) }, t.split = function (s) { var n = this, a = []; return this.reduce(function (o, u, f) { var c = s.call(n, u); return a.push(u), c ? (o.push(a), a = []) : f === n.length - 1 && o.push(a), o }, []) }, t.map = function (s) { return this.nodes.map(s) }, t.reduce = function (s, n) { return this.nodes.reduce(s, n) }, t.every = function (s) { return this.nodes.every(s) }, t.some = function (s) { return this.nodes.some(s) }, t.filter = function (s) { return this.nodes.filter(s) }, t.sort = function (s) { return this.nodes.sort(s) }, t.toString = function () { return this.map(String).join("") }, Bw(e, [{ key: "first", get: function () { return this.at(0) } }, { key: "last", get: function () { return this.at(this.length - 1) } }, { key: "length", get: function () { return this.nodes.length } }]), e }(Rw.default); Kt.default = $w; Xl.exports = Kt.default
            }); var Rs = w((Zt, Zl) => { l(); "use strict"; Zt.__esModule = !0; Zt.default = void 0; var jw = Vw(li()), Uw = X(); function Vw(r) { return r && r.__esModule ? r : { default: r } } function Kl(r, e) { for (var t = 0; t < e.length; t++) { var i = e[t]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, i.key, i) } } function Ww(r, e, t) { return e && Kl(r.prototype, e), t && Kl(r, t), r } function Gw(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Is(r, e) } function Is(r, e) { return Is = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, Is(r, e) } var Hw = function (r) { Gw(e, r); function e(i) { var s; return s = r.call(this, i) || this, s.type = Uw.ROOT, s } var t = e.prototype; return t.toString = function () { var s = this.reduce(function (n, a) { return n.push(String(a)), n }, []).join(","); return this.trailingComma ? s + "," : s }, t.error = function (s, n) { return this._error ? this._error(s, n) : new Error(s) }, Ww(e, [{ key: "errorGenerator", set: function (s) { this._error = s } }]), e }(jw.default); Zt.default = Hw; Zl.exports = Zt.default }); var Ls = w((er, eu) => { l(); "use strict"; er.__esModule = !0; er.default = void 0; var Yw = Jw(li()), Qw = X(); function Jw(r) { return r && r.__esModule ? r : { default: r } } function Xw(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Ms(r, e) } function Ms(r, e) { return Ms = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, Ms(r, e) } var Kw = function (r) { Xw(e, r); function e(t) { var i; return i = r.call(this, t) || this, i.type = Qw.SELECTOR, i } return e }(Yw.default); er.default = Kw; eu.exports = er.default }); var ui = w((fO, tu) => { l(); "use strict"; var Zw = {}, eb = Zw.hasOwnProperty, tb = function (e, t) { if (!e) return t; var i = {}; for (var s in t) i[s] = eb.call(e, s) ? e[s] : t[s]; return i }, rb = /[ -,\.\/:-@\[-\^`\{-~]/, ib = /[ -,\.\/:-@\[\]\^`\{-~]/, sb = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, Ns = function r(e, t) { t = tb(t, r.options), t.quotes != "single" && t.quotes != "double" && (t.quotes = "single"); for (var i = t.quotes == "double" ? '"' : "'", s = t.isIdentifier, n = e.charAt(0), a = "", o = 0, u = e.length; o < u;) { var f = e.charAt(o++), c = f.charCodeAt(), h = void 0; if (c < 32 || c > 126) { if (c >= 55296 && c <= 56319 && o < u) { var p = e.charCodeAt(o++); (p & 64512) == 56320 ? c = ((c & 1023) << 10) + (p & 1023) + 65536 : o-- } h = "\\" + c.toString(16).toUpperCase() + " " } else t.escapeEverything ? rb.test(f) ? h = "\\" + f : h = "\\" + c.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(f) ? h = "\\" + c.toString(16).toUpperCase() + " " : f == "\\" || !s && (f == '"' && i == f || f == "'" && i == f) || s && ib.test(f) ? h = "\\" + f : h = f; a += h } return s && (/^-[-\d]/.test(a) ? a = "\\-" + a.slice(1) : /\d/.test(n) && (a = "\\3" + n + " " + a.slice(1))), a = a.replace(sb, function (d, y, v) { return y && y.length % 2 ? d : (y || "") + v }), !s && t.wrap ? i + a + i : a }; Ns.options = { escapeEverything: !1, isIdentifier: !1, quotes: "single", wrap: !1 }; Ns.version = "3.0.0"; tu.exports = Ns }); var Bs = w((tr, su) => { l(); "use strict"; tr.__esModule = !0; tr.default = void 0; var nb = ru(ui()), ab = Jt(), ob = ru(De()), lb = X(); function ru(r) { return r && r.__esModule ? r : { default: r } } function iu(r, e) { for (var t = 0; t < e.length; t++) { var i = e[t]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, i.key, i) } } function ub(r, e, t) { return e && iu(r.prototype, e), t && iu(r, t), r } function fb(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Fs(r, e) } function Fs(r, e) { return Fs = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, Fs(r, e) } var cb = function (r) { fb(e, r); function e(i) { var s; return s = r.call(this, i) || this, s.type = lb.CLASS, s._constructed = !0, s } var t = e.prototype; return t.valueToString = function () { return "." + r.prototype.valueToString.call(this) }, ub(e, [{ key: "value", get: function () { return this._value }, set: function (s) { if (this._constructed) { var n = (0, nb.default)(s, { isIdentifier: !0 }); n !== s ? ((0, ab.ensureObject)(this, "raws"), this.raws.value = n) : this.raws && delete this.raws.value } this._value = s } }]), e }(ob.default); tr.default = cb; su.exports = tr.default }); var $s = w((rr, nu) => { l(); "use strict"; rr.__esModule = !0; rr.default = void 0; var pb = hb(De()), db = X(); function hb(r) { return r && r.__esModule ? r : { default: r } } function mb(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, zs(r, e) } function zs(r, e) { return zs = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, zs(r, e) } var gb = function (r) { mb(e, r); function e(t) { var i; return i = r.call(this, t) || this, i.type = db.COMMENT, i } return e }(pb.default); rr.default = gb; nu.exports = rr.default }); var Us = w((ir, au) => { l(); "use strict"; ir.__esModule = !0; ir.default = void 0; var yb = bb(De()), wb = X(); function bb(r) { return r && r.__esModule ? r : { default: r } } function xb(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, js(r, e) } function js(r, e) { return js = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, js(r, e) } var vb = function (r) { xb(e, r); function e(i) { var s; return s = r.call(this, i) || this, s.type = wb.ID, s } var t = e.prototype; return t.valueToString = function () { return "#" + r.prototype.valueToString.call(this) }, e }(yb.default); ir.default = vb; au.exports = ir.default }); var fi = w((sr, uu) => { l(); "use strict"; sr.__esModule = !0; sr.default = void 0; var kb = ou(ui()), Sb = Jt(), Cb = ou(De()); function ou(r) { return r && r.__esModule ? r : { default: r } } function lu(r, e) { for (var t = 0; t < e.length; t++) { var i = e[t]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, i.key, i) } } function _b(r, e, t) { return e && lu(r.prototype, e), t && lu(r, t), r } function Ab(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Vs(r, e) } function Vs(r, e) { return Vs = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, Vs(r, e) } var Ob = function (r) { Ab(e, r); function e() { return r.apply(this, arguments) || this } var t = e.prototype; return t.qualifiedName = function (s) { return this.namespace ? this.namespaceString + "|" + s : s }, t.valueToString = function () { return this.qualifiedName(r.prototype.valueToString.call(this)) }, _b(e, [{ key: "namespace", get: function () { return this._namespace }, set: function (s) { if (s === !0 || s === "*" || s === "&") { this._namespace = s, this.raws && delete this.raws.namespace; return } var n = (0, kb.default)(s, { isIdentifier: !0 }); this._namespace = s, n !== s ? ((0, Sb.ensureObject)(this, "raws"), this.raws.namespace = n) : this.raws && delete this.raws.namespace } }, { key: "ns", get: function () { return this._namespace }, set: function (s) { this.namespace = s } }, { key: "namespaceString", get: function () { if (this.namespace) { var s = this.stringifyProperty("namespace"); return s === !0 ? "" : s } else return "" } }]), e }(Cb.default); sr.default = Ob; uu.exports = sr.default }); var Gs = w((nr, fu) => { l(); "use strict"; nr.__esModule = !0; nr.default = void 0; var Eb = Pb(fi()), Tb = X(); function Pb(r) { return r && r.__esModule ? r : { default: r } } function Db(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Ws(r, e) } function Ws(r, e) { return Ws = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, Ws(r, e) } var qb = function (r) { Db(e, r); function e(t) { var i; return i = r.call(this, t) || this, i.type = Tb.TAG, i } return e }(Eb.default); nr.default = qb; fu.exports = nr.default }); var Ys = w((ar, cu) => { l(); "use strict"; ar.__esModule = !0; ar.default = void 0; var Ib = Mb(De()), Rb = X(); function Mb(r) { return r && r.__esModule ? r : { default: r } } function Lb(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Hs(r, e) } function Hs(r, e) { return Hs = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, Hs(r, e) } var Nb = function (r) { Lb(e, r); function e(t) { var i; return i = r.call(this, t) || this, i.type = Rb.STRING, i } return e }(Ib.default); ar.default = Nb; cu.exports = ar.default }); var Js = w((or, pu) => { l(); "use strict"; or.__esModule = !0; or.default = void 0; var Fb = zb(li()), Bb = X(); function zb(r) { return r && r.__esModule ? r : { default: r } } function $b(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Qs(r, e) } function Qs(r, e) { return Qs = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, Qs(r, e) } var jb = function (r) { $b(e, r); function e(i) { var s; return s = r.call(this, i) || this, s.type = Bb.PSEUDO, s } var t = e.prototype; return t.toString = function () { var s = this.length ? "(" + this.map(String).join(",") + ")" : ""; return [this.rawSpaceBefore, this.stringifyProperty("value"), s, this.rawSpaceAfter].join("") }, e }(Fb.default); or.default = jb; pu.exports = or.default }); var du = {}; de(du, { deprecate: () => Ub }); function Ub(r) { return r } var hu = C(() => { l() }); var gu = w((cO, mu) => { l(); mu.exports = (hu(), du).deprecate }); var rn = w(fr => { l(); "use strict"; fr.__esModule = !0; fr.unescapeValue = en; fr.default = void 0; var lr = Ks(ui()), Vb = Ks(ii()), Wb = Ks(fi()), Gb = X(), Xs; function Ks(r) { return r && r.__esModule ? r : { default: r } } function yu(r, e) { for (var t = 0; t < e.length; t++) { var i = e[t]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, i.key, i) } } function Hb(r, e, t) { return e && yu(r.prototype, e), t && yu(r, t), r } function Yb(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Zs(r, e) } function Zs(r, e) { return Zs = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, Zs(r, e) } var ur = gu(), Qb = /^('|")([^]*)\1$/, Jb = ur(function () { }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), Xb = ur(function () { }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), Kb = ur(function () { }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now."); function en(r) { var e = !1, t = null, i = r, s = i.match(Qb); return s && (t = s[1], i = s[2]), i = (0, Vb.default)(i), i !== r && (e = !0), { deprecatedUsage: e, unescaped: i, quoteMark: t } } function Zb(r) { if (r.quoteMark !== void 0 || r.value === void 0) return r; Kb(); var e = en(r.value), t = e.quoteMark, i = e.unescaped; return r.raws || (r.raws = {}), r.raws.value === void 0 && (r.raws.value = r.value), r.value = i, r.quoteMark = t, r } var ci = function (r) { Yb(e, r); function e(i) { var s; return i === void 0 && (i = {}), s = r.call(this, Zb(i)) || this, s.type = Gb.ATTRIBUTE, s.raws = s.raws || {}, Object.defineProperty(s.raws, "unquoted", { get: ur(function () { return s.value }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: ur(function () { return s.value }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), s._constructed = !0, s } var t = e.prototype; return t.getQuotedValue = function (s) { s === void 0 && (s = {}); var n = this._determineQuoteMark(s), a = tn[n], o = (0, lr.default)(this._value, a); return o }, t._determineQuoteMark = function (s) { return s.smart ? this.smartQuoteMark(s) : this.preferredQuoteMark(s) }, t.setValue = function (s, n) { n === void 0 && (n = {}), this._value = s, this._quoteMark = this._determineQuoteMark(n), this._syncRawValue() }, t.smartQuoteMark = function (s) { var n = this.value, a = n.replace(/[^']/g, "").length, o = n.replace(/[^"]/g, "").length; if (a + o === 0) { var u = (0, lr.default)(n, { isIdentifier: !0 }); if (u === n) return e.NO_QUOTE; var f = this.preferredQuoteMark(s); if (f === e.NO_QUOTE) { var c = this.quoteMark || s.quoteMark || e.DOUBLE_QUOTE, h = tn[c], p = (0, lr.default)(n, h); if (p.length < u.length) return c } return f } else return o === a ? this.preferredQuoteMark(s) : o < a ? e.DOUBLE_QUOTE : e.SINGLE_QUOTE }, t.preferredQuoteMark = function (s) { var n = s.preferCurrentQuoteMark ? this.quoteMark : s.quoteMark; return n === void 0 && (n = s.preferCurrentQuoteMark ? s.quoteMark : this.quoteMark), n === void 0 && (n = e.DOUBLE_QUOTE), n }, t._syncRawValue = function () { var s = (0, lr.default)(this._value, tn[this.quoteMark]); s === this._value ? this.raws && delete this.raws.value : this.raws.value = s }, t._handleEscapes = function (s, n) { if (this._constructed) { var a = (0, lr.default)(n, { isIdentifier: !0 }); a !== n ? this.raws[s] = a : delete this.raws[s] } }, t._spacesFor = function (s) { var n = { before: "", after: "" }, a = this.spaces[s] || {}, o = this.raws.spaces && this.raws.spaces[s] || {}; return Object.assign(n, a, o) }, t._stringFor = function (s, n, a) { n === void 0 && (n = s), a === void 0 && (a = wu); var o = this._spacesFor(n); return a(this.stringifyProperty(s), o) }, t.offsetOf = function (s) { var n = 1, a = this._spacesFor("attribute"); if (n += a.before.length, s === "namespace" || s === "ns") return this.namespace ? n : -1; if (s === "attributeNS" || (n += this.namespaceString.length, this.namespace && (n += 1), s === "attribute")) return n; n += this.stringifyProperty("attribute").length, n += a.after.length; var o = this._spacesFor("operator"); n += o.before.length; var u = this.stringifyProperty("operator"); if (s === "operator") return u ? n : -1; n += u.length, n += o.after.length; var f = this._spacesFor("value"); n += f.before.length; var c = this.stringifyProperty("value"); if (s === "value") return c ? n : -1; n += c.length, n += f.after.length; var h = this._spacesFor("insensitive"); return n += h.before.length, s === "insensitive" && this.insensitive ? n : -1 }, t.toString = function () { var s = this, n = [this.rawSpaceBefore, "["]; return n.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (n.push(this._stringFor("operator")), n.push(this._stringFor("value")), n.push(this._stringFor("insensitiveFlag", "insensitive", function (a, o) { return a.length > 0 && !s.quoted && o.before.length === 0 && !(s.spaces.value && s.spaces.value.after) && (o.before = " "), wu(a, o) }))), n.push("]"), n.push(this.rawSpaceAfter), n.join("") }, Hb(e, [{ key: "quoted", get: function () { var s = this.quoteMark; return s === "'" || s === '"' }, set: function (s) { Xb() } }, { key: "quoteMark", get: function () { return this._quoteMark }, set: function (s) { if (!this._constructed) { this._quoteMark = s; return } this._quoteMark !== s && (this._quoteMark = s, this._syncRawValue()) } }, { key: "qualifiedAttribute", get: function () { return this.qualifiedName(this.raws.attribute || this.attribute) } }, { key: "insensitiveFlag", get: function () { return this.insensitive ? "i" : "" } }, { key: "value", get: function () { return this._value }, set: function (s) { if (this._constructed) { var n = en(s), a = n.deprecatedUsage, o = n.unescaped, u = n.quoteMark; if (a && Jb(), o === this._value && u === this._quoteMark) return; this._value = o, this._quoteMark = u, this._syncRawValue() } else this._value = s } }, { key: "attribute", get: function () { return this._attribute }, set: function (s) { this._handleEscapes("attribute", s), this._attribute = s } }]), e }(Wb.default); fr.default = ci; ci.NO_QUOTE = null; ci.SINGLE_QUOTE = "'"; ci.DOUBLE_QUOTE = '"'; var tn = (Xs = { "'": { quotes: "single", wrap: !0 }, '"': { quotes: "double", wrap: !0 } }, Xs[null] = { isIdentifier: !0 }, Xs); function wu(r, e) { return "" + e.before + r + e.after } }); var nn = w((cr, bu) => { l(); "use strict"; cr.__esModule = !0; cr.default = void 0; var e0 = r0(fi()), t0 = X(); function r0(r) { return r && r.__esModule ? r : { default: r } } function i0(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, sn(r, e) } function sn(r, e) { return sn = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, sn(r, e) } var s0 = function (r) { i0(e, r); function e(t) { var i; return i = r.call(this, t) || this, i.type = t0.UNIVERSAL, i.value = "*", i } return e }(e0.default); cr.default = s0; bu.exports = cr.default }); var on = w((pr, xu) => { l(); "use strict"; pr.__esModule = !0; pr.default = void 0; var n0 = o0(De()), a0 = X(); function o0(r) { return r && r.__esModule ? r : { default: r } } function l0(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, an(r, e) } function an(r, e) { return an = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, an(r, e) } var u0 = function (r) { l0(e, r); function e(t) { var i; return i = r.call(this, t) || this, i.type = a0.COMBINATOR, i } return e }(n0.default); pr.default = u0; xu.exports = pr.default }); var un = w((dr, vu) => { l(); "use strict"; dr.__esModule = !0; dr.default = void 0; var f0 = p0(De()), c0 = X(); function p0(r) { return r && r.__esModule ? r : { default: r } } function d0(r, e) { r.prototype = Object.create(e.prototype), r.prototype.constructor = r, ln(r, e) } function ln(r, e) { return ln = Object.setPrototypeOf || function (i, s) { return i.__proto__ = s, i }, ln(r, e) } var h0 = function (r) { d0(e, r); function e(t) { var i; return i = r.call(this, t) || this, i.type = c0.NESTING, i.value = "&", i } return e }(f0.default); dr.default = h0; vu.exports = dr.default }); var Su = w((pi, ku) => { l(); "use strict"; pi.__esModule = !0; pi.default = m0; function m0(r) { return r.sort(function (e, t) { return e - t }) } ku.exports = pi.default }); var fn = w(E => { l(); "use strict"; E.__esModule = !0; E.combinator = E.word = E.comment = E.str = E.tab = E.newline = E.feed = E.cr = E.backslash = E.bang = E.slash = E.doubleQuote = E.singleQuote = E.space = E.greaterThan = E.pipe = E.equals = E.plus = E.caret = E.tilde = E.dollar = E.closeSquare = E.openSquare = E.closeParenthesis = E.openParenthesis = E.semicolon = E.colon = E.comma = E.at = E.asterisk = E.ampersand = void 0; var g0 = 38; E.ampersand = g0; var y0 = 42; E.asterisk = y0; var w0 = 64; E.at = w0; var b0 = 44; E.comma = b0; var x0 = 58; E.colon = x0; var v0 = 59; E.semicolon = v0; var k0 = 40; E.openParenthesis = k0; var S0 = 41; E.closeParenthesis = S0; var C0 = 91; E.openSquare = C0; var _0 = 93; E.closeSquare = _0; var A0 = 36; E.dollar = A0; var O0 = 126; E.tilde = O0; var E0 = 94; E.caret = E0; var T0 = 43; E.plus = T0; var P0 = 61; E.equals = P0; var D0 = 124; E.pipe = D0; var q0 = 62; E.greaterThan = q0; var I0 = 32; E.space = I0; var Cu = 39; E.singleQuote = Cu; var R0 = 34; E.doubleQuote = R0; var M0 = 47; E.slash = M0; var L0 = 33; E.bang = L0; var N0 = 92; E.backslash = N0; var F0 = 13; E.cr = F0; var B0 = 12; E.feed = B0; var z0 = 10; E.newline = z0; var $0 = 9; E.tab = $0; var j0 = Cu; E.str = j0; var U0 = -1; E.comment = U0; var V0 = -2; E.word = V0; var W0 = -3; E.combinator = W0 }); var Ou = w(hr => {
                l(); "use strict"; hr.__esModule = !0; hr.default = K0; hr.FIELDS = void 0; var _ = G0(fn()), dt, B; function _u() { if (typeof WeakMap != "function") return null; var r = new WeakMap; return _u = function () { return r }, r } function G0(r) { if (r && r.__esModule) return r; if (r === null || typeof r != "object" && typeof r != "function") return { default: r }; var e = _u(); if (e && e.has(r)) return e.get(r); var t = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var s in r) if (Object.prototype.hasOwnProperty.call(r, s)) { var n = i ? Object.getOwnPropertyDescriptor(r, s) : null; n && (n.get || n.set) ? Object.defineProperty(t, s, n) : t[s] = r[s] } return t.default = r, e && e.set(r, t), t } var H0 = (dt = {}, dt[_.tab] = !0, dt[_.newline] = !0, dt[_.cr] = !0, dt[_.feed] = !0, dt), Y0 = (B = {}, B[_.space] = !0, B[_.tab] = !0, B[_.newline] = !0, B[_.cr] = !0, B[_.feed] = !0, B[_.ampersand] = !0, B[_.asterisk] = !0, B[_.bang] = !0, B[_.comma] = !0, B[_.colon] = !0, B[_.semicolon] = !0, B[_.openParenthesis] = !0, B[_.closeParenthesis] = !0, B[_.openSquare] = !0, B[_.closeSquare] = !0, B[_.singleQuote] = !0, B[_.doubleQuote] = !0, B[_.plus] = !0, B[_.pipe] = !0, B[_.tilde] = !0, B[_.greaterThan] = !0, B[_.equals] = !0, B[_.dollar] = !0, B[_.caret] = !0, B[_.slash] = !0, B), cn = {}, Au = "0123456789abcdefABCDEF"; for (di = 0; di < Au.length; di++)cn[Au.charCodeAt(di)] = !0; var di; function Q0(r, e) { var t = e, i; do { if (i = r.charCodeAt(t), Y0[i]) return t - 1; i === _.backslash ? t = J0(r, t) + 1 : t++ } while (t < r.length); return t - 1 } function J0(r, e) { var t = e, i = r.charCodeAt(t + 1); if (!H0[i]) if (cn[i]) { var s = 0; do t++, s++, i = r.charCodeAt(t + 1); while (cn[i] && s < 6); s < 6 && i === _.space && t++ } else t++; return t } var X0 = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 }; hr.FIELDS = X0; function K0(r) {
                    var e = [], t = r.css.valueOf(), i = t, s = i.length, n = -1, a = 1, o = 0, u = 0, f, c, h, p, d, y, v, b, x, k, T, P, R; function Y(L, I) { if (r.safe) t += I, x = t.length - 1; else throw r.error("Unclosed " + L, a, o - n, o) } for (; o < s;) {
                        switch (f = t.charCodeAt(o), f === _.newline && (n = o, a += 1), f) {
                            case _.space: case _.tab: case _.newline: case _.cr: case _.feed: x = o; do x += 1, f = t.charCodeAt(x), f === _.newline && (n = x, a += 1); while (f === _.space || f === _.newline || f === _.tab || f === _.cr || f === _.feed); R = _.space, p = a, h = x - n - 1, u = x; break; case _.plus: case _.greaterThan: case _.tilde: case _.pipe: x = o; do x += 1, f = t.charCodeAt(x); while (f === _.plus || f === _.greaterThan || f === _.tilde || f === _.pipe); R = _.combinator, p = a, h = o - n, u = x; break; case _.asterisk: case _.ampersand: case _.bang: case _.comma: case _.equals: case _.dollar: case _.caret: case _.openSquare: case _.closeSquare: case _.colon: case _.semicolon: case _.openParenthesis: case _.closeParenthesis: x = o, R = f, p = a, h = o - n, u = x + 1; break; case _.singleQuote: case _.doubleQuote: P = f === _.singleQuote ? "'" : '"', x = o; do for (d = !1, x = t.indexOf(P, x + 1), x === -1 && Y("quote", P), y = x; t.charCodeAt(y - 1) === _.backslash;)y -= 1, d = !d; while (d); R = _.str, p = a, h = o - n, u = x + 1; break; default: f === _.slash && t.charCodeAt(o + 1) === _.asterisk ? (x = t.indexOf("*/", o + 2) + 1, x === 0 && Y("comment", "*/"), c = t.slice(o, x + 1), b = c.split(`
`), v = b.length - 1, v > 0 ? (k = a + v, T = x - b[v].length) : (k = a, T = n), R = _.comment, a = k, p = k, h = x - T) : f === _.slash ? (x = o, R = f, p = a, h = o - n, u = x + 1) : (x = Q0(t, o), R = _.word, p = a, h = x - n), u = x + 1; break
                        }e.push([R, a, o - n, p, h, o, u]), T && (n = T, T = null), o = u
                    } return e
                }
            }); var Mu = w((mr, Ru) => { l(); "use strict"; mr.__esModule = !0; mr.default = void 0; var Z0 = se(Rs()), pn = se(Ls()), ex = se(Bs()), Eu = se($s()), tx = se(Us()), rx = se(Gs()), dn = se(Ys()), ix = se(Js()), Tu = hi(rn()), sx = se(nn()), hn = se(on()), nx = se(un()), ax = se(Su()), S = hi(Ou()), A = hi(fn()), ox = hi(X()), W = Jt(), it, mn; function Pu() { if (typeof WeakMap != "function") return null; var r = new WeakMap; return Pu = function () { return r }, r } function hi(r) { if (r && r.__esModule) return r; if (r === null || typeof r != "object" && typeof r != "function") return { default: r }; var e = Pu(); if (e && e.has(r)) return e.get(r); var t = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var s in r) if (Object.prototype.hasOwnProperty.call(r, s)) { var n = i ? Object.getOwnPropertyDescriptor(r, s) : null; n && (n.get || n.set) ? Object.defineProperty(t, s, n) : t[s] = r[s] } return t.default = r, e && e.set(r, t), t } function se(r) { return r && r.__esModule ? r : { default: r } } function Du(r, e) { for (var t = 0; t < e.length; t++) { var i = e[t]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, i.key, i) } } function lx(r, e, t) { return e && Du(r.prototype, e), t && Du(r, t), r } var gn = (it = {}, it[A.space] = !0, it[A.cr] = !0, it[A.feed] = !0, it[A.newline] = !0, it[A.tab] = !0, it), ux = Object.assign({}, gn, (mn = {}, mn[A.comment] = !0, mn)); function qu(r) { return { line: r[S.FIELDS.START_LINE], column: r[S.FIELDS.START_COL] } } function Iu(r) { return { line: r[S.FIELDS.END_LINE], column: r[S.FIELDS.END_COL] } } function st(r, e, t, i) { return { start: { line: r, column: e }, end: { line: t, column: i } } } function ht(r) { return st(r[S.FIELDS.START_LINE], r[S.FIELDS.START_COL], r[S.FIELDS.END_LINE], r[S.FIELDS.END_COL]) } function yn(r, e) { if (!!r) return st(r[S.FIELDS.START_LINE], r[S.FIELDS.START_COL], e[S.FIELDS.END_LINE], e[S.FIELDS.END_COL]) } function mt(r, e) { var t = r[e]; if (typeof t == "string") return t.indexOf("\\") !== -1 && ((0, W.ensureObject)(r, "raws"), r[e] = (0, W.unesc)(t), r.raws[e] === void 0 && (r.raws[e] = t)), r } function wn(r, e) { for (var t = -1, i = []; (t = r.indexOf(e, t + 1)) !== -1;)i.push(t); return i } function fx() { var r = Array.prototype.concat.apply([], arguments); return r.filter(function (e, t) { return t === r.indexOf(e) }) } var cx = function () { function r(t, i) { i === void 0 && (i = {}), this.rule = t, this.options = Object.assign({ lossy: !1, safe: !1 }, i), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, S.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe }); var s = yn(this.tokens[0], this.tokens[this.tokens.length - 1]); this.root = new Z0.default({ source: s }), this.root.errorGenerator = this._errorGenerator(); var n = new pn.default({ source: { start: { line: 1, column: 1 } } }); this.root.append(n), this.current = n, this.loop() } var e = r.prototype; return e._errorGenerator = function () { var i = this; return function (s, n) { return typeof i.rule == "string" ? new Error(s) : i.rule.error(s, n) } }, e.attribute = function () { var i = [], s = this.currToken; for (this.position++; this.position < this.tokens.length && this.currToken[S.FIELDS.TYPE] !== A.closeSquare;)i.push(this.currToken), this.position++; if (this.currToken[S.FIELDS.TYPE] !== A.closeSquare) return this.expected("closing square bracket", this.currToken[S.FIELDS.START_POS]); var n = i.length, a = { source: st(s[1], s[2], this.currToken[3], this.currToken[4]), sourceIndex: s[S.FIELDS.START_POS] }; if (n === 1 && !~[A.word].indexOf(i[0][S.FIELDS.TYPE])) return this.expected("attribute", i[0][S.FIELDS.START_POS]); for (var o = 0, u = "", f = "", c = null, h = !1; o < n;) { var p = i[o], d = this.content(p), y = i[o + 1]; switch (p[S.FIELDS.TYPE]) { case A.space: if (h = !0, this.options.lossy) break; if (c) { (0, W.ensureObject)(a, "spaces", c); var v = a.spaces[c].after || ""; a.spaces[c].after = v + d; var b = (0, W.getProp)(a, "raws", "spaces", c, "after") || null; b && (a.raws.spaces[c].after = b + d) } else u = u + d, f = f + d; break; case A.asterisk: if (y[S.FIELDS.TYPE] === A.equals) a.operator = d, c = "operator"; else if ((!a.namespace || c === "namespace" && !h) && y) { u && ((0, W.ensureObject)(a, "spaces", "attribute"), a.spaces.attribute.before = u, u = ""), f && ((0, W.ensureObject)(a, "raws", "spaces", "attribute"), a.raws.spaces.attribute.before = u, f = ""), a.namespace = (a.namespace || "") + d; var x = (0, W.getProp)(a, "raws", "namespace") || null; x && (a.raws.namespace += d), c = "namespace" } h = !1; break; case A.dollar: if (c === "value") { var k = (0, W.getProp)(a, "raws", "value"); a.value += "$", k && (a.raws.value = k + "$"); break } case A.caret: y[S.FIELDS.TYPE] === A.equals && (a.operator = d, c = "operator"), h = !1; break; case A.combinator: if (d === "~" && y[S.FIELDS.TYPE] === A.equals && (a.operator = d, c = "operator"), d !== "|") { h = !1; break } y[S.FIELDS.TYPE] === A.equals ? (a.operator = d, c = "operator") : !a.namespace && !a.attribute && (a.namespace = !0), h = !1; break; case A.word: if (y && this.content(y) === "|" && i[o + 2] && i[o + 2][S.FIELDS.TYPE] !== A.equals && !a.operator && !a.namespace) a.namespace = d, c = "namespace"; else if (!a.attribute || c === "attribute" && !h) { u && ((0, W.ensureObject)(a, "spaces", "attribute"), a.spaces.attribute.before = u, u = ""), f && ((0, W.ensureObject)(a, "raws", "spaces", "attribute"), a.raws.spaces.attribute.before = f, f = ""), a.attribute = (a.attribute || "") + d; var T = (0, W.getProp)(a, "raws", "attribute") || null; T && (a.raws.attribute += d), c = "attribute" } else if (!a.value && a.value !== "" || c === "value" && !h) { var P = (0, W.unesc)(d), R = (0, W.getProp)(a, "raws", "value") || "", Y = a.value || ""; a.value = Y + P, a.quoteMark = null, (P !== d || R) && ((0, W.ensureObject)(a, "raws"), a.raws.value = (R || Y) + d), c = "value" } else { var L = d === "i" || d === "I"; (a.value || a.value === "") && (a.quoteMark || h) ? (a.insensitive = L, (!L || d === "I") && ((0, W.ensureObject)(a, "raws"), a.raws.insensitiveFlag = d), c = "insensitive", u && ((0, W.ensureObject)(a, "spaces", "insensitive"), a.spaces.insensitive.before = u, u = ""), f && ((0, W.ensureObject)(a, "raws", "spaces", "insensitive"), a.raws.spaces.insensitive.before = f, f = "")) : (a.value || a.value === "") && (c = "value", a.value += d, a.raws.value && (a.raws.value += d)) } h = !1; break; case A.str: if (!a.attribute || !a.operator) return this.error("Expected an attribute followed by an operator preceding the string.", { index: p[S.FIELDS.START_POS] }); var I = (0, Tu.unescapeValue)(d), Q = I.unescaped, et = I.quoteMark; a.value = Q, a.quoteMark = et, c = "value", (0, W.ensureObject)(a, "raws"), a.raws.value = d, h = !1; break; case A.equals: if (!a.attribute) return this.expected("attribute", p[S.FIELDS.START_POS], d); if (a.value) return this.error('Unexpected "=" found; an operator was already defined.', { index: p[S.FIELDS.START_POS] }); a.operator = a.operator ? a.operator + d : d, c = "operator", h = !1; break; case A.comment: if (c) if (h || y && y[S.FIELDS.TYPE] === A.space || c === "insensitive") { var Fe = (0, W.getProp)(a, "spaces", c, "after") || "", Gt = (0, W.getProp)(a, "raws", "spaces", c, "after") || Fe; (0, W.ensureObject)(a, "raws", "spaces", c), a.raws.spaces[c].after = Gt + d } else { var ew = a[c] || "", tw = (0, W.getProp)(a, "raws", c) || ew; (0, W.ensureObject)(a, "raws"), a.raws[c] = tw + d } else f = f + d; break; default: return this.error('Unexpected "' + d + '" found.', { index: p[S.FIELDS.START_POS] }) }o++ } mt(a, "attribute"), mt(a, "namespace"), this.newNode(new Tu.default(a)), this.position++ }, e.parseWhitespaceEquivalentTokens = function (i) { i < 0 && (i = this.tokens.length); var s = this.position, n = [], a = "", o = void 0; do if (gn[this.currToken[S.FIELDS.TYPE]]) this.options.lossy || (a += this.content()); else if (this.currToken[S.FIELDS.TYPE] === A.comment) { var u = {}; a && (u.before = a, a = ""), o = new Eu.default({ value: this.content(), source: ht(this.currToken), sourceIndex: this.currToken[S.FIELDS.START_POS], spaces: u }), n.push(o) } while (++this.position < i); if (a) { if (o) o.spaces.after = a; else if (!this.options.lossy) { var f = this.tokens[s], c = this.tokens[this.position - 1]; n.push(new dn.default({ value: "", source: st(f[S.FIELDS.START_LINE], f[S.FIELDS.START_COL], c[S.FIELDS.END_LINE], c[S.FIELDS.END_COL]), sourceIndex: f[S.FIELDS.START_POS], spaces: { before: a, after: "" } })) } } return n }, e.convertWhitespaceNodesToSpace = function (i, s) { var n = this; s === void 0 && (s = !1); var a = "", o = ""; i.forEach(function (f) { var c = n.lossySpace(f.spaces.before, s), h = n.lossySpace(f.rawSpaceBefore, s); a += c + n.lossySpace(f.spaces.after, s && c.length === 0), o += c + f.value + n.lossySpace(f.rawSpaceAfter, s && h.length === 0) }), o === a && (o = void 0); var u = { space: a, rawSpace: o }; return u }, e.isNamedCombinator = function (i) { return i === void 0 && (i = this.position), this.tokens[i + 0] && this.tokens[i + 0][S.FIELDS.TYPE] === A.slash && this.tokens[i + 1] && this.tokens[i + 1][S.FIELDS.TYPE] === A.word && this.tokens[i + 2] && this.tokens[i + 2][S.FIELDS.TYPE] === A.slash }, e.namedCombinator = function () { if (this.isNamedCombinator()) { var i = this.content(this.tokens[this.position + 1]), s = (0, W.unesc)(i).toLowerCase(), n = {}; s !== i && (n.value = "/" + i + "/"); var a = new hn.default({ value: "/" + s + "/", source: st(this.currToken[S.FIELDS.START_LINE], this.currToken[S.FIELDS.START_COL], this.tokens[this.position + 2][S.FIELDS.END_LINE], this.tokens[this.position + 2][S.FIELDS.END_COL]), sourceIndex: this.currToken[S.FIELDS.START_POS], raws: n }); return this.position = this.position + 3, a } else this.unexpected() }, e.combinator = function () { var i = this; if (this.content() === "|") return this.namespace(); var s = this.locateNextMeaningfulToken(this.position); if (s < 0 || this.tokens[s][S.FIELDS.TYPE] === A.comma) { var n = this.parseWhitespaceEquivalentTokens(s); if (n.length > 0) { var a = this.current.last; if (a) { var o = this.convertWhitespaceNodesToSpace(n), u = o.space, f = o.rawSpace; f !== void 0 && (a.rawSpaceAfter += f), a.spaces.after += u } else n.forEach(function (R) { return i.newNode(R) }) } return } var c = this.currToken, h = void 0; s > this.position && (h = this.parseWhitespaceEquivalentTokens(s)); var p; if (this.isNamedCombinator() ? p = this.namedCombinator() : this.currToken[S.FIELDS.TYPE] === A.combinator ? (p = new hn.default({ value: this.content(), source: ht(this.currToken), sourceIndex: this.currToken[S.FIELDS.START_POS] }), this.position++) : gn[this.currToken[S.FIELDS.TYPE]] || h || this.unexpected(), p) { if (h) { var d = this.convertWhitespaceNodesToSpace(h), y = d.space, v = d.rawSpace; p.spaces.before = y, p.rawSpaceBefore = v } } else { var b = this.convertWhitespaceNodesToSpace(h, !0), x = b.space, k = b.rawSpace; k || (k = x); var T = {}, P = { spaces: {} }; x.endsWith(" ") && k.endsWith(" ") ? (T.before = x.slice(0, x.length - 1), P.spaces.before = k.slice(0, k.length - 1)) : x.startsWith(" ") && k.startsWith(" ") ? (T.after = x.slice(1), P.spaces.after = k.slice(1)) : P.value = k, p = new hn.default({ value: " ", source: yn(c, this.tokens[this.position - 1]), sourceIndex: c[S.FIELDS.START_POS], spaces: T, raws: P }) } return this.currToken && this.currToken[S.FIELDS.TYPE] === A.space && (p.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(p) }, e.comma = function () { if (this.position === this.tokens.length - 1) { this.root.trailingComma = !0, this.position++; return } this.current._inferEndPosition(); var i = new pn.default({ source: { start: qu(this.tokens[this.position + 1]) } }); this.current.parent.append(i), this.current = i, this.position++ }, e.comment = function () { var i = this.currToken; this.newNode(new Eu.default({ value: this.content(), source: ht(i), sourceIndex: i[S.FIELDS.START_POS] })), this.position++ }, e.error = function (i, s) { throw this.root.error(i, s) }, e.missingBackslash = function () { return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[S.FIELDS.START_POS] }) }, e.missingParenthesis = function () { return this.expected("opening parenthesis", this.currToken[S.FIELDS.START_POS]) }, e.missingSquareBracket = function () { return this.expected("opening square bracket", this.currToken[S.FIELDS.START_POS]) }, e.unexpected = function () { return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[S.FIELDS.START_POS]) }, e.namespace = function () { var i = this.prevToken && this.content(this.prevToken) || !0; if (this.nextToken[S.FIELDS.TYPE] === A.word) return this.position++, this.word(i); if (this.nextToken[S.FIELDS.TYPE] === A.asterisk) return this.position++, this.universal(i) }, e.nesting = function () { if (this.nextToken) { var i = this.content(this.nextToken); if (i === "|") { this.position++; return } } var s = this.currToken; this.newNode(new nx.default({ value: this.content(), source: ht(s), sourceIndex: s[S.FIELDS.START_POS] })), this.position++ }, e.parentheses = function () { var i = this.current.last, s = 1; if (this.position++, i && i.type === ox.PSEUDO) { var n = new pn.default({ source: { start: qu(this.tokens[this.position - 1]) } }), a = this.current; for (i.append(n), this.current = n; this.position < this.tokens.length && s;)this.currToken[S.FIELDS.TYPE] === A.openParenthesis && s++, this.currToken[S.FIELDS.TYPE] === A.closeParenthesis && s--, s ? this.parse() : (this.current.source.end = Iu(this.currToken), this.current.parent.source.end = Iu(this.currToken), this.position++); this.current = a } else { for (var o = this.currToken, u = "(", f; this.position < this.tokens.length && s;)this.currToken[S.FIELDS.TYPE] === A.openParenthesis && s++, this.currToken[S.FIELDS.TYPE] === A.closeParenthesis && s--, f = this.currToken, u += this.parseParenthesisToken(this.currToken), this.position++; i ? i.appendToPropertyAndEscape("value", u, u) : this.newNode(new dn.default({ value: u, source: st(o[S.FIELDS.START_LINE], o[S.FIELDS.START_COL], f[S.FIELDS.END_LINE], f[S.FIELDS.END_COL]), sourceIndex: o[S.FIELDS.START_POS] })) } if (s) return this.expected("closing parenthesis", this.currToken[S.FIELDS.START_POS]) }, e.pseudo = function () { for (var i = this, s = "", n = this.currToken; this.currToken && this.currToken[S.FIELDS.TYPE] === A.colon;)s += this.content(), this.position++; if (!this.currToken) return this.expected(["pseudo-class", "pseudo-element"], this.position - 1); if (this.currToken[S.FIELDS.TYPE] === A.word) this.splitWord(!1, function (a, o) { s += a, i.newNode(new ix.default({ value: s, source: yn(n, i.currToken), sourceIndex: n[S.FIELDS.START_POS] })), o > 1 && i.nextToken && i.nextToken[S.FIELDS.TYPE] === A.openParenthesis && i.error("Misplaced parenthesis.", { index: i.nextToken[S.FIELDS.START_POS] }) }); else return this.expected(["pseudo-class", "pseudo-element"], this.currToken[S.FIELDS.START_POS]) }, e.space = function () { var i = this.content(); this.position === 0 || this.prevToken[S.FIELDS.TYPE] === A.comma || this.prevToken[S.FIELDS.TYPE] === A.openParenthesis || this.current.nodes.every(function (s) { return s.type === "comment" }) ? (this.spaces = this.optionalSpace(i), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[S.FIELDS.TYPE] === A.comma || this.nextToken[S.FIELDS.TYPE] === A.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(i), this.position++) : this.combinator() }, e.string = function () { var i = this.currToken; this.newNode(new dn.default({ value: this.content(), source: ht(i), sourceIndex: i[S.FIELDS.START_POS] })), this.position++ }, e.universal = function (i) { var s = this.nextToken; if (s && this.content(s) === "|") return this.position++, this.namespace(); var n = this.currToken; this.newNode(new sx.default({ value: this.content(), source: ht(n), sourceIndex: n[S.FIELDS.START_POS] }), i), this.position++ }, e.splitWord = function (i, s) { for (var n = this, a = this.nextToken, o = this.content(); a && ~[A.dollar, A.caret, A.equals, A.word].indexOf(a[S.FIELDS.TYPE]);) { this.position++; var u = this.content(); if (o += u, u.lastIndexOf("\\") === u.length - 1) { var f = this.nextToken; f && f[S.FIELDS.TYPE] === A.space && (o += this.requiredSpace(this.content(f)), this.position++) } a = this.nextToken } var c = wn(o, ".").filter(function (y) { var v = o[y - 1] === "\\", b = /^\d+\.\d+%$/.test(o); return !v && !b }), h = wn(o, "#").filter(function (y) { return o[y - 1] !== "\\" }), p = wn(o, "#{"); p.length && (h = h.filter(function (y) { return !~p.indexOf(y) })); var d = (0, ax.default)(fx([0].concat(c, h))); d.forEach(function (y, v) { var b = d[v + 1] || o.length, x = o.slice(y, b); if (v === 0 && s) return s.call(n, x, d.length); var k, T = n.currToken, P = T[S.FIELDS.START_POS] + d[v], R = st(T[1], T[2] + y, T[3], T[2] + (b - 1)); if (~c.indexOf(y)) { var Y = { value: x.slice(1), source: R, sourceIndex: P }; k = new ex.default(mt(Y, "value")) } else if (~h.indexOf(y)) { var L = { value: x.slice(1), source: R, sourceIndex: P }; k = new tx.default(mt(L, "value")) } else { var I = { value: x, source: R, sourceIndex: P }; mt(I, "value"), k = new rx.default(I) } n.newNode(k, i), i = null }), this.position++ }, e.word = function (i) { var s = this.nextToken; return s && this.content(s) === "|" ? (this.position++, this.namespace()) : this.splitWord(i) }, e.loop = function () { for (; this.position < this.tokens.length;)this.parse(!0); return this.current._inferEndPosition(), this.root }, e.parse = function (i) { switch (this.currToken[S.FIELDS.TYPE]) { case A.space: this.space(); break; case A.comment: this.comment(); break; case A.openParenthesis: this.parentheses(); break; case A.closeParenthesis: i && this.missingParenthesis(); break; case A.openSquare: this.attribute(); break; case A.dollar: case A.caret: case A.equals: case A.word: this.word(); break; case A.colon: this.pseudo(); break; case A.comma: this.comma(); break; case A.asterisk: this.universal(); break; case A.ampersand: this.nesting(); break; case A.slash: case A.combinator: this.combinator(); break; case A.str: this.string(); break; case A.closeSquare: this.missingSquareBracket(); case A.semicolon: this.missingBackslash(); default: this.unexpected() } }, e.expected = function (i, s, n) { if (Array.isArray(i)) { var a = i.pop(); i = i.join(", ") + " or " + a } var o = /^[aeiou]/.test(i[0]) ? "an" : "a"; return n ? this.error("Expected " + o + " " + i + ', found "' + n + '" instead.', { index: s }) : this.error("Expected " + o + " " + i + ".", { index: s }) }, e.requiredSpace = function (i) { return this.options.lossy ? " " : i }, e.optionalSpace = function (i) { return this.options.lossy ? "" : i }, e.lossySpace = function (i, s) { return this.options.lossy ? s ? " " : "" : i }, e.parseParenthesisToken = function (i) { var s = this.content(i); return i[S.FIELDS.TYPE] === A.space ? this.requiredSpace(s) : s }, e.newNode = function (i, s) { return s && (/^ +$/.test(s) && (this.options.lossy || (this.spaces = (this.spaces || "") + s), s = !0), i.namespace = s, mt(i, "namespace")), this.spaces && (i.spaces.before = this.spaces, this.spaces = ""), this.current.append(i) }, e.content = function (i) { return i === void 0 && (i = this.currToken), this.css.slice(i[S.FIELDS.START_POS], i[S.FIELDS.END_POS]) }, e.locateNextMeaningfulToken = function (i) { i === void 0 && (i = this.position + 1); for (var s = i; s < this.tokens.length;)if (ux[this.tokens[s][S.FIELDS.TYPE]]) { s++; continue } else return s; return -1 }, lx(r, [{ key: "currToken", get: function () { return this.tokens[this.position] } }, { key: "nextToken", get: function () { return this.tokens[this.position + 1] } }, { key: "prevToken", get: function () { return this.tokens[this.position - 1] } }]), r }(); mr.default = cx; Ru.exports = mr.default }); var Nu = w((gr, Lu) => { l(); "use strict"; gr.__esModule = !0; gr.default = void 0; var px = dx(Mu()); function dx(r) { return r && r.__esModule ? r : { default: r } } var hx = function () { function r(t, i) { this.func = t || function () { }, this.funcRes = null, this.options = i } var e = r.prototype; return e._shouldUpdateSelector = function (i, s) { s === void 0 && (s = {}); var n = Object.assign({}, this.options, s); return n.updateSelector === !1 ? !1 : typeof i != "string" }, e._isLossy = function (i) { i === void 0 && (i = {}); var s = Object.assign({}, this.options, i); return s.lossless === !1 }, e._root = function (i, s) { s === void 0 && (s = {}); var n = new px.default(i, this._parseOptions(s)); return n.root }, e._parseOptions = function (i) { return { lossy: this._isLossy(i) } }, e._run = function (i, s) { var n = this; return s === void 0 && (s = {}), new Promise(function (a, o) { try { var u = n._root(i, s); Promise.resolve(n.func(u)).then(function (f) { var c = void 0; return n._shouldUpdateSelector(i, s) && (c = u.toString(), i.selector = c), { transform: f, root: u, string: c } }).then(a, o) } catch (f) { o(f); return } }) }, e._runSync = function (i, s) { s === void 0 && (s = {}); var n = this._root(i, s), a = this.func(n); if (a && typeof a.then == "function") throw new Error("Selector processor returned a promise to a synchronous call."); var o = void 0; return s.updateSelector && typeof i != "string" && (o = n.toString(), i.selector = o), { transform: a, root: n, string: o } }, e.ast = function (i, s) { return this._run(i, s).then(function (n) { return n.root }) }, e.astSync = function (i, s) { return this._runSync(i, s).root }, e.transform = function (i, s) { return this._run(i, s).then(function (n) { return n.transform }) }, e.transformSync = function (i, s) { return this._runSync(i, s).transform }, e.process = function (i, s) { return this._run(i, s).then(function (n) { return n.string || n.root.toString() }) }, e.processSync = function (i, s) { var n = this._runSync(i, s); return n.string || n.root.toString() }, r }(); gr.default = hx; Lu.exports = gr.default }); var Fu = w($ => { l(); "use strict"; $.__esModule = !0; $.universal = $.tag = $.string = $.selector = $.root = $.pseudo = $.nesting = $.id = $.comment = $.combinator = $.className = $.attribute = void 0; var mx = ne(rn()), gx = ne(Bs()), yx = ne(on()), wx = ne($s()), bx = ne(Us()), xx = ne(un()), vx = ne(Js()), kx = ne(Rs()), Sx = ne(Ls()), Cx = ne(Ys()), _x = ne(Gs()), Ax = ne(nn()); function ne(r) { return r && r.__esModule ? r : { default: r } } var Ox = function (e) { return new mx.default(e) }; $.attribute = Ox; var Ex = function (e) { return new gx.default(e) }; $.className = Ex; var Tx = function (e) { return new yx.default(e) }; $.combinator = Tx; var Px = function (e) { return new wx.default(e) }; $.comment = Px; var Dx = function (e) { return new bx.default(e) }; $.id = Dx; var qx = function (e) { return new xx.default(e) }; $.nesting = qx; var Ix = function (e) { return new vx.default(e) }; $.pseudo = Ix; var Rx = function (e) { return new kx.default(e) }; $.root = Rx; var Mx = function (e) { return new Sx.default(e) }; $.selector = Mx; var Lx = function (e) { return new Cx.default(e) }; $.string = Lx; var Nx = function (e) { return new _x.default(e) }; $.tag = Nx; var Fx = function (e) { return new Ax.default(e) }; $.universal = Fx }); var ju = w(M => { l(); "use strict"; M.__esModule = !0; M.isNode = bn; M.isPseudoElement = $u; M.isPseudoClass = Qx; M.isContainer = Jx; M.isNamespace = Xx; M.isUniversal = M.isTag = M.isString = M.isSelector = M.isRoot = M.isPseudo = M.isNesting = M.isIdentifier = M.isComment = M.isCombinator = M.isClassName = M.isAttribute = void 0; var G = X(), ee, Bx = (ee = {}, ee[G.ATTRIBUTE] = !0, ee[G.CLASS] = !0, ee[G.COMBINATOR] = !0, ee[G.COMMENT] = !0, ee[G.ID] = !0, ee[G.NESTING] = !0, ee[G.PSEUDO] = !0, ee[G.ROOT] = !0, ee[G.SELECTOR] = !0, ee[G.STRING] = !0, ee[G.TAG] = !0, ee[G.UNIVERSAL] = !0, ee); function bn(r) { return typeof r == "object" && Bx[r.type] } function ae(r, e) { return bn(e) && e.type === r } var Bu = ae.bind(null, G.ATTRIBUTE); M.isAttribute = Bu; var zx = ae.bind(null, G.CLASS); M.isClassName = zx; var $x = ae.bind(null, G.COMBINATOR); M.isCombinator = $x; var jx = ae.bind(null, G.COMMENT); M.isComment = jx; var Ux = ae.bind(null, G.ID); M.isIdentifier = Ux; var Vx = ae.bind(null, G.NESTING); M.isNesting = Vx; var xn = ae.bind(null, G.PSEUDO); M.isPseudo = xn; var Wx = ae.bind(null, G.ROOT); M.isRoot = Wx; var Gx = ae.bind(null, G.SELECTOR); M.isSelector = Gx; var Hx = ae.bind(null, G.STRING); M.isString = Hx; var zu = ae.bind(null, G.TAG); M.isTag = zu; var Yx = ae.bind(null, G.UNIVERSAL); M.isUniversal = Yx; function $u(r) { return xn(r) && r.value && (r.value.startsWith("::") || r.value.toLowerCase() === ":before" || r.value.toLowerCase() === ":after" || r.value.toLowerCase() === ":first-letter" || r.value.toLowerCase() === ":first-line") } function Qx(r) { return xn(r) && !$u(r) } function Jx(r) { return !!(bn(r) && r.walk) } function Xx(r) { return Bu(r) || zu(r) } }); var Uu = w(me => { l(); "use strict"; me.__esModule = !0; var vn = X(); Object.keys(vn).forEach(function (r) { r === "default" || r === "__esModule" || r in me && me[r] === vn[r] || (me[r] = vn[r]) }); var kn = Fu(); Object.keys(kn).forEach(function (r) { r === "default" || r === "__esModule" || r in me && me[r] === kn[r] || (me[r] = kn[r]) }); var Sn = ju(); Object.keys(Sn).forEach(function (r) { r === "default" || r === "__esModule" || r in me && me[r] === Sn[r] || (me[r] = Sn[r]) }) }); var Se = w((yr, Wu) => { l(); "use strict"; yr.__esModule = !0; yr.default = void 0; var Kx = tv(Nu()), Zx = ev(Uu()); function Vu() { if (typeof WeakMap != "function") return null; var r = new WeakMap; return Vu = function () { return r }, r } function ev(r) { if (r && r.__esModule) return r; if (r === null || typeof r != "object" && typeof r != "function") return { default: r }; var e = Vu(); if (e && e.has(r)) return e.get(r); var t = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var s in r) if (Object.prototype.hasOwnProperty.call(r, s)) { var n = i ? Object.getOwnPropertyDescriptor(r, s) : null; n && (n.get || n.set) ? Object.defineProperty(t, s, n) : t[s] = r[s] } return t.default = r, e && e.set(r, t), t } function tv(r) { return r && r.__esModule ? r : { default: r } } var Cn = function (e) { return new Kx.default(e) }; Object.assign(Cn, Zx); delete Cn.__esModule; var rv = Cn; yr.default = rv; Wu.exports = yr.default }); function nt(r) { return r.replace(/\\,/g, "\\2c ") } var mi = C(() => { l() }); var Hu = w((bO, Gu) => { l(); "use strict"; Gu.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] } }); function wr(r, { loose: e = !1 } = {}) { if (typeof r != "string") return null; if (r = r.trim(), r === "transparent") return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" }; if (r in _n.default) return { mode: "rgb", color: _n.default[r].map(n => n.toString()) }; let t = r.replace(sv, (n, a, o, u, f) => ["#", a, a, o, o, u, u, f ? f + f : ""].join("")).match(iv); if (t !== null) return { mode: "rgb", color: [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)].map(n => n.toString()), alpha: t[4] ? (parseInt(t[4], 16) / 255).toString() : void 0 }; let i = r.match(nv) ?? r.match(av); if (i === null) return null; let s = [i[2], i[3], i[4]].filter(Boolean).map(n => n.toString()); return !e && s.length !== 3 || s.length < 3 && !s.some(n => /^var\(.*?\)$/.test(n)) ? null : { mode: i[1], color: s, alpha: i[5]?.toString?.() } } function An({ mode: r, color: e, alpha: t }) { let i = t !== void 0; return `${r}(${e.join(" ")}${i ? ` / ${t}` : ""})` } var _n, iv, sv, $e, gi, Yu, je, nv, av, On = C(() => { l(); _n = H(Hu()), iv = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, sv = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, $e = /(?:\d+|\d*\.\d+)%?/, gi = /(?:\s*,\s*|\s+)/, Yu = /\s*[,/]\s*/, je = /var\(--(?:[^ )]*?)\)/, nv = new RegExp(`^(rgb)a?\\(\\s*(${$e.source}|${je.source})(?:${gi.source}(${$e.source}|${je.source}))?(?:${gi.source}(${$e.source}|${je.source}))?(?:${Yu.source}(${$e.source}|${je.source}))?\\s*\\)$`), av = new RegExp(`^(hsl)a?\\(\\s*((?:${$e.source})(?:deg|rad|grad|turn)?|${je.source})(?:${gi.source}(${$e.source}|${je.source}))?(?:${gi.source}(${$e.source}|${je.source}))?(?:${Yu.source}(${$e.source}|${je.source}))?\\s*\\)$`) }); function Ce(r, e, t) { if (typeof r == "function") return r({ opacityValue: e }); let i = wr(r, { loose: !0 }); return i === null ? t : An({ ...i, alpha: e }) } function te({ color: r, property: e, variable: t }) { let i = [].concat(e); if (typeof r == "function") return { [t]: "1", ...Object.fromEntries(i.map(n => [n, r({ opacityVariable: t, opacityValue: `var(${t})` })])) }; let s = wr(r); return s === null ? Object.fromEntries(i.map(n => [n, r])) : s.alpha !== void 0 ? Object.fromEntries(i.map(n => [n, r])) : { [t]: "1", ...Object.fromEntries(i.map(n => [n, An({ ...s, alpha: `var(${t})` })])) } } var br = C(() => { l(); On() }); function yi(r) { return r = Array.isArray(r) ? r : [r], r = r.map(e => e instanceof RegExp ? e.source : e), r.join("") } function Ue(r) { return new RegExp(yi(r), "g") } function xr(r) { return `(?:${r.map(yi).join("|")})` } function Ju(r) { return `(?:${yi(r)})?` } function Xu(r) { return `(?:${yi(r)})*` } function Ku(r) { return r && ov.test(r) ? r.replace(Qu, "\\$&") : r || "" } var Qu, ov, En = C(() => { l(); Qu = /[\\^$.*+?()[\]{}|]/g, ov = RegExp(Qu.source) }); function* vr(r, e) { let t = new RegExp(`[(){}\\[\\]${Ku(e)}]`, "g"), i = 0, s = 0, n = !1, a = 0, o = 0, u = e.length; for (let f of r.matchAll(t)) { let c = f[0] === e[a], h = a === u - 1, p = c && h; f[0] === "(" && i++, f[0] === ")" && i--, f[0] === "[" && i++, f[0] === "]" && i--, f[0] === "{" && i++, f[0] === "}" && i--, c && i === 0 && (o === 0 && (o = f.index), a++), p && i === 0 && (n = !0, yield r.substring(s, o), s = o + u), a === u && (a = 0, o = 0) } n ? yield r.substring(s) : yield r } var Tn = C(() => { l(); En() }); function wi(r) { return Array.from(vr(r, ",")).map(t => { let i = t.trim(), s = { raw: i }, n = i.split(uv), a = new Set; for (let o of n) Zu.lastIndex = 0, !a.has("KEYWORD") && lv.has(o) ? (s.keyword = o, a.add("KEYWORD")) : Zu.test(o) ? a.has("X") ? a.has("Y") ? a.has("BLUR") ? a.has("SPREAD") || (s.spread = o, a.add("SPREAD")) : (s.blur = o, a.add("BLUR")) : (s.y = o, a.add("Y")) : (s.x = o, a.add("X")) : s.color ? (s.unknown || (s.unknown = []), s.unknown.push(o)) : s.color = o; return s.valid = s.x !== void 0 && s.y !== void 0, s }) } function ef(r) { return r.map(e => e.valid ? [e.keyword, e.x, e.y, e.blur, e.spread, e.color].filter(Boolean).join(" ") : e.raw).join(", ") } var lv, uv, Zu, Pn = C(() => { l(); Tn(); lv = new Set(["inset", "inherit", "initial", "revert", "unset"]), uv = /\ +(?![^(]*\))/g, Zu = /^-?(\d+|\.\d+)(.*?)$/g }); function oe(r, e = !0) { return r.includes("url(") ? r.split(/(url\(.*?\))/g).filter(Boolean).map(t => /^url\(.*?\)$/.test(t) ? t : oe(t, !1)).join("") : (r = r.replace(/([^\\])_+/g, (t, i) => i + " ".repeat(t.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), e && (r = r.trim()), r = r.replace(/(calc|min|max|clamp)\(.+\)/g, t => t.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ")), r.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([\/])/g, "$1 $2 ")) } function qn(r) { return r.startsWith("url(") } function rf(r) { return !isNaN(Number(r)) || Dn.some(e => new RegExp(`^${e}\\(.+?`).test(r)) } function In(r) { return r.split(bi).every(e => /%$/g.test(e) || Dn.some(t => new RegExp(`^${t}\\(.+?%`).test(e))) } function Rn(r) { return r.split(bi).every(e => e === "0" || new RegExp(`${sf}$`).test(e) || Dn.some(t => new RegExp(`^${t}\\(.+?${sf}`).test(e))) } function nf(r) { return cv.has(r) } function af(r) { let e = wi(oe(r)); for (let t of e) if (!t.valid) return !1; return !0 } function of(r) { let e = 0; return r.split(bi).every(i => (i = oe(i), i.startsWith("var(") ? !0 : wr(i, { loose: !0 }) !== null ? (e++, !0) : !1)) ? e > 0 : !1 } function lf(r) { let e = 0; return r.split(tf).every(i => (i = oe(i), i.startsWith("var(") ? !0 : qn(i) || dv(i) || ["element(", "image(", "cross-fade(", "image-set("].some(s => i.startsWith(s)) ? (e++, !0) : !1)) ? e > 0 : !1 } function dv(r) { r = oe(r); for (let e of pv) if (r.startsWith(`${e}(`)) return !0; return !1 } function uf(r) { let e = 0; return r.split(bi).every(i => (i = oe(i), i.startsWith("var(") ? !0 : hv.has(i) || Rn(i) || In(i) ? (e++, !0) : !1)) ? e > 0 : !1 } function ff(r) { let e = 0; return r.split(tf).every(i => (i = oe(i), i.startsWith("var(") ? !0 : i.includes(" ") && !/(['"])([^"']+)\1/g.test(i) || /^\d/g.test(i) ? !1 : (e++, !0))) ? e > 0 : !1 } function cf(r) { return mv.has(r) } function pf(r) { return gv.has(r) } function df(r) { return yv.has(r) } var Dn, tf, bi, fv, sf, cv, pv, hv, mv, gv, yv, Mn = C(() => { l(); On(); Pn(); Dn = ["min", "max", "clamp", "calc"], tf = /,(?![^(]*\))/g, bi = /_(?![^(]*\))/g; fv = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "vw", "vh", "vmin", "vmax"], sf = `(?:${fv.join("|")})`; cv = new Set(["thin", "medium", "thick"]); pv = new Set(["linear-gradient", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "conic-gradient"]); hv = new Set(["center", "top", "right", "bottom", "left"]); mv = new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]); gv = new Set(["xx-small", "x-small", "small", "medium", "large", "x-large", "x-large", "xxx-large"]); yv = new Set(["larger", "smaller"]) }); function mf(r, e) { return (0, hf.default)(s => { s.walkClasses(n => { let a = e(n.value); n.value = a, n.raws && n.raws.value && (n.raws.value = nt(n.raws.value)) }) }).processSync(r) } function gf(r, e) { if (!kr(r)) return; let t = r.slice(1, -1); if (!!e(t)) return oe(t) } function wv(r, e = {}, t) { let i = e[r]; if (i !== void 0) return rt(i); if (kr(r)) { let s = gf(r, t); return s === void 0 ? void 0 : rt(s) } } function xi(r, e = {}, { validate: t = () => !0 } = {}) { let i = e.values?.[r]; return i !== void 0 ? i : e.supportsNegativeValues && r.startsWith("-") ? wv(r.slice(1), e.values, t) : gf(r, t) } function kr(r) { return r.startsWith("[") && r.endsWith("]") } function bv(r) { let e = r.lastIndexOf("/"); return e === -1 || e === r.length - 1 ? [r] : [r.slice(0, e), r.slice(e + 1)] } function gt(r) { if (typeof r == "string" && r.includes("<alpha-value>")) { let e = r; return ({ opacityValue: t = 1 }) => e.replace("<alpha-value>", t) } return r } function xv(r, e = {}, { tailwindConfig: t = {} } = {}) { if (e.values?.[r] !== void 0) return gt(e.values?.[r]); let [i, s] = bv(r); if (s !== void 0) { let n = e.values?.[i] ?? (kr(i) ? i.slice(1, -1) : void 0); return n === void 0 ? void 0 : (n = gt(n), kr(s) ? Ce(n, s.slice(1, -1)) : t.theme?.opacity?.[s] === void 0 ? void 0 : Ce(n, t.theme.opacity[s])) } return xi(r, e, { validate: of }) } function vv(r, e = {}) { return e.values?.[r] } function le(r) { return (e, t) => xi(e, t, { validate: r }) } function kv(r, e) { let t = r.indexOf(e); return t === -1 ? [void 0, r] : [r.slice(0, t), r.slice(t + 1)] } function Ln(r, e, t, i) { if (kr(e)) { let s = e.slice(1, -1), [n, a] = kv(s, ":"); if (!/^[\w-_]+$/g.test(n)) a = s; else if (n !== void 0 && !wf.includes(n)) return []; if (a.length > 0 && wf.includes(n)) return [xi(`[${a}]`, t), n] } for (let s of [].concat(r)) { let n = yf[s](e, t, { tailwindConfig: i }); if (n !== void 0) return [n, s] } return [] } var hf, yf, wf, Sr = C(() => { l(); hf = H(Se()); mi(); br(); Mn(); Kr(); yf = { any: xi, color: xv, url: le(qn), image: le(lf), length: le(Rn), percentage: le(In), position: le(uf), lookup: vv, "generic-name": le(cf), "family-name": le(ff), number: le(rf), "line-width": le(nf), "absolute-size": le(pf), "relative-size": le(df), shadow: le(af) }, wf = Object.keys(yf) }); function N(r) { return typeof r == "function" ? r({}) : r } var Nn = C(() => { l() }); function yt(r) { return typeof r == "function" } function Cr(r) { return typeof r == "object" && r !== null } function _r(r, ...e) { let t = e.pop(); for (let i of e) for (let s in i) { let n = t(r[s], i[s]); n === void 0 ? Cr(r[s]) && Cr(i[s]) ? r[s] = _r(r[s], i[s], t) : r[s] = i[s] : r[s] = n } return r } function Sv(r, ...e) { return yt(r) ? r(...e) : r } function Cv(r) { return r.reduce((e, { extend: t }) => _r(e, t, (i, s) => i === void 0 ? [s] : Array.isArray(i) ? [s, ...i] : [s, i]), {}) } function _v(r) { return { ...r.reduce((e, t) => Ds(e, t), {}), extend: Cv(r) } } function xf(r, e) { if (Array.isArray(r) && Cr(r[0])) return r.concat(e); if (Array.isArray(e) && Cr(e[0]) && Cr(r)) return [r, ...e]; if (Array.isArray(e)) return e } function Av({ extend: r, ...e }) { return _r(e, r, (t, i) => !yt(t) && !i.some(yt) ? _r({}, t, ...i, xf) : (s, n) => _r({}, ...[t, ...i].map(a => Sv(a, s, n)), xf)) } function* Ov(r) { let e = Be(r); if (e.length === 0 || (yield e, Array.isArray(r))) return; let t = /^(.*?)\s*\/\s*([^/]+)$/, i = r.match(t); if (i !== null) { let [, s, n] = i, a = Be(s); a.alpha = n, yield a } } function Ev(r) { let e = (t, i) => { for (let s of Ov(t)) { let n = 0, a = r; for (; a != null && n < s.length;)a = a[s[n++]], a = yt(a) && (s.alpha === void 0 || n < s.length - 1) ? a(e, Fn) : a; if (a !== void 0) { if (s.alpha !== void 0) { let o = gt(a); return Ce(o, s.alpha, N(o)) } return Pe(a) ? ze(a) : a } } return i }; return Object.assign(e, { theme: e, ...Fn }), Object.keys(r).reduce((t, i) => (t[i] = yt(r[i]) ? r[i](e, Fn) : r[i], t), {}) } function vf(r) { let e = []; return r.forEach(t => { e = [...e, t]; let i = t?.plugins ?? []; i.length !== 0 && i.forEach(s => { s.__isOptionsFunction && (s = s()), e = [...e, ...vf([s?.config ?? {}])] }) }), e } function Tv(r) { return [...r].reduceRight((t, i) => yt(i) ? i({ corePlugins: t }) : Tl(i, t), Ol) } function Pv(r) { return [...r].reduceRight((t, i) => [...t, ...i], []) } function Bn(r) { let e = [...vf(r), { prefix: "", important: !1, separator: ":", variantOrder: bf.default.variantOrder }]; return Ll(Ds({ theme: Ev(Av(_v(e.map(t => t?.theme ?? {})))), corePlugins: Tv(e.map(t => t.corePlugins)), plugins: Pv(r.map(t => t?.plugins ?? [])) }, ...e)) } var bf, Fn, kf = C(() => { l(); Kr(); El(); Pl(); bf = H(Ht()); Ps(); Ml(); ei(); Nl(); Qt(); ti(); Sr(); br(); Nn(); Fn = { colors: Ts, negative(r) { return Object.keys(r).filter(e => r[e] !== "0").reduce((e, t) => { let i = rt(r[t]); return i !== void 0 && (e[`-${t}`] = i), e }, {}) }, breakpoints(r) { return Object.keys(r).filter(e => typeof r[e] == "string").reduce((e, t) => ({ ...e, [`screen-${t}`]: r[t] }), {}) } } }); function K(r, e) { return vi.future.includes(e) ? r.future === "all" || (r?.future?.[e] ?? Sf[e] ?? !1) : vi.experimental.includes(e) ? r.experimental === "all" || (r?.experimental?.[e] ?? Sf[e] ?? !1) : !1 } function Cf(r) { return r.experimental === "all" ? vi.experimental : Object.keys(r?.experimental ?? {}).filter(e => vi.experimental.includes(e) && r.experimental[e]) } function _f(r) { if (m.env.JEST_WORKER_ID === void 0 && Cf(r).length > 0) { let e = Cf(r).map(t => he.yellow(t)).join(", "); V.warn("experimental-flags-enabled", [`You have enabled experimental features: ${e}`, "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."]) } } var Sf, vi, Ve = C(() => { l(); Zr(); ve(); Sf = { optimizeUniversalDefaults: !1 }, vi = { future: ["hoverOnlyWhenSupported", "respectDefaultRingColorOpacity"], experimental: ["optimizeUniversalDefaults", "matchVariant"] } }); function ki(r) { let e = (r?.presets ?? [Af.default]).slice().reverse().flatMap(s => ki(s instanceof Function ? s() : s)), t = { respectDefaultRingColorOpacity: { theme: { ringColor: { DEFAULT: "#3b82f67f" } } } }, i = Object.keys(t).filter(s => K(r, s)).map(s => t[s]); return [r, ...i, ...e] } var Af, Of = C(() => { l(); Af = H(Ht()); Ve() }); var Ef = {}; de(Ef, { default: () => Ar }); function Ar(...r) { let [, ...e] = ki(r[0]); return Bn([...r, ...e]) } var zn = C(() => { l(); kf(); Of() }); function Si(r) { return typeof r == "object" && r !== null } function Dv(r) { return Object.keys(r).length === 0 } function Tf(r) { return typeof r == "string" || r instanceof String } function $n(r) { if (Si(r) && r.config === void 0 && !Dv(r)) return null; if (Si(r) && r.config !== void 0 && Tf(r.config)) return ie.resolve(r.config); if (Si(r) && r.config !== void 0 && Si(r.config)) return null; if (Tf(r)) return ie.resolve(r); for (let e of ["./tailwind.config.js", "./tailwind.config.cjs"]) try { let t = ie.resolve(e); return xe.accessSync(t), t } catch (t) { } return null } var Pf = C(() => { l(); ct(); tt() }); function qv(r) { if (r === void 0) return !1; if (r === "true" || r === "1") return !0; if (r === "false" || r === "0") return !1; if (r === "*") return !0; let e = r.split(",").map(t => t.split(":")[0]); return e.includes("-tailwindcss") ? !1 : !!e.includes("tailwindcss") } var ge, Df, qf, Ci, jn, Ie, We = C(() => { l(); ge = { NODE_ENV: "production", DEBUG: qv(m.env.DEBUG) }, Df = new Map, qf = new Map, Ci = new Map, jn = new Map, Ie = new String("*") }); var If = {}; de(If, { default: () => Un }); var Un, Vn = C(() => { l(); Un = { parse: r => ({ href: r }) } }); var Wn = w(() => { l() }); var _i = w((uE, Lf) => {
                l(); "use strict"; var Rf = (Zr(), ql), Mf = Wn(), wt = class extends Error {
                    constructor(e, t, i, s, n, a) { super(e); this.name = "CssSyntaxError", this.reason = e, n && (this.file = n), s && (this.source = s), a && (this.plugin = a), typeof t != "undefined" && typeof i != "undefined" && (typeof t == "number" ? (this.line = t, this.column = i) : (this.line = t.line, this.column = t.column, this.endLine = i.line, this.endColumn = i.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, wt) } setMessage() { this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line != "undefined" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason } showSourceCode(e) {
                        if (!this.source) return ""; let t = this.source; e == null && (e = Rf.isColorSupported), Mf && e && (t = Mf(t)); let i = t.split(/\r?\n/), s = Math.max(this.line - 3, 0), n = Math.min(this.line + 2, i.length), a = String(n).length, o, u; if (e) { let { bold: f, red: c, gray: h } = Rf.createColors(!0); o = p => f(c(p)), u = p => h(p) } else o = u = f => f; return i.slice(s, n).map((f, c) => {
                            let h = s + 1 + c, p = " " + (" " + h).slice(-a) + " | "; if (h === this.line) {
                                let d = u(p.replace(/\d/g, " ")) + f.slice(0, this.column - 1).replace(/[^\t]/g, " "); return o(">") + u(p) + f + `
         `+ d + o("^")
                            } return " " + u(p) + f
                        }).join(`
`)
                    } toString() {
                        let e = this.showSourceCode(); return e && (e = `

`+ e + `
`), this.name + ": " + this.message + e
                    }
                }; Lf.exports = wt; wt.default = wt
            }); var Ai = w((fE, Gn) => { l(); "use strict"; Gn.exports.isClean = Symbol("isClean"); Gn.exports.my = Symbol("my") }); var Hn = w((cE, Ff) => {
                l(); "use strict"; var Nf = {
                    colon: ": ", indent: "    ", beforeDecl: `
`, beforeRule: `
`, beforeOpen: " ", beforeClose: `
`, beforeComment: `
`, after: `
`, emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: !1
                }; function Iv(r) { return r[0].toUpperCase() + r.slice(1) } var Oi = class {
                    constructor(e) { this.builder = e } stringify(e, t) { if (!this[e.type]) throw new Error("Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."); this[e.type](e, t) } document(e) { this.body(e) } root(e) { this.body(e), e.raws.after && this.builder(e.raws.after) } comment(e) { let t = this.raw(e, "left", "commentLeft"), i = this.raw(e, "right", "commentRight"); this.builder("/*" + t + e.text + i + "*/", e) } decl(e, t) { let i = this.raw(e, "between", "colon"), s = e.prop + i + this.rawValue(e, "value"); e.important && (s += e.raws.important || " !important"), t && (s += ";"), this.builder(s, e) } rule(e) { this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end") } atrule(e, t) { let i = "@" + e.name, s = e.params ? this.rawValue(e, "params") : ""; if (typeof e.raws.afterName != "undefined" ? i += e.raws.afterName : s && (i += " "), e.nodes) this.block(e, i + s); else { let n = (e.raws.between || "") + (t ? ";" : ""); this.builder(i + s + n, e) } } body(e) { let t = e.nodes.length - 1; for (; t > 0 && e.nodes[t].type === "comment";)t -= 1; let i = this.raw(e, "semicolon"); for (let s = 0; s < e.nodes.length; s++) { let n = e.nodes[s], a = this.raw(n, "before"); a && this.builder(a), this.stringify(n, t !== s || i) } } block(e, t) { let i = this.raw(e, "between", "beforeOpen"); this.builder(t + i + "{", e, "start"); let s; e.nodes && e.nodes.length ? (this.body(e), s = this.raw(e, "after")) : s = this.raw(e, "after", "emptyBody"), s && this.builder(s), this.builder("}", e, "end") } raw(e, t, i) { let s; if (i || (i = t), t && (s = e.raws[t], typeof s != "undefined")) return s; let n = e.parent; if (i === "before" && (!n || n.type === "root" && n.first === e || n && n.type === "document")) return ""; if (!n) return Nf[i]; let a = e.root(); if (a.rawCache || (a.rawCache = {}), typeof a.rawCache[i] != "undefined") return a.rawCache[i]; if (i === "before" || i === "after") return this.beforeAfter(e, i); { let o = "raw" + Iv(i); this[o] ? s = this[o](a, e) : a.walk(u => { if (s = u.raws[t], typeof s != "undefined") return !1 }) } return typeof s == "undefined" && (s = Nf[i]), a.rawCache[i] = s, s } rawSemicolon(e) { let t; return e.walk(i => { if (i.nodes && i.nodes.length && i.last.type === "decl" && (t = i.raws.semicolon, typeof t != "undefined")) return !1 }), t } rawEmptyBody(e) { let t; return e.walk(i => { if (i.nodes && i.nodes.length === 0 && (t = i.raws.after, typeof t != "undefined")) return !1 }), t } rawIndent(e) {
                        if (e.raws.indent) return e.raws.indent; let t; return e.walk(i => {
                            let s = i.parent; if (s && s !== e && s.parent && s.parent === e && typeof i.raws.before != "undefined") {
                                let n = i.raws.before.split(`
`); return t = n[n.length - 1], t = t.replace(/\S/g, ""), !1
                            }
                        }), t
                    } rawBeforeComment(e, t) {
                        let i; return e.walkComments(s => {
                            if (typeof s.raws.before != "undefined") return i = s.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1
                        }), typeof i == "undefined" ? i = this.raw(t, null, "beforeDecl") : i && (i = i.replace(/\S/g, "")), i
                    } rawBeforeDecl(e, t) {
                        let i; return e.walkDecls(s => {
                            if (typeof s.raws.before != "undefined") return i = s.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1
                        }), typeof i == "undefined" ? i = this.raw(t, null, "beforeRule") : i && (i = i.replace(/\S/g, "")), i
                    } rawBeforeRule(e) {
                        let t; return e.walk(i => {
                            if (i.nodes && (i.parent !== e || e.first !== i) && typeof i.raws.before != "undefined") return t = i.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1
                        }), t && (t = t.replace(/\S/g, "")), t
                    } rawBeforeClose(e) {
                        let t; return e.walk(i => {
                            if (i.nodes && i.nodes.length > 0 && typeof i.raws.after != "undefined") return t = i.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1
                        }), t && (t = t.replace(/\S/g, "")), t
                    } rawBeforeOpen(e) { let t; return e.walk(i => { if (i.type !== "decl" && (t = i.raws.between, typeof t != "undefined")) return !1 }), t } rawColon(e) { let t; return e.walkDecls(i => { if (typeof i.raws.between != "undefined") return t = i.raws.between.replace(/[^\s:]/g, ""), !1 }), t } beforeAfter(e, t) {
                        let i; e.type === "decl" ? i = this.raw(e, null, "beforeDecl") : e.type === "comment" ? i = this.raw(e, null, "beforeComment") : t === "before" ? i = this.raw(e, null, "beforeRule") : i = this.raw(e, null, "beforeClose"); let s = e.parent, n = 0; for (; s && s.type !== "root";)n += 1, s = s.parent; if (i.includes(`
`)) { let a = this.raw(e, null, "indent"); if (a.length) for (let o = 0; o < n; o++)i += a } return i
                    } rawValue(e, t) { let i = e[t], s = e.raws[t]; return s && s.value === i ? s.raw : i }
                }; Ff.exports = Oi; Oi.default = Oi
            }); var Or = w((pE, Bf) => { l(); "use strict"; var Rv = Hn(); function Yn(r, e) { new Rv(e).stringify(r) } Bf.exports = Yn; Yn.default = Yn }); var Er = w((dE, zf) => {
                l(); "use strict"; var { isClean: Ei, my: Mv } = Ai(), Lv = _i(), Nv = Hn(), Fv = Or(); function Qn(r, e) { let t = new r.constructor; for (let i in r) { if (!Object.prototype.hasOwnProperty.call(r, i) || i === "proxyCache") continue; let s = r[i], n = typeof s; i === "parent" && n === "object" ? e && (t[i] = e) : i === "source" ? t[i] = s : Array.isArray(s) ? t[i] = s.map(a => Qn(a, t)) : (n === "object" && s !== null && (s = Qn(s)), t[i] = s) } return t } var Ti = class {
                    constructor(e = {}) { this.raws = {}, this[Ei] = !1, this[Mv] = !0; for (let t in e) if (t === "nodes") { this.nodes = []; for (let i of e[t]) typeof i.clone == "function" ? this.append(i.clone()) : this.append(i) } else this[t] = e[t] } error(e, t = {}) { if (this.source) { let { start: i, end: s } = this.rangeBy(t); return this.source.input.error(e, { line: i.line, column: i.column }, { line: s.line, column: s.column }, t) } return new Lv(e) } warn(e, t, i) { let s = { node: this }; for (let n in i) s[n] = i[n]; return e.warn(t, s) } remove() { return this.parent && this.parent.removeChild(this), this.parent = void 0, this } toString(e = Fv) { e.stringify && (e = e.stringify); let t = ""; return e(this, i => { t += i }), t } assign(e = {}) { for (let t in e) this[t] = e[t]; return this } clone(e = {}) { let t = Qn(this); for (let i in e) t[i] = e[i]; return t } cloneBefore(e = {}) { let t = this.clone(e); return this.parent.insertBefore(this, t), t } cloneAfter(e = {}) { let t = this.clone(e); return this.parent.insertAfter(this, t), t } replaceWith(...e) { if (this.parent) { let t = this, i = !1; for (let s of e) s === this ? i = !0 : i ? (this.parent.insertAfter(t, s), t = s) : this.parent.insertBefore(t, s); i || this.remove() } return this } next() { if (!this.parent) return; let e = this.parent.index(this); return this.parent.nodes[e + 1] } prev() { if (!this.parent) return; let e = this.parent.index(this); return this.parent.nodes[e - 1] } before(e) { return this.parent.insertBefore(this, e), this } after(e) { return this.parent.insertAfter(this, e), this } root() { let e = this; for (; e.parent && e.parent.type !== "document";)e = e.parent; return e } raw(e, t) { return new Nv().raw(this, e, t) } cleanRaws(e) { delete this.raws.before, delete this.raws.after, e || delete this.raws.between } toJSON(e, t) { let i = {}, s = t == null; t = t || new Map; let n = 0; for (let a in this) { if (!Object.prototype.hasOwnProperty.call(this, a) || a === "parent" || a === "proxyCache") continue; let o = this[a]; if (Array.isArray(o)) i[a] = o.map(u => typeof u == "object" && u.toJSON ? u.toJSON(null, t) : u); else if (typeof o == "object" && o.toJSON) i[a] = o.toJSON(null, t); else if (a === "source") { let u = t.get(o.input); u == null && (u = n, t.set(o.input, n), n++), i[a] = { inputId: u, start: o.start, end: o.end } } else i[a] = o } return s && (i.inputs = [...t.keys()].map(a => a.toJSON())), i } positionInside(e) {
                        let t = this.toString(), i = this.source.start.column, s = this.source.start.line; for (let n = 0; n < e; n++)t[n] === `
`? (i = 1, s += 1) : i += 1; return { line: s, column: i }
                    } positionBy(e) { let t = this.source.start; if (e.index) t = this.positionInside(e.index); else if (e.word) { let i = this.toString().indexOf(e.word); i !== -1 && (t = this.positionInside(i)) } return t } rangeBy(e) { let t = { line: this.source.start.line, column: this.source.start.column }, i = this.source.end ? { line: this.source.end.line, column: this.source.end.column + 1 } : { line: t.line, column: t.column + 1 }; if (e.word) { let s = this.toString().indexOf(e.word); s !== -1 && (t = this.positionInside(s), i = this.positionInside(s + e.word.length)) } else e.start ? t = { line: e.start.line, column: e.start.column } : e.index && (t = this.positionInside(e.index)), e.end ? i = { line: e.end.line, column: e.end.column } : e.endIndex ? i = this.positionInside(e.endIndex) : e.index && (i = this.positionInside(e.index + 1)); return (i.line < t.line || i.line === t.line && i.column <= t.column) && (i = { line: t.line, column: t.column + 1 }), { start: t, end: i } } getProxyProcessor() { return { set(e, t, i) { return e[t] === i || (e[t] = i, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || t === "text") && e.markDirty()), !0 }, get(e, t) { return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t] } } } toProxy() { return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache } addToError(e) { if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) { let t = this.source; e.stack = e.stack.replace(/\n\s{4}at /, `$&${t.input.from}:${t.start.line}:${t.start.column}$&`) } return e } markDirty() { if (this[Ei]) { this[Ei] = !1; let e = this; for (; e = e.parent;)e[Ei] = !1 } } get proxyOf() { return this }
                }; zf.exports = Ti; Ti.default = Ti
            }); var Tr = w((hE, $f) => { l(); "use strict"; var Bv = Er(), Pi = class extends Bv { constructor(e) { e && typeof e.value != "undefined" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }); super(e); this.type = "decl" } get variable() { return this.prop.startsWith("--") || this.prop[0] === "$" } }; $f.exports = Pi; Pi.default = Pi }); var Jn = w((mE, jf) => { l(); jf.exports = function (r, e) { return { generate: () => { let t = ""; return r(e, i => { t += i }), [t] } } } }); var Pr = w((gE, Uf) => { l(); "use strict"; var zv = Er(), Di = class extends zv { constructor(e) { super(e); this.type = "comment" } }; Uf.exports = Di; Di.default = Di }); var Ge = w((yE, Xf) => { l(); "use strict"; var { isClean: Vf, my: Wf } = Ai(), Gf = Tr(), Hf = Pr(), $v = Er(), Yf, Xn, Kn; function Qf(r) { return r.map(e => (e.nodes && (e.nodes = Qf(e.nodes)), delete e.source, e)) } function Jf(r) { if (r[Vf] = !1, r.proxyOf.nodes) for (let e of r.proxyOf.nodes) Jf(e) } var ye = class extends $v { push(e) { return e.parent = this, this.proxyOf.nodes.push(e), this } each(e) { if (!this.proxyOf.nodes) return; let t = this.getIterator(), i, s; for (; this.indexes[t] < this.proxyOf.nodes.length && (i = this.indexes[t], s = e(this.proxyOf.nodes[i], i), s !== !1);)this.indexes[t] += 1; return delete this.indexes[t], s } walk(e) { return this.each((t, i) => { let s; try { s = e(t, i) } catch (n) { throw t.addToError(n) } return s !== !1 && t.walk && (s = t.walk(e)), s }) } walkDecls(e, t) { return t ? e instanceof RegExp ? this.walk((i, s) => { if (i.type === "decl" && e.test(i.prop)) return t(i, s) }) : this.walk((i, s) => { if (i.type === "decl" && i.prop === e) return t(i, s) }) : (t = e, this.walk((i, s) => { if (i.type === "decl") return t(i, s) })) } walkRules(e, t) { return t ? e instanceof RegExp ? this.walk((i, s) => { if (i.type === "rule" && e.test(i.selector)) return t(i, s) }) : this.walk((i, s) => { if (i.type === "rule" && i.selector === e) return t(i, s) }) : (t = e, this.walk((i, s) => { if (i.type === "rule") return t(i, s) })) } walkAtRules(e, t) { return t ? e instanceof RegExp ? this.walk((i, s) => { if (i.type === "atrule" && e.test(i.name)) return t(i, s) }) : this.walk((i, s) => { if (i.type === "atrule" && i.name === e) return t(i, s) }) : (t = e, this.walk((i, s) => { if (i.type === "atrule") return t(i, s) })) } walkComments(e) { return this.walk((t, i) => { if (t.type === "comment") return e(t, i) }) } append(...e) { for (let t of e) { let i = this.normalize(t, this.last); for (let s of i) this.proxyOf.nodes.push(s) } return this.markDirty(), this } prepend(...e) { e = e.reverse(); for (let t of e) { let i = this.normalize(t, this.first, "prepend").reverse(); for (let s of i) this.proxyOf.nodes.unshift(s); for (let s in this.indexes) this.indexes[s] = this.indexes[s] + i.length } return this.markDirty(), this } cleanRaws(e) { if (super.cleanRaws(e), this.nodes) for (let t of this.nodes) t.cleanRaws(e) } insertBefore(e, t) { e = this.index(e); let i = e === 0 ? "prepend" : !1, s = this.normalize(t, this.proxyOf.nodes[e], i).reverse(); for (let a of s) this.proxyOf.nodes.splice(e, 0, a); let n; for (let a in this.indexes) n = this.indexes[a], e <= n && (this.indexes[a] = n + s.length); return this.markDirty(), this } insertAfter(e, t) { e = this.index(e); let i = this.normalize(t, this.proxyOf.nodes[e]).reverse(); for (let n of i) this.proxyOf.nodes.splice(e + 1, 0, n); let s; for (let n in this.indexes) s = this.indexes[n], e < s && (this.indexes[n] = s + i.length); return this.markDirty(), this } removeChild(e) { e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1); let t; for (let i in this.indexes) t = this.indexes[i], t >= e && (this.indexes[i] = t - 1); return this.markDirty(), this } removeAll() { for (let e of this.proxyOf.nodes) e.parent = void 0; return this.proxyOf.nodes = [], this.markDirty(), this } replaceValues(e, t, i) { return i || (i = t, t = {}), this.walkDecls(s => { t.props && !t.props.includes(s.prop) || t.fast && !s.value.includes(t.fast) || (s.value = s.value.replace(e, i)) }), this.markDirty(), this } every(e) { return this.nodes.every(e) } some(e) { return this.nodes.some(e) } index(e) { return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e)) } get first() { if (!!this.proxyOf.nodes) return this.proxyOf.nodes[0] } get last() { if (!!this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1] } normalize(e, t) { if (typeof e == "string") e = Qf(Yf(e).nodes); else if (Array.isArray(e)) { e = e.slice(0); for (let s of e) s.parent && s.parent.removeChild(s, "ignore") } else if (e.type === "root" && this.type !== "document") { e = e.nodes.slice(0); for (let s of e) s.parent && s.parent.removeChild(s, "ignore") } else if (e.type) e = [e]; else if (e.prop) { if (typeof e.value == "undefined") throw new Error("Value field is missed in node creation"); typeof e.value != "string" && (e.value = String(e.value)), e = [new Gf(e)] } else if (e.selector) e = [new Xn(e)]; else if (e.name) e = [new Kn(e)]; else if (e.text) e = [new Hf(e)]; else throw new Error("Unknown node type in node creation"); return e.map(s => (s[Wf] || ye.rebuild(s), s = s.proxyOf, s.parent && s.parent.removeChild(s), s[Vf] && Jf(s), typeof s.raws.before == "undefined" && t && typeof t.raws.before != "undefined" && (s.raws.before = t.raws.before.replace(/\S/g, "")), s.parent = this.proxyOf, s)) } getProxyProcessor() { return { set(e, t, i) { return e[t] === i || (e[t] = i, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0 }, get(e, t) { return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...i) => e[t](...i.map(s => typeof s == "function" ? (n, a) => s(n.toProxy(), a) : s)) : t === "every" || t === "some" ? i => e[t]((s, ...n) => i(s.toProxy(), ...n)) : t === "root" ? () => e.root().toProxy() : t === "nodes" ? e.nodes.map(i => i.toProxy()) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t] } } } getIterator() { this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1; let e = this.lastEach; return this.indexes[e] = 0, e } }; ye.registerParse = r => { Yf = r }; ye.registerRule = r => { Xn = r }; ye.registerAtRule = r => { Kn = r }; Xf.exports = ye; ye.default = ye; ye.rebuild = r => { r.type === "atrule" ? Object.setPrototypeOf(r, Kn.prototype) : r.type === "rule" ? Object.setPrototypeOf(r, Xn.prototype) : r.type === "decl" ? Object.setPrototypeOf(r, Gf.prototype) : r.type === "comment" && Object.setPrototypeOf(r, Hf.prototype), r[Wf] = !0, r.nodes && r.nodes.forEach(e => { ye.rebuild(e) }) } }); var qi = w((wE, ec) => { l(); "use strict"; var jv = Ge(), Kf, Zf, bt = class extends jv { constructor(e) { super({ type: "document", ...e }); this.nodes || (this.nodes = []) } toResult(e = {}) { return new Kf(new Zf, this, e).stringify() } }; bt.registerLazyResult = r => { Kf = r }; bt.registerProcessor = r => { Zf = r }; ec.exports = bt; bt.default = bt }); var Zn = w((bE, rc) => { l(); "use strict"; var tc = {}; rc.exports = function (e) { tc[e] || (tc[e] = !0, typeof console != "undefined" && console.warn && console.warn(e)) } }); var ea = w((xE, ic) => { l(); "use strict"; var Ii = class { constructor(e, t = {}) { if (this.type = "warning", this.text = e, t.node && t.node.source) { let i = t.node.rangeBy(t); this.line = i.start.line, this.column = i.start.column, this.endLine = i.end.line, this.endColumn = i.end.column } for (let i in t) this[i] = t[i] } toString() { return this.node ? this.node.error(this.text, { plugin: this.plugin, index: this.index, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text } }; ic.exports = Ii; Ii.default = Ii }); var Mi = w((vE, sc) => { l(); "use strict"; var Uv = ea(), Ri = class { constructor(e, t, i) { this.processor = e, this.messages = [], this.root = t, this.opts = i, this.css = void 0, this.map = void 0 } toString() { return this.css } warn(e, t = {}) { t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin); let i = new Uv(e, t); return this.messages.push(i), i } warnings() { return this.messages.filter(e => e.type === "warning") } get content() { return this.css } }; sc.exports = Ri; Ri.default = Ri }); var uc = w((kE, lc) => {
                l(); "use strict"; var ta = "'".charCodeAt(0), nc = '"'.charCodeAt(0), Li = "\\".charCodeAt(0), ac = "/".charCodeAt(0), Ni = `
`.charCodeAt(0), Dr = " ".charCodeAt(0), Fi = "\f".charCodeAt(0), Bi = "	".charCodeAt(0), zi = "\r".charCodeAt(0), Vv = "[".charCodeAt(0), Wv = "]".charCodeAt(0), Gv = "(".charCodeAt(0), Hv = ")".charCodeAt(0), Yv = "{".charCodeAt(0), Qv = "}".charCodeAt(0), Jv = ";".charCodeAt(0), Xv = "*".charCodeAt(0), Kv = ":".charCodeAt(0), Zv = "@".charCodeAt(0), $i = /[\t\n\f\r "#'()/;[\\\]{}]/g, ji = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, e1 = /.[\n"'(/\\]/, oc = /[\da-f]/i; lc.exports = function (e, t = {}) { let i = e.css.valueOf(), s = t.ignoreErrors, n, a, o, u, f, c, h, p, d, y, v = i.length, b = 0, x = [], k = []; function T() { return b } function P(I) { throw e.error("Unclosed " + I, b) } function R() { return k.length === 0 && b >= v } function Y(I) { if (k.length) return k.pop(); if (b >= v) return; let Q = I ? I.ignoreUnclosed : !1; switch (n = i.charCodeAt(b), n) { case Ni: case Dr: case Bi: case zi: case Fi: { a = b; do a += 1, n = i.charCodeAt(a); while (n === Dr || n === Ni || n === Bi || n === zi || n === Fi); y = ["space", i.slice(b, a)], b = a - 1; break } case Vv: case Wv: case Yv: case Qv: case Kv: case Jv: case Hv: { let et = String.fromCharCode(n); y = [et, et, b]; break } case Gv: { if (p = x.length ? x.pop()[1] : "", d = i.charCodeAt(b + 1), p === "url" && d !== ta && d !== nc && d !== Dr && d !== Ni && d !== Bi && d !== Fi && d !== zi) { a = b; do { if (c = !1, a = i.indexOf(")", a + 1), a === -1) if (s || Q) { a = b; break } else P("bracket"); for (h = a; i.charCodeAt(h - 1) === Li;)h -= 1, c = !c } while (c); y = ["brackets", i.slice(b, a + 1), b, a], b = a } else a = i.indexOf(")", b + 1), u = i.slice(b, a + 1), a === -1 || e1.test(u) ? y = ["(", "(", b] : (y = ["brackets", u, b, a], b = a); break } case ta: case nc: { o = n === ta ? "'" : '"', a = b; do { if (c = !1, a = i.indexOf(o, a + 1), a === -1) if (s || Q) { a = b + 1; break } else P("string"); for (h = a; i.charCodeAt(h - 1) === Li;)h -= 1, c = !c } while (c); y = ["string", i.slice(b, a + 1), b, a], b = a; break } case Zv: { $i.lastIndex = b + 1, $i.test(i), $i.lastIndex === 0 ? a = i.length - 1 : a = $i.lastIndex - 2, y = ["at-word", i.slice(b, a + 1), b, a], b = a; break } case Li: { for (a = b, f = !0; i.charCodeAt(a + 1) === Li;)a += 1, f = !f; if (n = i.charCodeAt(a + 1), f && n !== ac && n !== Dr && n !== Ni && n !== Bi && n !== zi && n !== Fi && (a += 1, oc.test(i.charAt(a)))) { for (; oc.test(i.charAt(a + 1));)a += 1; i.charCodeAt(a + 1) === Dr && (a += 1) } y = ["word", i.slice(b, a + 1), b, a], b = a; break } default: { n === ac && i.charCodeAt(b + 1) === Xv ? (a = i.indexOf("*/", b + 2) + 1, a === 0 && (s || Q ? a = i.length : P("comment")), y = ["comment", i.slice(b, a + 1), b, a], b = a) : (ji.lastIndex = b + 1, ji.test(i), ji.lastIndex === 0 ? a = i.length - 1 : a = ji.lastIndex - 2, y = ["word", i.slice(b, a + 1), b, a], x.push(y), b = a); break } }return b++, y } function L(I) { k.push(I) } return { back: L, nextToken: Y, endOfFile: R, position: T } }
            }); var Ui = w((SE, cc) => { l(); "use strict"; var fc = Ge(), qr = class extends fc { constructor(e) { super(e); this.type = "atrule" } append(...e) { return this.proxyOf.nodes || (this.nodes = []), super.append(...e) } prepend(...e) { return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e) } }; cc.exports = qr; qr.default = qr; fc.registerAtRule(qr) }); var vt = w((CE, hc) => { l(); "use strict"; var t1 = Ge(), pc, dc, xt = class extends t1 { constructor(e) { super(e); this.type = "root", this.nodes || (this.nodes = []) } removeChild(e, t) { let i = this.index(e); return !t && i === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[i].raws.before), super.removeChild(e) } normalize(e, t, i) { let s = super.normalize(e); if (t) { if (i === "prepend") this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before; else if (this.first !== t) for (let n of s) n.raws.before = t.raws.before } return s } toResult(e = {}) { return new pc(new dc, this, e).stringify() } }; xt.registerLazyResult = r => { pc = r }; xt.registerProcessor = r => { dc = r }; hc.exports = xt; xt.default = xt }); var ra = w((_E, mc) => {
                l(); "use strict"; var Ir = {
                    split(r, e, t) { let i = [], s = "", n = !1, a = 0, o = !1, u = !1; for (let f of r) u ? u = !1 : f === "\\" ? u = !0 : o ? f === o && (o = !1) : f === '"' || f === "'" ? o = f : f === "(" ? a += 1 : f === ")" ? a > 0 && (a -= 1) : a === 0 && e.includes(f) && (n = !0), n ? (s !== "" && i.push(s.trim()), s = "", n = !1) : s += f; return (t || s !== "") && i.push(s.trim()), i }, space(r) {
                        let e = [" ", `
`, "	"]; return Ir.split(r, e)
                    }, comma(r) { return Ir.split(r, [","], !0) }
                }; mc.exports = Ir; Ir.default = Ir
            }); var Vi = w((AE, yc) => { l(); "use strict"; var gc = Ge(), r1 = ra(), Rr = class extends gc { constructor(e) { super(e); this.type = "rule", this.nodes || (this.nodes = []) } get selectors() { return r1.comma(this.selector) } set selectors(e) { let t = this.selector ? this.selector.match(/,\s*/) : null, i = t ? t[0] : "," + this.raw("between", "beforeOpen"); this.selector = e.join(i) } }; yc.exports = Rr; Rr.default = Rr; gc.registerRule(Rr) }); var kc = w((OE, vc) => { l(); "use strict"; var i1 = Tr(), s1 = uc(), n1 = Pr(), a1 = Ui(), o1 = vt(), wc = Vi(), bc = { empty: !0, space: !0 }; function l1(r) { for (let e = r.length - 1; e >= 0; e--) { let t = r[e], i = t[3] || t[2]; if (i) return i } } var xc = class { constructor(e) { this.input = e, this.root = new o1, this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = { input: e, start: { offset: 0, line: 1, column: 1 } } } createTokenizer() { this.tokenizer = s1(this.input) } parse() { let e; for (; !this.tokenizer.endOfFile();)switch (e = this.tokenizer.nextToken(), e[0]) { case "space": this.spaces += e[1]; break; case ";": this.freeSemicolon(e); break; case "}": this.end(e); break; case "comment": this.comment(e); break; case "at-word": this.atrule(e); break; case "{": this.emptyRule(e); break; default: this.other(e); break }this.endFile() } comment(e) { let t = new n1; this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]); let i = e[1].slice(2, -2); if (/^\s*$/.test(i)) t.text = "", t.raws.left = i, t.raws.right = ""; else { let s = i.match(/^(\s*)([^]*\S)(\s*)$/); t.text = s[2], t.raws.left = s[1], t.raws.right = s[3] } } emptyRule(e) { let t = new wc; this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t } other(e) { let t = !1, i = null, s = !1, n = null, a = [], o = e[1].startsWith("--"), u = [], f = e; for (; f;) { if (i = f[0], u.push(f), i === "(" || i === "[") n || (n = f), a.push(i === "(" ? ")" : "]"); else if (o && s && i === "{") n || (n = f), a.push("}"); else if (a.length === 0) if (i === ";") if (s) { this.decl(u, o); return } else break; else if (i === "{") { this.rule(u); return } else if (i === "}") { this.tokenizer.back(u.pop()), t = !0; break } else i === ":" && (s = !0); else i === a[a.length - 1] && (a.pop(), a.length === 0 && (n = null)); f = this.tokenizer.nextToken() } if (this.tokenizer.endOfFile() && (t = !0), a.length > 0 && this.unclosedBracket(n), t && s) { if (!o) for (; u.length && (f = u[u.length - 1][0], !(f !== "space" && f !== "comment"));)this.tokenizer.back(u.pop()); this.decl(u, o) } else this.unknownWord(u) } rule(e) { e.pop(); let t = new wc; this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t } decl(e, t) { let i = new i1; this.init(i, e[0][2]); let s = e[e.length - 1]; for (s[0] === ";" && (this.semicolon = !0, e.pop()), i.source.end = this.getPosition(s[3] || s[2] || l1(e)); e[0][0] !== "word";)e.length === 1 && this.unknownWord(e), i.raws.before += e.shift()[1]; for (i.source.start = this.getPosition(e[0][2]), i.prop = ""; e.length;) { let f = e[0][0]; if (f === ":" || f === "space" || f === "comment") break; i.prop += e.shift()[1] } i.raws.between = ""; let n; for (; e.length;)if (n = e.shift(), n[0] === ":") { i.raws.between += n[1]; break } else n[0] === "word" && /\w/.test(n[1]) && this.unknownWord([n]), i.raws.between += n[1]; (i.prop[0] === "_" || i.prop[0] === "*") && (i.raws.before += i.prop[0], i.prop = i.prop.slice(1)); let a = [], o; for (; e.length && (o = e[0][0], !(o !== "space" && o !== "comment"));)a.push(e.shift()); this.precheckMissedSemicolon(e); for (let f = e.length - 1; f >= 0; f--) { if (n = e[f], n[1].toLowerCase() === "!important") { i.important = !0; let c = this.stringFrom(e, f); c = this.spacesFromEnd(e) + c, c !== " !important" && (i.raws.important = c); break } else if (n[1].toLowerCase() === "important") { let c = e.slice(0), h = ""; for (let p = f; p > 0; p--) { let d = c[p][0]; if (h.trim().indexOf("!") === 0 && d !== "space") break; h = c.pop()[1] + h } h.trim().indexOf("!") === 0 && (i.important = !0, i.raws.important = h, e = c) } if (n[0] !== "space" && n[0] !== "comment") break } e.some(f => f[0] !== "space" && f[0] !== "comment") && (i.raws.between += a.map(f => f[1]).join(""), a = []), this.raw(i, "value", a.concat(e), t), i.value.includes(":") && !t && this.checkMissedSemicolon(e) } atrule(e) { let t = new a1; t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]); let i, s, n, a = !1, o = !1, u = [], f = []; for (; !this.tokenizer.endOfFile();) { if (e = this.tokenizer.nextToken(), i = e[0], i === "(" || i === "[" ? f.push(i === "(" ? ")" : "]") : i === "{" && f.length > 0 ? f.push("}") : i === f[f.length - 1] && f.pop(), f.length === 0) if (i === ";") { t.source.end = this.getPosition(e[2]), this.semicolon = !0; break } else if (i === "{") { o = !0; break } else if (i === "}") { if (u.length > 0) { for (n = u.length - 1, s = u[n]; s && s[0] === "space";)s = u[--n]; s && (t.source.end = this.getPosition(s[3] || s[2])) } this.end(e); break } else u.push(e); else u.push(e); if (this.tokenizer.endOfFile()) { a = !0; break } } t.raws.between = this.spacesAndCommentsFromEnd(u), u.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(u), this.raw(t, "params", u), a && (e = u[u.length - 1], t.source.end = this.getPosition(e[3] || e[2]), this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), o && (t.nodes = [], this.current = t) } end(e) { this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current = this.current.parent) : this.unexpectedClose(e) } endFile() { this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces } freeSemicolon(e) { if (this.spaces += e[1], this.current.nodes) { let t = this.current.nodes[this.current.nodes.length - 1]; t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "") } } getPosition(e) { let t = this.input.fromOffset(e); return { offset: e, line: t.line, column: t.col } } init(e, t) { this.current.push(e), e.source = { start: this.getPosition(t), input: this.input }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1) } raw(e, t, i, s) { let n, a, o = i.length, u = "", f = !0, c, h; for (let p = 0; p < o; p += 1)n = i[p], a = n[0], a === "space" && p === o - 1 && !s ? f = !1 : a === "comment" ? (h = i[p - 1] ? i[p - 1][0] : "empty", c = i[p + 1] ? i[p + 1][0] : "empty", !bc[h] && !bc[c] ? u.slice(-1) === "," ? f = !1 : u += n[1] : f = !1) : u += n[1]; if (!f) { let p = i.reduce((d, y) => d + y[1], ""); e.raws[t] = { value: u, raw: p } } e[t] = u } spacesAndCommentsFromEnd(e) { let t, i = ""; for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment"));)i = e.pop()[1] + i; return i } spacesAndCommentsFromStart(e) { let t, i = ""; for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment"));)i += e.shift()[1]; return i } spacesFromEnd(e) { let t, i = ""; for (; e.length && (t = e[e.length - 1][0], t === "space");)i = e.pop()[1] + i; return i } stringFrom(e, t) { let i = ""; for (let s = t; s < e.length; s++)i += e[s][1]; return e.splice(t, e.length - t), i } colon(e) { let t = 0, i, s, n; for (let [a, o] of e.entries()) { if (i = o, s = i[0], s === "(" && (t += 1), s === ")" && (t -= 1), t === 0 && s === ":") if (!n) this.doubleColon(i); else { if (n[0] === "word" && n[1] === "progid") continue; return a } n = i } return !1 } unclosedBracket(e) { throw this.input.error("Unclosed bracket", { offset: e[2] }, { offset: e[2] + 1 }) } unknownWord(e) { throw this.input.error("Unknown word", { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length }) } unexpectedClose(e) { throw this.input.error("Unexpected }", { offset: e[2] }, { offset: e[2] + 1 }) } unclosedBlock() { let e = this.current.source.start; throw this.input.error("Unclosed block", e.line, e.column) } doubleColon(e) { throw this.input.error("Double colon", { offset: e[2] }, { offset: e[2] + e[1].length }) } unnamedAtrule(e, t) { throw this.input.error("At-rule without name", { offset: t[2] }, { offset: t[2] + t[1].length }) } precheckMissedSemicolon() { } checkMissedSemicolon(e) { let t = this.colon(e); if (t === !1) return; let i = 0, s; for (let n = t - 1; n >= 0 && (s = e[n], !(s[0] !== "space" && (i += 1, i === 2))); n--); throw this.input.error("Missed semicolon", s[0] === "word" ? s[3] + 1 : s[2]) } }; vc.exports = xc }); var Sc = w(() => { l() }); var _c = w((PE, Cc) => { l(); var u1 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", f1 = (r, e = 21) => (t = e) => { let i = "", s = t; for (; s--;)i += r[Math.random() * r.length | 0]; return i }, c1 = (r = 21) => { let e = "", t = r; for (; t--;)e += u1[Math.random() * 64 | 0]; return e }; Cc.exports = { nanoid: c1, customAlphabet: f1 } }); var ia = w((DE, Ac) => { l(); Ac.exports = {} }); var Gi = w((qE, Pc) => {
                l(); "use strict"; var { SourceMapConsumer: p1, SourceMapGenerator: d1 } = Sc(), { fileURLToPath: Oc, pathToFileURL: Wi } = (Vn(), If), { resolve: sa, isAbsolute: na } = (tt(), ml), { nanoid: h1 } = _c(), aa = Wn(), Ec = _i(), m1 = ia(), oa = Symbol("fromOffsetCache"), g1 = Boolean(p1 && d1), Tc = Boolean(sa && na), Mr = class {
                    constructor(e, t = {}) { if (e === null || typeof e == "undefined" || typeof e == "object" && !e.toString) throw new Error(`PostCSS received ${e} instead of CSS string`); if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, t.from && (!Tc || /^\w+:\/\//.test(t.from) || na(t.from) ? this.file = t.from : this.file = sa(t.from)), Tc && g1) { let i = new m1(this.css, t); if (i.text) { this.map = i; let s = i.consumer().file; !this.file && s && (this.file = this.mapResolve(s)) } } this.file || (this.id = "<input css " + h1(6) + ">"), this.map && (this.map.file = this.from) } fromOffset(e) {
                        let t, i; if (this[oa]) i = this[oa]; else {
                            let n = this.css.split(`
`); i = new Array(n.length); let a = 0; for (let o = 0, u = n.length; o < u; o++)i[o] = a, a += n[o].length + 1; this[oa] = i
                        } t = i[i.length - 1]; let s = 0; if (e >= t) s = i.length - 1; else { let n = i.length - 2, a; for (; s < n;)if (a = s + (n - s >> 1), e < i[a]) n = a - 1; else if (e >= i[a + 1]) s = a + 1; else { s = a; break } } return { line: s + 1, col: e - i[s] + 1 }
                    } error(e, t, i, s = {}) { let n, a, o; if (t && typeof t == "object") { let f = t, c = i; if (typeof t.offset == "number") { let h = this.fromOffset(f.offset); t = h.line, i = h.col } else t = f.line, i = f.column; if (typeof c.offset == "number") { let h = this.fromOffset(c.offset); a = h.line, o = h.col } else a = c.line, o = c.column } else if (!i) { let f = this.fromOffset(t); t = f.line, i = f.col } let u = this.origin(t, i, a, o); return u ? n = new Ec(e, u.endLine === void 0 ? u.line : { line: u.line, column: u.column }, u.endLine === void 0 ? u.column : { line: u.endLine, column: u.endColumn }, u.source, u.file, s.plugin) : n = new Ec(e, a === void 0 ? t : { line: t, column: i }, a === void 0 ? i : { line: a, column: o }, this.css, this.file, s.plugin), n.input = { line: t, column: i, endLine: a, endColumn: o, source: this.css }, this.file && (Wi && (n.input.url = Wi(this.file).toString()), n.input.file = this.file), n } origin(e, t, i, s) { if (!this.map) return !1; let n = this.map.consumer(), a = n.originalPositionFor({ line: e, column: t }); if (!a.source) return !1; let o; typeof i == "number" && (o = n.originalPositionFor({ line: i, column: s })); let u; na(a.source) ? u = Wi(a.source) : u = new URL(a.source, this.map.consumer().sourceRoot || Wi(this.map.mapFile)); let f = { url: u.toString(), line: a.line, column: a.column, endLine: o && o.line, endColumn: o && o.column }; if (u.protocol === "file:") if (Oc) f.file = Oc(u); else throw new Error("file: protocol is not available in this PostCSS build"); let c = n.sourceContentFor(a.source); return c && (f.source = c), f } mapResolve(e) { return /^\w+:\/\//.test(e) ? e : sa(this.map.consumer().sourceRoot || this.map.root || ".", e) } get from() { return this.file || this.id } toJSON() { let e = {}; for (let t of ["hasBOM", "css", "file", "id"]) this[t] != null && (e[t] = this[t]); return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e }
                }; Pc.exports = Mr; Mr.default = Mr; aa && aa.registerInput && aa.registerInput(Mr)
            }); var Yi = w((IE, Dc) => { l(); "use strict"; var y1 = Ge(), w1 = kc(), b1 = Gi(); function Hi(r, e) { let t = new b1(r, e), i = new w1(t); try { i.parse() } catch (s) { throw s } return i.root } Dc.exports = Hi; Hi.default = Hi; y1.registerParse(Hi) }); var fa = w((ME, Mc) => { l(); "use strict"; var { isClean: _e, my: x1 } = Ai(), v1 = Jn(), k1 = Or(), S1 = Ge(), C1 = qi(), RE = Zn(), qc = Mi(), _1 = Yi(), A1 = vt(), O1 = { document: "Document", root: "Root", atrule: "AtRule", rule: "Rule", decl: "Declaration", comment: "Comment" }, E1 = { postcssPlugin: !0, prepare: !0, Once: !0, Document: !0, Root: !0, Declaration: !0, Rule: !0, AtRule: !0, Comment: !0, DeclarationExit: !0, RuleExit: !0, AtRuleExit: !0, CommentExit: !0, RootExit: !0, DocumentExit: !0, OnceExit: !0 }, T1 = { postcssPlugin: !0, prepare: !0, Once: !0 }, kt = 0; function Lr(r) { return typeof r == "object" && typeof r.then == "function" } function Ic(r) { let e = !1, t = O1[r.type]; return r.type === "decl" ? e = r.prop.toLowerCase() : r.type === "atrule" && (e = r.name.toLowerCase()), e && r.append ? [t, t + "-" + e, kt, t + "Exit", t + "Exit-" + e] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : r.append ? [t, kt, t + "Exit"] : [t, t + "Exit"] } function Rc(r) { let e; return r.type === "document" ? e = ["Document", kt, "DocumentExit"] : r.type === "root" ? e = ["Root", kt, "RootExit"] : e = Ic(r), { node: r, events: e, eventIndex: 0, visitors: [], visitorIndex: 0, iterator: 0 } } function la(r) { return r[_e] = !1, r.nodes && r.nodes.forEach(e => la(e)), r } var ua = {}, Re = class { constructor(e, t, i) { this.stringified = !1, this.processed = !1; let s; if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document")) s = la(t); else if (t instanceof Re || t instanceof qc) s = la(t.root), t.map && (typeof i.map == "undefined" && (i.map = {}), i.map.inline || (i.map.inline = !1), i.map.prev = t.map); else { let n = _1; i.syntax && (n = i.syntax.parse), i.parser && (n = i.parser), n.parse && (n = n.parse); try { s = n(t, i) } catch (a) { this.processed = !0, this.error = a } s && !s[x1] && S1.rebuild(s) } this.result = new qc(e, s, i), this.helpers = { ...ua, result: this.result, postcss: ua }, this.plugins = this.processor.plugins.map(n => typeof n == "object" && n.prepare ? { ...n, ...n.prepare(this.result) } : n) } get [Symbol.toStringTag]() { return "LazyResult" } get processor() { return this.result.processor } get opts() { return this.result.opts } get css() { return this.stringify().css } get content() { return this.stringify().content } get map() { return this.stringify().map } get root() { return this.sync().root } get messages() { return this.sync().messages } warnings() { return this.sync().warnings() } toString() { return this.css } then(e, t) { return this.async().then(e, t) } catch(e) { return this.async().catch(e) } finally(e) { return this.async().then(e, e) } async() { return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing) } sync() { if (this.error) throw this.error; if (this.processed) return this.result; if (this.processed = !0, this.processing) throw this.getAsyncError(); for (let e of this.plugins) { let t = this.runOnRoot(e); if (Lr(t)) throw this.getAsyncError() } if (this.prepareVisitors(), this.hasListener) { let e = this.result.root; for (; !e[_e];)e[_e] = !0, this.walkSync(e); if (this.listeners.OnceExit) if (e.type === "document") for (let t of e.nodes) this.visitSync(this.listeners.OnceExit, t); else this.visitSync(this.listeners.OnceExit, e) } return this.result } stringify() { if (this.error) throw this.error; if (this.stringified) return this.result; this.stringified = !0, this.sync(); let e = this.result.opts, t = k1; e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify); let s = new v1(t, this.result.root, this.result.opts).generate(); return this.result.css = s[0], this.result.map = s[1], this.result } walkSync(e) { e[_e] = !0; let t = Ic(e); for (let i of t) if (i === kt) e.nodes && e.each(s => { s[_e] || this.walkSync(s) }); else { let s = this.listeners[i]; if (s && this.visitSync(s, e.toProxy())) return } } visitSync(e, t) { for (let [i, s] of e) { this.result.lastPlugin = i; let n; try { n = s(t, this.helpers) } catch (a) { throw this.handleError(a, t.proxyOf) } if (t.type !== "root" && t.type !== "document" && !t.parent) return !0; if (Lr(n)) throw this.getAsyncError() } } runOnRoot(e) { this.result.lastPlugin = e; try { if (typeof e == "object" && e.Once) { if (this.result.root.type === "document") { let t = this.result.root.nodes.map(i => e.Once(i, this.helpers)); return Lr(t[0]) ? Promise.all(t) : t } return e.Once(this.result.root, this.helpers) } else if (typeof e == "function") return e(this.result.root, this.result) } catch (t) { throw this.handleError(t) } } getAsyncError() { throw new Error("Use process(css).then(cb) to work with async plugins") } handleError(e, t) { let i = this.result.lastPlugin; try { t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin ? (e.plugin = i.postcssPlugin, e.setMessage()) : i.postcssVersion } catch (s) { console && console.error && console.error(s) } return e } async runAsync() { this.plugin = 0; for (let e = 0; e < this.plugins.length; e++) { let t = this.plugins[e], i = this.runOnRoot(t); if (Lr(i)) try { await i } catch (s) { throw this.handleError(s) } } if (this.prepareVisitors(), this.hasListener) { let e = this.result.root; for (; !e[_e];) { e[_e] = !0; let t = [Rc(e)]; for (; t.length > 0;) { let i = this.visitTick(t); if (Lr(i)) try { await i } catch (s) { let n = t[t.length - 1].node; throw this.handleError(s, n) } } } if (this.listeners.OnceExit) for (let [t, i] of this.listeners.OnceExit) { this.result.lastPlugin = t; try { if (e.type === "document") { let s = e.nodes.map(n => i(n, this.helpers)); await Promise.all(s) } else await i(e, this.helpers) } catch (s) { throw this.handleError(s) } } } return this.processed = !0, this.stringify() } prepareVisitors() { this.listeners = {}; let e = (t, i, s) => { this.listeners[i] || (this.listeners[i] = []), this.listeners[i].push([t, s]) }; for (let t of this.plugins) if (typeof t == "object") for (let i in t) { if (!E1[i] && /^[A-Z]/.test(i)) throw new Error(`Unknown event ${i} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`); if (!T1[i]) if (typeof t[i] == "object") for (let s in t[i]) s === "*" ? e(t, i, t[i][s]) : e(t, i + "-" + s.toLowerCase(), t[i][s]); else typeof t[i] == "function" && e(t, i, t[i]) } this.hasListener = Object.keys(this.listeners).length > 0 } visitTick(e) { let t = e[e.length - 1], { node: i, visitors: s } = t; if (i.type !== "root" && i.type !== "document" && !i.parent) { e.pop(); return } if (s.length > 0 && t.visitorIndex < s.length) { let [a, o] = s[t.visitorIndex]; t.visitorIndex += 1, t.visitorIndex === s.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = a; try { return o(i.toProxy(), this.helpers) } catch (u) { throw this.handleError(u, i) } } if (t.iterator !== 0) { let a = t.iterator, o; for (; o = i.nodes[i.indexes[a]];)if (i.indexes[a] += 1, !o[_e]) { o[_e] = !0, e.push(Rc(o)); return } t.iterator = 0, delete i.indexes[a] } let n = t.events; for (; t.eventIndex < n.length;) { let a = n[t.eventIndex]; if (t.eventIndex += 1, a === kt) { i.nodes && i.nodes.length && (i[_e] = !0, t.iterator = i.getIterator()); return } else if (this.listeners[a]) { t.visitors = this.listeners[a]; return } } e.pop() } }; Re.registerPostcss = r => { ua = r }; Mc.exports = Re; Re.default = Re; A1.registerLazyResult(Re); C1.registerLazyResult(Re) }); var Nc = w((NE, Lc) => { l(); "use strict"; var P1 = Jn(), D1 = Or(), LE = Zn(), q1 = Yi(), I1 = Mi(), Qi = class { constructor(e, t, i) { t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = i, this._map = void 0; let s, n = D1; this.result = new I1(this._processor, s, this._opts), this.result.css = t; let a = this; Object.defineProperty(this.result, "root", { get() { return a.root } }); let o = new P1(n, s, this._opts, t); if (o.isMap()) { let [u, f] = o.generate(); u && (this.result.css = u), f && (this.result.map = f) } } get [Symbol.toStringTag]() { return "NoWorkResult" } get processor() { return this.result.processor } get opts() { return this.result.opts } get css() { return this.result.css } get content() { return this.result.css } get map() { return this.result.map } get root() { if (this._root) return this._root; let e, t = q1; try { e = t(this._css, this._opts) } catch (i) { this.error = i } if (this.error) throw this.error; return this._root = e, e } get messages() { return [] } warnings() { return [] } toString() { return this._css } then(e, t) { return this.async().then(e, t) } catch(e) { return this.async().catch(e) } finally(e) { return this.async().then(e, e) } async() { return this.error ? Promise.reject(this.error) : Promise.resolve(this.result) } sync() { if (this.error) throw this.error; return this.result } }; Lc.exports = Qi; Qi.default = Qi }); var Bc = w((FE, Fc) => { l(); "use strict"; var R1 = Nc(), M1 = fa(), L1 = qi(), N1 = vt(), St = class { constructor(e = []) { this.version = "8.4.14", this.plugins = this.normalize(e) } use(e) { return this.plugins = this.plugins.concat(this.normalize([e])), this } process(e, t = {}) { return this.plugins.length === 0 && typeof t.parser == "undefined" && typeof t.stringifier == "undefined" && typeof t.syntax == "undefined" ? new R1(this, e, t) : new M1(this, e, t) } normalize(e) { let t = []; for (let i of e) if (i.postcss === !0 ? i = i() : i.postcss && (i = i.postcss), typeof i == "object" && Array.isArray(i.plugins)) t = t.concat(i.plugins); else if (typeof i == "object" && i.postcssPlugin) t.push(i); else if (typeof i == "function") t.push(i); else if (!(typeof i == "object" && (i.parse || i.stringify))) throw new Error(i + " is not a PostCSS plugin"); return t } }; Fc.exports = St; St.default = St; N1.registerProcessor(St); L1.registerProcessor(St) }); var $c = w((BE, zc) => { l(); "use strict"; var F1 = Tr(), B1 = ia(), z1 = Pr(), $1 = Ui(), j1 = Gi(), U1 = vt(), V1 = Vi(); function Nr(r, e) { if (Array.isArray(r)) return r.map(s => Nr(s)); let { inputs: t, ...i } = r; if (t) { e = []; for (let s of t) { let n = { ...s, __proto__: j1.prototype }; n.map && (n.map = { ...n.map, __proto__: B1.prototype }), e.push(n) } } if (i.nodes && (i.nodes = r.nodes.map(s => Nr(s, e))), i.source) { let { inputId: s, ...n } = i.source; i.source = n, s != null && (i.source.input = e[s]) } if (i.type === "root") return new U1(i); if (i.type === "decl") return new F1(i); if (i.type === "rule") return new V1(i); if (i.type === "comment") return new z1(i); if (i.type === "atrule") return new $1(i); throw new Error("Unknown node type: " + r.type) } zc.exports = Nr; Nr.default = Nr }); var ue = w((zE, Yc) => {
                l(); "use strict"; var W1 = _i(), jc = Tr(), G1 = fa(), H1 = Ge(), ca = Bc(), Y1 = Or(), Q1 = $c(), Uc = qi(), J1 = ea(), Vc = Pr(), Wc = Ui(), X1 = Mi(), K1 = Gi(), Z1 = Yi(), ek = ra(), Gc = Vi(), Hc = vt(), tk = Er(); function F(...r) { return r.length === 1 && Array.isArray(r[0]) && (r = r[0]), new ca(r) } F.plugin = function (e, t) {
                    let i = !1; function s(...a) {
                        console && console.warn && !i && (i = !0, console.warn(e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), m.env.LANG && m.env.LANG.startsWith("cn") && console.warn(e + `: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
https://www.w3ctech.com/topic/2226`)); let o = t(...a); return o.postcssPlugin = e, o.postcssVersion = new ca().version, o
                    } let n; return Object.defineProperty(s, "postcss", { get() { return n || (n = s()), n } }), s.process = function (a, o, u) { return F([s(u)]).process(a, o) }, s
                }; F.stringify = Y1; F.parse = Z1; F.fromJSON = Q1; F.list = ek; F.comment = r => new Vc(r); F.atRule = r => new Wc(r); F.decl = r => new jc(r); F.rule = r => new Gc(r); F.root = r => new Hc(r); F.document = r => new Uc(r); F.CssSyntaxError = W1; F.Declaration = jc; F.Container = H1; F.Processor = ca; F.Document = Uc; F.Comment = Vc; F.Warning = J1; F.AtRule = Wc; F.Result = X1; F.Input = K1; F.Rule = Gc; F.Root = Hc; F.Node = tk; G1.registerPostcss(F); Yc.exports = F; F.default = F
            }); var j, U, $E, jE, UE, VE, WE, GE, HE, YE, QE, JE, XE, KE, ZE, e5, t5, r5, i5, s5, n5, a5, o5, l5, u5, f5, He = C(() => { l(); j = H(ue()), U = j.default, $E = j.default.stringify, jE = j.default.fromJSON, UE = j.default.plugin, VE = j.default.parse, WE = j.default.list, GE = j.default.document, HE = j.default.comment, YE = j.default.atRule, QE = j.default.rule, JE = j.default.decl, XE = j.default.root, KE = j.default.CssSyntaxError, ZE = j.default.Declaration, e5 = j.default.Container, t5 = j.default.Processor, r5 = j.default.Document, i5 = j.default.Comment, s5 = j.default.Warning, n5 = j.default.AtRule, a5 = j.default.Result, o5 = j.default.Input, l5 = j.default.Rule, u5 = j.default.Root, f5 = j.default.Node }); var pa = w((p5, Qc) => { l(); Qc.exports = function (r, e, t, i, s) { for (e = e.split ? e.split(".") : e, i = 0; i < e.length; i++)r = r ? r[e[i]] : s; return r === s ? t : r } }); function Me(r) { return ["fontSize", "outline"].includes(r) ? e => (typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e[0]), e) : ["fontFamily", "boxShadow", "transitionProperty", "transitionDuration", "transitionDelay", "transitionTimingFunction", "backgroundImage", "backgroundSize", "backgroundColor", "cursor", "animation"].includes(r) ? e => (typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e.join(", ")), e) : ["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(r) ? e => (typeof e == "function" && (e = e({})), typeof e == "string" && (e = U.list.comma(e).join(" ")), e) : (e, t = {}) => (typeof e == "function" && (e = e(t)), e) } var Fr = C(() => { l(); He() }); var ep = w((m5, ga) => { l(); var Jc = Se(); function da(r, e) { let t, i = Jc(s => { t = s }); try { i.processSync(r) } catch (s) { throw r.includes(":") ? e ? e.error("Missed semicolon") : s : e ? e.error(s.message) : s } return t.at(0) } function Xc(r, e) { let t = !1; return r.each(i => { if (i.type === "nesting") { let s = e.clone(); i.value !== "&" ? i.replaceWith(da(i.value.replace("&", s.toString()))) : i.replaceWith(s), t = !0 } else i.nodes && Xc(i, e) && (t = !0) }), t } function Kc(r, e) { let t = []; return r.selectors.forEach(i => { let s = da(i, r); e.selectors.forEach(n => { if (n.length) { let a = da(n, e); Xc(a, s) || (a.prepend(Jc.combinator({ value: " " })), a.prepend(s.clone())), t.push(a.toString()) } }) }), t } function ha(r, e) { return r && r.type === "comment" ? (e.after(r), r) : e } function rk(r) { return function e(t, i, s) { let n = []; if (i.each(a => { a.type === "comment" || a.type === "decl" ? n.push(a) : a.type === "rule" && s ? a.selectors = Kc(t, a) : a.type === "atrule" && (a.nodes && r[a.name] ? e(t, a, !0) : n.push(a)) }), s && n.length) { let a = t.clone({ nodes: [] }); for (let o of n) a.append(o); i.prepend(a) } } } function ma(r, e, t, i) { let s = new i({ selector: r, nodes: [] }); for (let n of e) s.append(n); return t.after(s), s } function Zc(r, e) { let t = {}; for (let i of r) t[i] = !0; if (e) for (let i of e) { let s = i.replace(/^@/, ""); t[s] = !0 } return t } ga.exports = (r = {}) => { let e = Zc(["media", "supports"], r.bubble), t = rk(e), i = Zc(["document", "font-face", "keyframes", "-webkit-keyframes", "-moz-keyframes"], r.unwrap), s = r.preserveEmpty; return { postcssPlugin: "postcss-nested", Rule(n, { Rule: a }) { let o = !1, u = n, f = !1, c = []; n.each(h => { if (h.type === "rule") c.length && (u = ma(n.selector, c, u, a), c = []), f = !0, o = !0, h.selectors = Kc(n, h), u = ha(h.prev(), u), u.after(h), u = h; else if (h.type === "atrule") if (c.length && (u = ma(n.selector, c, u, a), c = []), h.name === "at-root") { o = !0, t(n, h, !1); let p = h.nodes; h.params && (p = new a({ selector: h.params, nodes: p })), u.after(p), u = p, h.remove() } else e[h.name] ? (f = !0, o = !0, t(n, h, !0), u = ha(h.prev(), u), u.after(h), u = h) : i[h.name] ? (f = !0, o = !0, t(n, h, !1), u = ha(h.prev(), u), u.after(h), u = h) : f && c.push(h); else h.type === "decl" && f && c.push(h) }), c.length && (u = ma(n.selector, c, u, a)), o && s !== !0 && (n.raws.semicolon = !0, n.nodes.length === 0 && n.remove()) } } }; ga.exports.postcss = !0 }); var sp = w((g5, ip) => { l(); "use strict"; var tp = /-(\w|$)/g, rp = (r, e) => e.toUpperCase(), ik = r => (r = r.toLowerCase(), r === "float" ? "cssFloat" : r.startsWith("-ms-") ? r.substr(1).replace(tp, rp) : r.replace(tp, rp)); ip.exports = ik }); var ba = w((y5, np) => { l(); var sk = sp(), nk = { boxFlex: !0, boxFlexGroup: !0, columnCount: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, strokeDashoffset: !0, strokeOpacity: !0, strokeWidth: !0 }; function ya(r) { return typeof r.nodes == "undefined" ? !0 : wa(r) } function wa(r) { let e, t = {}; return r.each(i => { if (i.type === "atrule") e = "@" + i.name, i.params && (e += " " + i.params), typeof t[e] == "undefined" ? t[e] = ya(i) : Array.isArray(t[e]) ? t[e].push(ya(i)) : t[e] = [t[e], ya(i)]; else if (i.type === "rule") { let s = wa(i); if (t[i.selector]) for (let n in s) t[i.selector][n] = s[n]; else t[i.selector] = s } else if (i.type === "decl") { i.prop[0] === "-" && i.prop[1] === "-" ? e = i.prop : e = sk(i.prop); let s = i.value; !isNaN(i.value) && nk[e] && (s = parseFloat(i.value)), i.important && (s += " !important"), typeof t[e] == "undefined" ? t[e] = s : Array.isArray(t[e]) ? t[e].push(s) : t[e] = [t[e], s] } }), t } np.exports = wa }); var Ji = w((w5, up) => { l(); var Br = ue(), ap = /\s*!important\s*$/i, ak = { "box-flex": !0, "box-flex-group": !0, "column-count": !0, flex: !0, "flex-grow": !0, "flex-positive": !0, "flex-shrink": !0, "flex-negative": !0, "font-weight": !0, "line-clamp": !0, "line-height": !0, opacity: !0, order: !0, orphans: !0, "tab-size": !0, widows: !0, "z-index": !0, zoom: !0, "fill-opacity": !0, "stroke-dashoffset": !0, "stroke-opacity": !0, "stroke-width": !0 }; function ok(r) { return r.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase() } function op(r, e, t) { t === !1 || t === null || (e.startsWith("--") || (e = ok(e)), typeof t == "number" && (t === 0 || ak[e] ? t = t.toString() : t += "px"), e === "css-float" && (e = "float"), ap.test(t) ? (t = t.replace(ap, ""), r.push(Br.decl({ prop: e, value: t, important: !0 }))) : r.push(Br.decl({ prop: e, value: t }))) } function lp(r, e, t) { let i = Br.atRule({ name: e[1], params: e[3] || "" }); typeof t == "object" && (i.nodes = [], xa(t, i)), r.push(i) } function xa(r, e) { let t, i, s; for (t in r) if (i = r[t], !(i === null || typeof i == "undefined")) if (t[0] === "@") { let n = t.match(/@(\S+)(\s+([\W\w]*)\s*)?/); if (Array.isArray(i)) for (let a of i) lp(e, n, a); else lp(e, n, i) } else if (Array.isArray(i)) for (let n of i) op(e, t, n); else typeof i == "object" ? (s = Br.rule({ selector: t }), xa(i, s), e.push(s)) : op(e, t, i) } up.exports = function (r) { let e = Br.root(); return xa(r, e), e } }); var va = w((b5, fp) => { l(); var lk = ba(); fp.exports = function (e) { return console && console.warn && e.warnings().forEach(t => { let i = t.plugin || "PostCSS"; console.warn(i + ": " + t.text) }), lk(e.root) } }); var pp = w((x5, cp) => { l(); var uk = ue(), fk = va(), ck = Ji(); cp.exports = function (e) { let t = uk(e); return async i => { let s = await t.process(i, { parser: ck, from: void 0 }); return fk(s) } } }); var hp = w((v5, dp) => { l(); var pk = ue(), dk = va(), hk = Ji(); dp.exports = function (r) { let e = pk(r); return t => { let i = e.process(t, { parser: hk, from: void 0 }); return dk(i) } } }); var gp = w((k5, mp) => { l(); var mk = ba(), gk = Ji(), yk = pp(), wk = hp(); mp.exports = { objectify: mk, parse: gk, async: yk, sync: wk } }); var Ct, yp, S5, C5, _5, A5, wp = C(() => { l(); Ct = H(gp()), yp = Ct.default, S5 = Ct.default.objectify, C5 = Ct.default.parse, _5 = Ct.default.async, A5 = Ct.default.sync }); function _t(r) { return Array.isArray(r) ? r.flatMap(e => U([(0, bp.default)({ bubble: ["screen"] })]).process(e, { parser: yp }).root.nodes) : _t([r]) } var bp, ka = C(() => { l(); He(); bp = H(ep()); wp() }); function At(r, e, t = !1) { return (0, xp.default)(i => { i.walkClasses(s => { let n = s.value, a = t && n.startsWith("-"); s.value = a ? `-${r}${n.slice(1)}` : `${r}${n}` }) }).processSync(e) } var xp, Xi = C(() => { l(); xp = H(Se()) }); function fe(r) { let e = vp.default.className(); return e.value = r, nt(e?.raws?.value ?? e.value) } var vp, Ot = C(() => { l(); vp = H(Se()); mi() }); function Sa(r) { return nt(`.${fe(r)}`) } function Ki(r, e) { return Sa(zr(r, e)) } function zr(r, e) { return e === "DEFAULT" ? r : e === "-" || e === "-DEFAULT" ? `-${r}` : e.startsWith("-") ? `-${r}${e}` : `${r}-${e}` } var Ca = C(() => { l(); Ot(); mi() }); function at(r) { return (r > 0n) - (r < 0n) } var Zi = C(() => { l() }); function O(r, e = [[r, [r]]], { filterDefault: t = !1, ...i } = {}) { let s = Me(r); return function ({ matchUtilities: n, theme: a }) { for (let o of e) { let u = Array.isArray(o[0]) ? o : [o]; n(u.reduce((f, [c, h]) => Object.assign(f, { [c]: p => h.reduce((d, y) => Array.isArray(y) ? Object.assign(d, { [y[0]]: y[1] }) : Object.assign(d, { [y]: s(p) }), {}) }), {}), { ...i, values: t ? Object.fromEntries(Object.entries(a(r) ?? {}).filter(([f]) => f !== "DEFAULT")) : a(r) }) } } } var kp = C(() => { l(); Fr() }); function ot(r) { return r = Array.isArray(r) ? r : [r], r.map(e => e.values.map(t => t.raw !== void 0 ? t.raw : [t.min && `(min-width: ${t.min})`, t.max && `(max-width: ${t.max})`].filter(Boolean).join(" and "))).join(", ") } var es = C(() => { l() }); function _a(r) { return r.split(_k).map(t => { let i = t.trim(), s = { value: i }, n = i.split(Ak), a = new Set; for (let o of n) !a.has("DIRECTIONS") && bk.has(o) ? (s.direction = o, a.add("DIRECTIONS")) : !a.has("PLAY_STATES") && xk.has(o) ? (s.playState = o, a.add("PLAY_STATES")) : !a.has("FILL_MODES") && vk.has(o) ? (s.fillMode = o, a.add("FILL_MODES")) : !a.has("ITERATION_COUNTS") && (kk.has(o) || Ok.test(o)) ? (s.iterationCount = o, a.add("ITERATION_COUNTS")) : !a.has("TIMING_FUNCTION") && Sk.has(o) || !a.has("TIMING_FUNCTION") && Ck.some(u => o.startsWith(`${u}(`)) ? (s.timingFunction = o, a.add("TIMING_FUNCTION")) : !a.has("DURATION") && Sp.test(o) ? (s.duration = o, a.add("DURATION")) : !a.has("DELAY") && Sp.test(o) ? (s.delay = o, a.add("DELAY")) : a.has("NAME") ? (s.unknown || (s.unknown = []), s.unknown.push(o)) : (s.name = o, a.add("NAME")); return s }) } var bk, xk, vk, kk, Sk, Ck, _k, Ak, Sp, Ok, Cp = C(() => { l(); bk = new Set(["normal", "reverse", "alternate", "alternate-reverse"]), xk = new Set(["running", "paused"]), vk = new Set(["none", "forwards", "backwards", "both"]), kk = new Set(["infinite"]), Sk = new Set(["linear", "ease", "ease-in", "ease-out", "ease-in-out", "step-start", "step-end"]), Ck = ["cubic-bezier", "steps"], _k = /\,(?![^(]*\))/g, Ak = /\ +(?![^(]*\))/g, Sp = /^(-?[\d.]+m?s)$/, Ok = /^(\d+)$/ }); var _p, J, Ap = C(() => { l(); _p = r => Object.assign({}, ...Object.entries(r ?? {}).flatMap(([e, t]) => typeof t == "object" ? Object.entries(_p(t)).map(([i, s]) => ({ [e + (i === "DEFAULT" ? "" : `-${i}`)]: s })) : [{ [`${e}`]: t }])), J = _p }); var Ep, Op = C(() => { Ep = "3.1.3" }); function Ye(r, e = !0) { return Array.isArray(r) ? r.map(t => { if (e && Array.isArray(t)) throw new Error("The tuple syntax is not supported for `screens`."); if (typeof t == "string") return { name: t.toString(), values: [{ min: t, max: void 0 }] }; let [i, s] = t; return i = i.toString(), typeof s == "string" ? { name: i, values: [{ min: s, max: void 0 }] } : Array.isArray(s) ? { name: i, values: s.map(n => Tp(n)) } : { name: i, values: [Tp(s)] } }) : Ye(Object.entries(r ?? {}), !1) } function Tp({ "min-width": r, min: e = r, max: t, raw: i } = {}) { return { min: e, max: t, raw: i } } var ts = C(() => { l() }); function rs(r, e) { r.walkDecls(t => { if (e.includes(t.prop)) { t.remove(); return } for (let i of e) t.value.includes(`/ var(${i})`) && (t.value = t.value.replace(`/ var(${i})`, "")) }) } var Pp = C(() => { l() }); var we, be, Ae, Oe, Dp, qp = C(() => { l(); ct(); tt(); He(); kp(); es(); Ot(); Cp(); Ap(); br(); Nn(); Qt(); Fr(); Op(); ve(); ts(); Pn(); Pp(); Ve(); we = { pseudoElementVariants: ({ addVariant: r }) => { r("first-letter", "&::first-letter"), r("first-line", "&::first-line"), r("marker", [({ container: e }) => (rs(e, ["--tw-text-opacity"]), "& *::marker"), ({ container: e }) => (rs(e, ["--tw-text-opacity"]), "&::marker")]), r("selection", ["& *::selection", "&::selection"]), r("file", "&::file-selector-button"), r("placeholder", "&::placeholder"), r("backdrop", "&::backdrop"), r("before", ({ container: e }) => (e.walkRules(t => { let i = !1; t.walkDecls("content", () => { i = !0 }), i || t.prepend(U.decl({ prop: "content", value: "var(--tw-content)" })) }), "&::before")), r("after", ({ container: e }) => (e.walkRules(t => { let i = !1; t.walkDecls("content", () => { i = !0 }), i || t.prepend(U.decl({ prop: "content", value: "var(--tw-content)" })) }), "&::after")) }, pseudoClassVariants: ({ addVariant: r, config: e }) => { let t = [["first", "&:first-child"], ["last", "&:last-child"], ["only", "&:only-child"], ["odd", "&:nth-child(odd)"], ["even", "&:nth-child(even)"], "first-of-type", "last-of-type", "only-of-type", ["visited", ({ container: i }) => (rs(i, ["--tw-text-opacity", "--tw-border-opacity", "--tw-bg-opacity"]), "&:visited")], "target", ["open", "&[open]"], "default", "checked", "indeterminate", "placeholder-shown", "autofill", "optional", "required", "valid", "invalid", "in-range", "out-of-range", "read-only", "empty", "focus-within", ["hover", K(e(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"], "focus", "focus-visible", "active", "enabled", "disabled"].map(i => Array.isArray(i) ? i : [i, `&:${i}`]); for (let [i, s] of t) r(i, n => typeof s == "function" ? s(n) : s); for (let [i, s] of t) r(`group-${i}`, n => (typeof s == "function" ? s(n) : s).replace(/&(\S+)/, ":merge(.group)$1 &")); for (let [i, s] of t) r(`peer-${i}`, n => (typeof s == "function" ? s(n) : s).replace(/&(\S+)/, ":merge(.peer)$1 ~ &")) }, directionVariants: ({ addVariant: r }) => { r("ltr", () => (V.warn("rtl-experimental", ["The RTL features in Tailwind CSS are currently in preview.", "Preview features are not covered by semver, and may be improved in breaking ways at any time."]), '[dir="ltr"] &')), r("rtl", () => (V.warn("rtl-experimental", ["The RTL features in Tailwind CSS are currently in preview.", "Preview features are not covered by semver, and may be improved in breaking ways at any time."]), '[dir="rtl"] &')) }, reducedMotionVariants: ({ addVariant: r }) => { r("motion-safe", "@media (prefers-reduced-motion: no-preference)"), r("motion-reduce", "@media (prefers-reduced-motion: reduce)") }, darkVariants: ({ config: r, addVariant: e }) => { let [t, i = ".dark"] = [].concat(r("darkMode", "media")); t === !1 && (t = "media", V.warn("darkmode-false", ["The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.", "Change `darkMode` to `media` or remove it entirely.", "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"])), t === "class" ? e("dark", `${i} &`) : t === "media" && e("dark", "@media (prefers-color-scheme: dark)") }, printVariant: ({ addVariant: r }) => { r("print", "@media print") }, screenVariants: ({ theme: r, addVariant: e }) => { for (let t of Ye(r("screens"))) { let i = ot(t); e(t.name, `@media ${i}`) } }, orientationVariants: ({ addVariant: r }) => { r("portrait", "@media (orientation: portrait)"), r("landscape", "@media (orientation: landscape)") }, prefersContrastVariants: ({ addVariant: r }) => { r("contrast-more", "@media (prefers-contrast: more)"), r("contrast-less", "@media (prefers-contrast: less)") } }, be = ["translate(var(--tw-translate-x), var(--tw-translate-y))", "rotate(var(--tw-rotate))", "skewX(var(--tw-skew-x))", "skewY(var(--tw-skew-y))", "scaleX(var(--tw-scale-x))", "scaleY(var(--tw-scale-y))"].join(" "), Ae = ["var(--tw-blur)", "var(--tw-brightness)", "var(--tw-contrast)", "var(--tw-grayscale)", "var(--tw-hue-rotate)", "var(--tw-invert)", "var(--tw-saturate)", "var(--tw-sepia)", "var(--tw-drop-shadow)"].join(" "), Oe = ["var(--tw-backdrop-blur)", "var(--tw-backdrop-brightness)", "var(--tw-backdrop-contrast)", "var(--tw-backdrop-grayscale)", "var(--tw-backdrop-hue-rotate)", "var(--tw-backdrop-invert)", "var(--tw-backdrop-opacity)", "var(--tw-backdrop-saturate)", "var(--tw-backdrop-sepia)"].join(" "), Dp = { preflight: ({ addBase: r }) => { let e = U.parse(`*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:theme('borderColor.DEFAULT', currentColor)}::after,::before{--tw-content:''}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:theme('fontFamily.sans', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji")}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:theme('fontFamily.mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace);font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:theme('colors.gray.4', #9ca3af)}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}`); r([U.comment({ text: `! tailwindcss v${Ep} | MIT License | https://tailwindcss.com` }), ...e.nodes]) }, container: (() => { function r(t = []) { return t.flatMap(i => i.values.map(s => s.min)).filter(i => i !== void 0) } function e(t, i, s) { if (typeof s == "undefined") return []; if (!(typeof s == "object" && s !== null)) return [{ screen: "DEFAULT", minWidth: 0, padding: s }]; let n = []; s.DEFAULT && n.push({ screen: "DEFAULT", minWidth: 0, padding: s.DEFAULT }); for (let a of t) for (let o of i) for (let { min: u } of o.values) u === a && n.push({ minWidth: a, padding: s[o.name] }); return n } return function ({ addComponents: t, theme: i }) { let s = Ye(i("container.screens", i("screens"))), n = r(s), a = e(n, s, i("container.padding")), o = f => { let c = a.find(h => h.minWidth === f); return c ? { paddingRight: c.padding, paddingLeft: c.padding } : {} }, u = Array.from(new Set(n.slice().sort((f, c) => parseInt(f) - parseInt(c)))).map(f => ({ [`@media (min-width: ${f})`]: { ".container": { "max-width": f, ...o(f) } } })); t([{ ".container": Object.assign({ width: "100%" }, i("container.center", !1) ? { marginRight: "auto", marginLeft: "auto" } : {}, o(0)) }, ...u]) } })(), accessibility: ({ addUtilities: r }) => { r({ ".sr-only": { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" }, ".not-sr-only": { position: "static", width: "auto", height: "auto", padding: "0", margin: "0", overflow: "visible", clip: "auto", whiteSpace: "normal" } }) }, pointerEvents: ({ addUtilities: r }) => { r({ ".pointer-events-none": { "pointer-events": "none" }, ".pointer-events-auto": { "pointer-events": "auto" } }) }, visibility: ({ addUtilities: r }) => { r({ ".visible": { visibility: "visible" }, ".invisible": { visibility: "hidden" } }) }, position: ({ addUtilities: r }) => { r({ ".static": { position: "static" }, ".fixed": { position: "fixed" }, ".absolute": { position: "absolute" }, ".relative": { position: "relative" }, ".sticky": { position: "sticky" } }) }, inset: O("inset", [["inset", ["top", "right", "bottom", "left"]], [["inset-x", ["left", "right"]], ["inset-y", ["top", "bottom"]]], [["top", ["top"]], ["right", ["right"]], ["bottom", ["bottom"]], ["left", ["left"]]]], { supportsNegativeValues: !0 }), isolation: ({ addUtilities: r }) => { r({ ".isolate": { isolation: "isolate" }, ".isolation-auto": { isolation: "auto" } }) }, zIndex: O("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: !0 }), order: O("order", void 0, { supportsNegativeValues: !0 }), gridColumn: O("gridColumn", [["col", ["gridColumn"]]]), gridColumnStart: O("gridColumnStart", [["col-start", ["gridColumnStart"]]]), gridColumnEnd: O("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]), gridRow: O("gridRow", [["row", ["gridRow"]]]), gridRowStart: O("gridRowStart", [["row-start", ["gridRowStart"]]]), gridRowEnd: O("gridRowEnd", [["row-end", ["gridRowEnd"]]]), float: ({ addUtilities: r }) => { r({ ".float-right": { float: "right" }, ".float-left": { float: "left" }, ".float-none": { float: "none" } }) }, clear: ({ addUtilities: r }) => { r({ ".clear-left": { clear: "left" }, ".clear-right": { clear: "right" }, ".clear-both": { clear: "both" }, ".clear-none": { clear: "none" } }) }, margin: O("margin", [["m", ["margin"]], [["mx", ["margin-left", "margin-right"]], ["my", ["margin-top", "margin-bottom"]]], [["mt", ["margin-top"]], ["mr", ["margin-right"]], ["mb", ["margin-bottom"]], ["ml", ["margin-left"]]]], { supportsNegativeValues: !0 }), boxSizing: ({ addUtilities: r }) => { r({ ".box-border": { "box-sizing": "border-box" }, ".box-content": { "box-sizing": "content-box" } }) }, display: ({ addUtilities: r }) => { r({ ".block": { display: "block" }, ".inline-block": { display: "inline-block" }, ".inline": { display: "inline" }, ".flex": { display: "flex" }, ".inline-flex": { display: "inline-flex" }, ".table": { display: "table" }, ".inline-table": { display: "inline-table" }, ".table-caption": { display: "table-caption" }, ".table-cell": { display: "table-cell" }, ".table-column": { display: "table-column" }, ".table-column-group": { display: "table-column-group" }, ".table-footer-group": { display: "table-footer-group" }, ".table-header-group": { display: "table-header-group" }, ".table-row-group": { display: "table-row-group" }, ".table-row": { display: "table-row" }, ".flow-root": { display: "flow-root" }, ".grid": { display: "grid" }, ".inline-grid": { display: "inline-grid" }, ".contents": { display: "contents" }, ".list-item": { display: "list-item" }, ".hidden": { display: "none" } }) }, aspectRatio: O("aspectRatio", [["aspect", ["aspect-ratio"]]]), height: O("height", [["h", ["height"]]]), maxHeight: O("maxHeight", [["max-h", ["maxHeight"]]]), minHeight: O("minHeight", [["min-h", ["minHeight"]]]), width: O("width", [["w", ["width"]]]), minWidth: O("minWidth", [["min-w", ["minWidth"]]]), maxWidth: O("maxWidth", [["max-w", ["maxWidth"]]]), flex: O("flex"), flexShrink: O("flexShrink", [["flex-shrink", ["flex-shrink"]], ["shrink", ["flex-shrink"]]]), flexGrow: O("flexGrow", [["flex-grow", ["flex-grow"]], ["grow", ["flex-grow"]]]), flexBasis: O("flexBasis", [["basis", ["flex-basis"]]]), tableLayout: ({ addUtilities: r }) => { r({ ".table-auto": { "table-layout": "auto" }, ".table-fixed": { "table-layout": "fixed" } }) }, borderCollapse: ({ addUtilities: r }) => { r({ ".border-collapse": { "border-collapse": "collapse" }, ".border-separate": { "border-collapse": "separate" } }) }, borderSpacing: ({ addDefaults: r, matchUtilities: e, theme: t }) => { r("border-spacing", { "--tw-border-spacing-x": 0, "--tw-border-spacing-y": 0 }), e({ "border-spacing": i => ({ "--tw-border-spacing-x": i, "--tw-border-spacing-y": i, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-x": i => ({ "--tw-border-spacing-x": i, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-y": i => ({ "--tw-border-spacing-y": i, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }) }, { values: t("borderSpacing") }) }, transformOrigin: O("transformOrigin", [["origin", ["transformOrigin"]]]), translate: O("translate", [[["translate-x", [["@defaults transform", {}], "--tw-translate-x", ["transform", be]]], ["translate-y", [["@defaults transform", {}], "--tw-translate-y", ["transform", be]]]]], { supportsNegativeValues: !0 }), rotate: O("rotate", [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", be]]]], { supportsNegativeValues: !0 }), skew: O("skew", [[["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", be]]], ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", be]]]]], { supportsNegativeValues: !0 }), scale: O("scale", [["scale", [["@defaults transform", {}], "--tw-scale-x", "--tw-scale-y", ["transform", be]]], [["scale-x", [["@defaults transform", {}], "--tw-scale-x", ["transform", be]]], ["scale-y", [["@defaults transform", {}], "--tw-scale-y", ["transform", be]]]]], { supportsNegativeValues: !0 }), transform: ({ addDefaults: r, addUtilities: e }) => { r("transform", { "--tw-translate-x": "0", "--tw-translate-y": "0", "--tw-rotate": "0", "--tw-skew-x": "0", "--tw-skew-y": "0", "--tw-scale-x": "1", "--tw-scale-y": "1" }), e({ ".transform": { "@defaults transform": {}, transform: be }, ".transform-cpu": { transform: be }, ".transform-gpu": { transform: be.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)") }, ".transform-none": { transform: "none" } }) }, animation: ({ matchUtilities: r, theme: e, config: t }) => { let i = n => `${t("prefix")}${fe(n)}`, s = Object.fromEntries(Object.entries(e("keyframes") ?? {}).map(([n, a]) => [n, { [`@keyframes ${i(n)}`]: a }])); r({ animate: n => { let a = _a(n); return [...a.flatMap(o => s[o.name]), { animation: a.map(({ name: o, value: u }) => o === void 0 || s[o] === void 0 ? u : u.replace(o, i(o))).join(", ") }] } }, { values: e("animation") }) }, cursor: O("cursor"), touchAction: ({ addDefaults: r, addUtilities: e }) => { r("touch-action", { "--tw-pan-x": " ", "--tw-pan-y": " ", "--tw-pinch-zoom": " " }); let t = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)"; e({ ".touch-auto": { "touch-action": "auto" }, ".touch-none": { "touch-action": "none" }, ".touch-pan-x": { "@defaults touch-action": {}, "--tw-pan-x": "pan-x", "touch-action": t }, ".touch-pan-left": { "@defaults touch-action": {}, "--tw-pan-x": "pan-left", "touch-action": t }, ".touch-pan-right": { "@defaults touch-action": {}, "--tw-pan-x": "pan-right", "touch-action": t }, ".touch-pan-y": { "@defaults touch-action": {}, "--tw-pan-y": "pan-y", "touch-action": t }, ".touch-pan-up": { "@defaults touch-action": {}, "--tw-pan-y": "pan-up", "touch-action": t }, ".touch-pan-down": { "@defaults touch-action": {}, "--tw-pan-y": "pan-down", "touch-action": t }, ".touch-pinch-zoom": { "@defaults touch-action": {}, "--tw-pinch-zoom": "pinch-zoom", "touch-action": t }, ".touch-manipulation": { "touch-action": "manipulation" } }) }, userSelect: ({ addUtilities: r }) => { r({ ".select-none": { "user-select": "none" }, ".select-text": { "user-select": "text" }, ".select-all": { "user-select": "all" }, ".select-auto": { "user-select": "auto" } }) }, resize: ({ addUtilities: r }) => { r({ ".resize-none": { resize: "none" }, ".resize-y": { resize: "vertical" }, ".resize-x": { resize: "horizontal" }, ".resize": { resize: "both" } }) }, scrollSnapType: ({ addDefaults: r, addUtilities: e }) => { r("scroll-snap-type", { "--tw-scroll-snap-strictness": "proximity" }), e({ ".snap-none": { "scroll-snap-type": "none" }, ".snap-x": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "x var(--tw-scroll-snap-strictness)" }, ".snap-y": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "y var(--tw-scroll-snap-strictness)" }, ".snap-both": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "both var(--tw-scroll-snap-strictness)" }, ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" }, ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" } }) }, scrollSnapAlign: ({ addUtilities: r }) => { r({ ".snap-start": { "scroll-snap-align": "start" }, ".snap-end": { "scroll-snap-align": "end" }, ".snap-center": { "scroll-snap-align": "center" }, ".snap-align-none": { "scroll-snap-align": "none" } }) }, scrollSnapStop: ({ addUtilities: r }) => { r({ ".snap-normal": { "scroll-snap-stop": "normal" }, ".snap-always": { "scroll-snap-stop": "always" } }) }, scrollMargin: O("scrollMargin", [["scroll-m", ["scroll-margin"]], [["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]], ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]], [["scroll-mt", ["scroll-margin-top"]], ["scroll-mr", ["scroll-margin-right"]], ["scroll-mb", ["scroll-margin-bottom"]], ["scroll-ml", ["scroll-margin-left"]]]], { supportsNegativeValues: !0 }), scrollPadding: O("scrollPadding", [["scroll-p", ["scroll-padding"]], [["scroll-px", ["scroll-padding-left", "scroll-padding-right"]], ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]], [["scroll-pt", ["scroll-padding-top"]], ["scroll-pr", ["scroll-padding-right"]], ["scroll-pb", ["scroll-padding-bottom"]], ["scroll-pl", ["scroll-padding-left"]]]]), listStylePosition: ({ addUtilities: r }) => { r({ ".list-inside": { "list-style-position": "inside" }, ".list-outside": { "list-style-position": "outside" } }) }, listStyleType: O("listStyleType", [["list", ["listStyleType"]]]), appearance: ({ addUtilities: r }) => { r({ ".appearance-none": { appearance: "none" } }) }, columns: O("columns", [["columns", ["columns"]]]), breakBefore: ({ addUtilities: r }) => { r({ ".break-before-auto": { "break-before": "auto" }, ".break-before-avoid": { "break-before": "avoid" }, ".break-before-all": { "break-before": "all" }, ".break-before-avoid-page": { "break-before": "avoid-page" }, ".break-before-page": { "break-before": "page" }, ".break-before-left": { "break-before": "left" }, ".break-before-right": { "break-before": "right" }, ".break-before-column": { "break-before": "column" } }) }, breakInside: ({ addUtilities: r }) => { r({ ".break-inside-auto": { "break-inside": "auto" }, ".break-inside-avoid": { "break-inside": "avoid" }, ".break-inside-avoid-page": { "break-inside": "avoid-page" }, ".break-inside-avoid-column": { "break-inside": "avoid-column" } }) }, breakAfter: ({ addUtilities: r }) => { r({ ".break-after-auto": { "break-after": "auto" }, ".break-after-avoid": { "break-after": "avoid" }, ".break-after-all": { "break-after": "all" }, ".break-after-avoid-page": { "break-after": "avoid-page" }, ".break-after-page": { "break-after": "page" }, ".break-after-left": { "break-after": "left" }, ".break-after-right": { "break-after": "right" }, ".break-after-column": { "break-after": "column" } }) }, gridAutoColumns: O("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]), gridAutoFlow: ({ addUtilities: r }) => { r({ ".grid-flow-row": { gridAutoFlow: "row" }, ".grid-flow-col": { gridAutoFlow: "column" }, ".grid-flow-dense": { gridAutoFlow: "dense" }, ".grid-flow-row-dense": { gridAutoFlow: "row dense" }, ".grid-flow-col-dense": { gridAutoFlow: "column dense" } }) }, gridAutoRows: O("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]), gridTemplateColumns: O("gridTemplateColumns", [["grid-cols", ["gridTemplateColumns"]]]), gridTemplateRows: O("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]), flexDirection: ({ addUtilities: r }) => { r({ ".flex-row": { "flex-direction": "row" }, ".flex-row-reverse": { "flex-direction": "row-reverse" }, ".flex-col": { "flex-direction": "column" }, ".flex-col-reverse": { "flex-direction": "column-reverse" } }) }, flexWrap: ({ addUtilities: r }) => { r({ ".flex-wrap": { "flex-wrap": "wrap" }, ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" }, ".flex-nowrap": { "flex-wrap": "nowrap" } }) }, placeContent: ({ addUtilities: r }) => { r({ ".place-content-center": { "place-content": "center" }, ".place-content-start": { "place-content": "start" }, ".place-content-end": { "place-content": "end" }, ".place-content-between": { "place-content": "space-between" }, ".place-content-around": { "place-content": "space-around" }, ".place-content-evenly": { "place-content": "space-evenly" }, ".place-content-stretch": { "place-content": "stretch" } }) }, placeItems: ({ addUtilities: r }) => { r({ ".place-items-start": { "place-items": "start" }, ".place-items-end": { "place-items": "end" }, ".place-items-center": { "place-items": "center" }, ".place-items-stretch": { "place-items": "stretch" } }) }, alignContent: ({ addUtilities: r }) => { r({ ".content-center": { "align-content": "center" }, ".content-start": { "align-content": "flex-start" }, ".content-end": { "align-content": "flex-end" }, ".content-between": { "align-content": "space-between" }, ".content-around": { "align-content": "space-around" }, ".content-evenly": { "align-content": "space-evenly" } }) }, alignItems: ({ addUtilities: r }) => { r({ ".items-start": { "align-items": "flex-start" }, ".items-end": { "align-items": "flex-end" }, ".items-center": { "align-items": "center" }, ".items-baseline": { "align-items": "baseline" }, ".items-stretch": { "align-items": "stretch" } }) }, justifyContent: ({ addUtilities: r }) => { r({ ".justify-start": { "justify-content": "flex-start" }, ".justify-end": { "justify-content": "flex-end" }, ".justify-center": { "justify-content": "center" }, ".justify-between": { "justify-content": "space-between" }, ".justify-around": { "justify-content": "space-around" }, ".justify-evenly": { "justify-content": "space-evenly" } }) }, justifyItems: ({ addUtilities: r }) => { r({ ".justify-items-start": { "justify-items": "start" }, ".justify-items-end": { "justify-items": "end" }, ".justify-items-center": { "justify-items": "center" }, ".justify-items-stretch": { "justify-items": "stretch" } }) }, gap: O("gap", [["gap", ["gap"]], [["gap-x", ["columnGap"]], ["gap-y", ["rowGap"]]]]), space: ({ matchUtilities: r, addUtilities: e, theme: t }) => { r({ "space-x": i => (i = i === "0" ? "0px" : i, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "0", "margin-right": `calc(${i} * var(--tw-space-x-reverse))`, "margin-left": `calc(${i} * calc(1 - var(--tw-space-x-reverse)))` } }), "space-y": i => (i = i === "0" ? "0px" : i, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "0", "margin-top": `calc(${i} * calc(1 - var(--tw-space-y-reverse)))`, "margin-bottom": `calc(${i} * var(--tw-space-y-reverse))` } }) }, { values: t("space"), supportsNegativeValues: !0 }), e({ ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" }, ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" } }) }, divideWidth: ({ matchUtilities: r, addUtilities: e, theme: t }) => { r({ "divide-x": i => (i = i === "0" ? "0px" : i, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "0", "border-right-width": `calc(${i} * var(--tw-divide-x-reverse))`, "border-left-width": `calc(${i} * calc(1 - var(--tw-divide-x-reverse)))` } }), "divide-y": i => (i = i === "0" ? "0px" : i, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "0", "border-top-width": `calc(${i} * calc(1 - var(--tw-divide-y-reverse)))`, "border-bottom-width": `calc(${i} * var(--tw-divide-y-reverse))` } }) }, { values: t("divideWidth"), type: ["line-width", "length"] }), e({ ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "1" }, ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "1" } }) }, divideStyle: ({ addUtilities: r }) => { r({ ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" }, ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" }, ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" }, ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" }, ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" } }) }, divideColor: ({ matchUtilities: r, theme: e, corePlugins: t }) => { r({ divide: i => t("divideOpacity") ? { ["& > :not([hidden]) ~ :not([hidden])"]: te({ color: i, property: "border-color", variable: "--tw-divide-opacity" }) } : { ["& > :not([hidden]) ~ :not([hidden])"]: { "border-color": N(i) } } }, { values: (({ DEFAULT: i, ...s }) => s)(J(e("divideColor"))), type: "color" }) }, divideOpacity: ({ matchUtilities: r, theme: e }) => { r({ "divide-opacity": t => ({ ["& > :not([hidden]) ~ :not([hidden])"]: { "--tw-divide-opacity": t } }) }, { values: e("divideOpacity") }) }, placeSelf: ({ addUtilities: r }) => { r({ ".place-self-auto": { "place-self": "auto" }, ".place-self-start": { "place-self": "start" }, ".place-self-end": { "place-self": "end" }, ".place-self-center": { "place-self": "center" }, ".place-self-stretch": { "place-self": "stretch" } }) }, alignSelf: ({ addUtilities: r }) => { r({ ".self-auto": { "align-self": "auto" }, ".self-start": { "align-self": "flex-start" }, ".self-end": { "align-self": "flex-end" }, ".self-center": { "align-self": "center" }, ".self-stretch": { "align-self": "stretch" }, ".self-baseline": { "align-self": "baseline" } }) }, justifySelf: ({ addUtilities: r }) => { r({ ".justify-self-auto": { "justify-self": "auto" }, ".justify-self-start": { "justify-self": "start" }, ".justify-self-end": { "justify-self": "end" }, ".justify-self-center": { "justify-self": "center" }, ".justify-self-stretch": { "justify-self": "stretch" } }) }, overflow: ({ addUtilities: r }) => { r({ ".overflow-auto": { overflow: "auto" }, ".overflow-hidden": { overflow: "hidden" }, ".overflow-clip": { overflow: "clip" }, ".overflow-visible": { overflow: "visible" }, ".overflow-scroll": { overflow: "scroll" }, ".overflow-x-auto": { "overflow-x": "auto" }, ".overflow-y-auto": { "overflow-y": "auto" }, ".overflow-x-hidden": { "overflow-x": "hidden" }, ".overflow-y-hidden": { "overflow-y": "hidden" }, ".overflow-x-clip": { "overflow-x": "clip" }, ".overflow-y-clip": { "overflow-y": "clip" }, ".overflow-x-visible": { "overflow-x": "visible" }, ".overflow-y-visible": { "overflow-y": "visible" }, ".overflow-x-scroll": { "overflow-x": "scroll" }, ".overflow-y-scroll": { "overflow-y": "scroll" } }) }, overscrollBehavior: ({ addUtilities: r }) => { r({ ".overscroll-auto": { "overscroll-behavior": "auto" }, ".overscroll-contain": { "overscroll-behavior": "contain" }, ".overscroll-none": { "overscroll-behavior": "none" }, ".overscroll-y-auto": { "overscroll-behavior-y": "auto" }, ".overscroll-y-contain": { "overscroll-behavior-y": "contain" }, ".overscroll-y-none": { "overscroll-behavior-y": "none" }, ".overscroll-x-auto": { "overscroll-behavior-x": "auto" }, ".overscroll-x-contain": { "overscroll-behavior-x": "contain" }, ".overscroll-x-none": { "overscroll-behavior-x": "none" } }) }, scrollBehavior: ({ addUtilities: r }) => { r({ ".scroll-auto": { "scroll-behavior": "auto" }, ".scroll-smooth": { "scroll-behavior": "smooth" } }) }, textOverflow: ({ addUtilities: r }) => { r({ ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }, ".overflow-ellipsis": { "text-overflow": "ellipsis" }, ".text-ellipsis": { "text-overflow": "ellipsis" }, ".text-clip": { "text-overflow": "clip" } }) }, whitespace: ({ addUtilities: r }) => { r({ ".whitespace-normal": { "white-space": "normal" }, ".whitespace-nowrap": { "white-space": "nowrap" }, ".whitespace-pre": { "white-space": "pre" }, ".whitespace-pre-line": { "white-space": "pre-line" }, ".whitespace-pre-wrap": { "white-space": "pre-wrap" } }) }, wordBreak: ({ addUtilities: r }) => { r({ ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" }, ".break-words": { "overflow-wrap": "break-word" }, ".break-all": { "word-break": "break-all" } }) }, borderRadius: O("borderRadius", [["rounded", ["border-radius"]], [["rounded-t", ["border-top-left-radius", "border-top-right-radius"]], ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]], ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]], ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]], [["rounded-tl", ["border-top-left-radius"]], ["rounded-tr", ["border-top-right-radius"]], ["rounded-br", ["border-bottom-right-radius"]], ["rounded-bl", ["border-bottom-left-radius"]]]]), borderWidth: O("borderWidth", [["border", [["@defaults border-width", {}], "border-width"]], [["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]], ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]], [["border-t", [["@defaults border-width", {}], "border-top-width"]], ["border-r", [["@defaults border-width", {}], "border-right-width"]], ["border-b", [["@defaults border-width", {}], "border-bottom-width"]], ["border-l", [["@defaults border-width", {}], "border-left-width"]]]], { type: ["line-width", "length"] }), borderStyle: ({ addUtilities: r }) => { r({ ".border-solid": { "border-style": "solid" }, ".border-dashed": { "border-style": "dashed" }, ".border-dotted": { "border-style": "dotted" }, ".border-double": { "border-style": "double" }, ".border-hidden": { "border-style": "hidden" }, ".border-none": { "border-style": "none" } }) }, borderColor: ({ matchUtilities: r, theme: e, corePlugins: t }) => { r({ border: i => t("borderOpacity") ? te({ color: i, property: "border-color", variable: "--tw-border-opacity" }) : { "border-color": N(i) } }, { values: (({ DEFAULT: i, ...s }) => s)(J(e("borderColor"))), type: ["color"] }), r({ "border-x": i => t("borderOpacity") ? te({ color: i, property: ["border-left-color", "border-right-color"], variable: "--tw-border-opacity" }) : { "border-left-color": N(i), "border-right-color": N(i) }, "border-y": i => t("borderOpacity") ? te({ color: i, property: ["border-top-color", "border-bottom-color"], variable: "--tw-border-opacity" }) : { "border-top-color": N(i), "border-bottom-color": N(i) } }, { values: (({ DEFAULT: i, ...s }) => s)(J(e("borderColor"))), type: "color" }), r({ "border-t": i => t("borderOpacity") ? te({ color: i, property: "border-top-color", variable: "--tw-border-opacity" }) : { "border-top-color": N(i) }, "border-r": i => t("borderOpacity") ? te({ color: i, property: "border-right-color", variable: "--tw-border-opacity" }) : { "border-right-color": N(i) }, "border-b": i => t("borderOpacity") ? te({ color: i, property: "border-bottom-color", variable: "--tw-border-opacity" }) : { "border-bottom-color": N(i) }, "border-l": i => t("borderOpacity") ? te({ color: i, property: "border-left-color", variable: "--tw-border-opacity" }) : { "border-left-color": N(i) } }, { values: (({ DEFAULT: i, ...s }) => s)(J(e("borderColor"))), type: "color" }) }, borderOpacity: O("borderOpacity", [["border-opacity", ["--tw-border-opacity"]]]), backgroundColor: ({ matchUtilities: r, theme: e, corePlugins: t }) => { r({ bg: i => t("backgroundOpacity") ? te({ color: i, property: "background-color", variable: "--tw-bg-opacity" }) : { "background-color": N(i) } }, { values: J(e("backgroundColor")), type: "color" }) }, backgroundOpacity: O("backgroundOpacity", [["bg-opacity", ["--tw-bg-opacity"]]]), backgroundImage: O("backgroundImage", [["bg", ["background-image"]]], { type: ["lookup", "image", "url"] }), gradientColorStops: (() => { function r(e) { return Ce(e, 0, "rgb(255 255 255 / 0)") } return function ({ matchUtilities: e, theme: t }) { let i = { values: J(t("gradientColorStops")), type: ["color", "any"] }; e({ from: s => { let n = r(s); return { "--tw-gradient-from": N(s, "from"), "--tw-gradient-to": n, "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)" } } }, i), e({ via: s => ({ "--tw-gradient-to": r(s), "--tw-gradient-stops": `var(--tw-gradient-from), ${N(s, "via")}, var(--tw-gradient-to)` }) }, i), e({ to: s => ({ "--tw-gradient-to": N(s, "to") }) }, i) } })(), boxDecorationBreak: ({ addUtilities: r }) => { r({ ".decoration-slice": { "box-decoration-break": "slice" }, ".decoration-clone": { "box-decoration-break": "clone" }, ".box-decoration-slice": { "box-decoration-break": "slice" }, ".box-decoration-clone": { "box-decoration-break": "clone" } }) }, backgroundSize: O("backgroundSize", [["bg", ["background-size"]]], { type: ["lookup", "length", "percentage"] }), backgroundAttachment: ({ addUtilities: r }) => { r({ ".bg-fixed": { "background-attachment": "fixed" }, ".bg-local": { "background-attachment": "local" }, ".bg-scroll": { "background-attachment": "scroll" } }) }, backgroundClip: ({ addUtilities: r }) => { r({ ".bg-clip-border": { "background-clip": "border-box" }, ".bg-clip-padding": { "background-clip": "padding-box" }, ".bg-clip-content": { "background-clip": "content-box" }, ".bg-clip-text": { "background-clip": "text" } }) }, backgroundPosition: O("backgroundPosition", [["bg", ["background-position"]]], { type: ["lookup", "position"] }), backgroundRepeat: ({ addUtilities: r }) => { r({ ".bg-repeat": { "background-repeat": "repeat" }, ".bg-no-repeat": { "background-repeat": "no-repeat" }, ".bg-repeat-x": { "background-repeat": "repeat-x" }, ".bg-repeat-y": { "background-repeat": "repeat-y" }, ".bg-repeat-round": { "background-repeat": "round" }, ".bg-repeat-space": { "background-repeat": "space" } }) }, backgroundOrigin: ({ addUtilities: r }) => { r({ ".bg-origin-border": { "background-origin": "border-box" }, ".bg-origin-padding": { "background-origin": "padding-box" }, ".bg-origin-content": { "background-origin": "content-box" } }) }, fill: ({ matchUtilities: r, theme: e }) => { r({ fill: t => ({ fill: N(t) }) }, { values: J(e("fill")), type: ["color", "any"] }) }, stroke: ({ matchUtilities: r, theme: e }) => { r({ stroke: t => ({ stroke: N(t) }) }, { values: J(e("stroke")), type: ["color", "url"] }) }, strokeWidth: O("strokeWidth", [["stroke", ["stroke-width"]]], { type: ["length", "number", "percentage"] }), objectFit: ({ addUtilities: r }) => { r({ ".object-contain": { "object-fit": "contain" }, ".object-cover": { "object-fit": "cover" }, ".object-fill": { "object-fit": "fill" }, ".object-none": { "object-fit": "none" }, ".object-scale-down": { "object-fit": "scale-down" } }) }, objectPosition: O("objectPosition", [["object", ["object-position"]]]), padding: O("padding", [["p", ["padding"]], [["px", ["padding-left", "padding-right"]], ["py", ["padding-top", "padding-bottom"]]], [["pt", ["padding-top"]], ["pr", ["padding-right"]], ["pb", ["padding-bottom"]], ["pl", ["padding-left"]]]]), textAlign: ({ addUtilities: r }) => { r({ ".text-left": { "text-align": "left" }, ".text-center": { "text-align": "center" }, ".text-right": { "text-align": "right" }, ".text-justify": { "text-align": "justify" }, ".text-start": { "text-align": "start" }, ".text-end": { "text-align": "end" } }) }, textIndent: O("textIndent", [["indent", ["text-indent"]]], { supportsNegativeValues: !0 }), verticalAlign: ({ addUtilities: r, matchUtilities: e }) => { r({ ".align-baseline": { "vertical-align": "baseline" }, ".align-top": { "vertical-align": "top" }, ".align-middle": { "vertical-align": "middle" }, ".align-bottom": { "vertical-align": "bottom" }, ".align-text-top": { "vertical-align": "text-top" }, ".align-text-bottom": { "vertical-align": "text-bottom" }, ".align-sub": { "vertical-align": "sub" }, ".align-super": { "vertical-align": "super" } }), e({ align: t => ({ "vertical-align": t }) }) }, fontFamily: O("fontFamily", [["font", ["fontFamily"]]], { type: ["lookup", "generic-name", "family-name"] }), fontSize: ({ matchUtilities: r, theme: e }) => { r({ text: t => { let [i, s] = Array.isArray(t) ? t : [t], { lineHeight: n, letterSpacing: a } = Pe(s) ? s : { lineHeight: s }; return { "font-size": i, ...n === void 0 ? {} : { "line-height": n }, ...a === void 0 ? {} : { "letter-spacing": a } } } }, { values: e("fontSize"), type: ["absolute-size", "relative-size", "length", "percentage"] }) }, fontWeight: O("fontWeight", [["font", ["fontWeight"]]], { type: ["lookup", "number"] }), textTransform: ({ addUtilities: r }) => { r({ ".uppercase": { "text-transform": "uppercase" }, ".lowercase": { "text-transform": "lowercase" }, ".capitalize": { "text-transform": "capitalize" }, ".normal-case": { "text-transform": "none" } }) }, fontStyle: ({ addUtilities: r }) => { r({ ".italic": { "font-style": "italic" }, ".not-italic": { "font-style": "normal" } }) }, fontVariantNumeric: ({ addDefaults: r, addUtilities: e }) => { let t = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)"; r("font-variant-numeric", { "--tw-ordinal": " ", "--tw-slashed-zero": " ", "--tw-numeric-figure": " ", "--tw-numeric-spacing": " ", "--tw-numeric-fraction": " " }), e({ ".normal-nums": { "font-variant-numeric": "normal" }, ".ordinal": { "@defaults font-variant-numeric": {}, "--tw-ordinal": "ordinal", "font-variant-numeric": t }, ".slashed-zero": { "@defaults font-variant-numeric": {}, "--tw-slashed-zero": "slashed-zero", "font-variant-numeric": t }, ".lining-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "lining-nums", "font-variant-numeric": t }, ".oldstyle-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "oldstyle-nums", "font-variant-numeric": t }, ".proportional-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "proportional-nums", "font-variant-numeric": t }, ".tabular-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "tabular-nums", "font-variant-numeric": t }, ".diagonal-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "diagonal-fractions", "font-variant-numeric": t }, ".stacked-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "stacked-fractions", "font-variant-numeric": t } }) }, lineHeight: O("lineHeight", [["leading", ["lineHeight"]]]), letterSpacing: O("letterSpacing", [["tracking", ["letterSpacing"]]], { supportsNegativeValues: !0 }), textColor: ({ matchUtilities: r, theme: e, corePlugins: t }) => { r({ text: i => t("textOpacity") ? te({ color: i, property: "color", variable: "--tw-text-opacity" }) : { color: N(i) } }, { values: J(e("textColor")), type: "color" }) }, textOpacity: O("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]), textDecoration: ({ addUtilities: r }) => { r({ ".underline": { "text-decoration-line": "underline" }, ".overline": { "text-decoration-line": "overline" }, ".line-through": { "text-decoration-line": "line-through" }, ".no-underline": { "text-decoration-line": "none" } }) }, textDecorationColor: ({ matchUtilities: r, theme: e }) => { r({ decoration: t => ({ "text-decoration-color": N(t) }) }, { values: J(e("textDecorationColor")), type: ["color"] }) }, textDecorationStyle: ({ addUtilities: r }) => { r({ ".decoration-solid": { "text-decoration-style": "solid" }, ".decoration-double": { "text-decoration-style": "double" }, ".decoration-dotted": { "text-decoration-style": "dotted" }, ".decoration-dashed": { "text-decoration-style": "dashed" }, ".decoration-wavy": { "text-decoration-style": "wavy" } }) }, textDecorationThickness: O("textDecorationThickness", [["decoration", ["text-decoration-thickness"]]], { type: ["length", "percentage"] }), textUnderlineOffset: O("textUnderlineOffset", [["underline-offset", ["text-underline-offset"]]], { type: ["length", "percentage"] }), fontSmoothing: ({ addUtilities: r }) => { r({ ".antialiased": { "-webkit-font-smoothing": "antialiased", "-moz-osx-font-smoothing": "grayscale" }, ".subpixel-antialiased": { "-webkit-font-smoothing": "auto", "-moz-osx-font-smoothing": "auto" } }) }, placeholderColor: ({ matchUtilities: r, theme: e, corePlugins: t }) => { r({ placeholder: i => t("placeholderOpacity") ? { "&::placeholder": te({ color: i, property: "color", variable: "--tw-placeholder-opacity" }) } : { "&::placeholder": { color: N(i) } } }, { values: J(e("placeholderColor")), type: ["color", "any"] }) }, placeholderOpacity: ({ matchUtilities: r, theme: e }) => { r({ "placeholder-opacity": t => ({ ["&::placeholder"]: { "--tw-placeholder-opacity": t } }) }, { values: e("placeholderOpacity") }) }, caretColor: ({ matchUtilities: r, theme: e }) => { r({ caret: t => ({ "caret-color": N(t) }) }, { values: J(e("caretColor")), type: ["color", "any"] }) }, accentColor: ({ matchUtilities: r, theme: e }) => { r({ accent: t => ({ "accent-color": N(t) }) }, { values: J(e("accentColor")), type: ["color", "any"] }) }, opacity: O("opacity", [["opacity", ["opacity"]]]), backgroundBlendMode: ({ addUtilities: r }) => { r({ ".bg-blend-normal": { "background-blend-mode": "normal" }, ".bg-blend-multiply": { "background-blend-mode": "multiply" }, ".bg-blend-screen": { "background-blend-mode": "screen" }, ".bg-blend-overlay": { "background-blend-mode": "overlay" }, ".bg-blend-darken": { "background-blend-mode": "darken" }, ".bg-blend-lighten": { "background-blend-mode": "lighten" }, ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" }, ".bg-blend-color-burn": { "background-blend-mode": "color-burn" }, ".bg-blend-hard-light": { "background-blend-mode": "hard-light" }, ".bg-blend-soft-light": { "background-blend-mode": "soft-light" }, ".bg-blend-difference": { "background-blend-mode": "difference" }, ".bg-blend-exclusion": { "background-blend-mode": "exclusion" }, ".bg-blend-hue": { "background-blend-mode": "hue" }, ".bg-blend-saturation": { "background-blend-mode": "saturation" }, ".bg-blend-color": { "background-blend-mode": "color" }, ".bg-blend-luminosity": { "background-blend-mode": "luminosity" } }) }, mixBlendMode: ({ addUtilities: r }) => { r({ ".mix-blend-normal": { "mix-blend-mode": "normal" }, ".mix-blend-multiply": { "mix-blend-mode": "multiply" }, ".mix-blend-screen": { "mix-blend-mode": "screen" }, ".mix-blend-overlay": { "mix-blend-mode": "overlay" }, ".mix-blend-darken": { "mix-blend-mode": "darken" }, ".mix-blend-lighten": { "mix-blend-mode": "lighten" }, ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" }, ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" }, ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" }, ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" }, ".mix-blend-difference": { "mix-blend-mode": "difference" }, ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" }, ".mix-blend-hue": { "mix-blend-mode": "hue" }, ".mix-blend-saturation": { "mix-blend-mode": "saturation" }, ".mix-blend-color": { "mix-blend-mode": "color" }, ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" }, ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" } }) }, boxShadow: (() => { let r = Me("boxShadow"), e = ["var(--tw-ring-offset-shadow, 0 0 #0000)", "var(--tw-ring-shadow, 0 0 #0000)", "var(--tw-shadow)"].join(", "); return function ({ matchUtilities: t, addDefaults: i, theme: s }) { i(" box-shadow", { "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), t({ shadow: n => { n = r(n); let a = wi(n); for (let o of a) !o.valid || (o.color = "var(--tw-shadow-color)"); return { "@defaults box-shadow": {}, "--tw-shadow": n === "none" ? "0 0 #0000" : n, "--tw-shadow-colored": n === "none" ? "0 0 #0000" : ef(a), "box-shadow": e } } }, { values: s("boxShadow"), type: ["shadow"] }) } })(), boxShadowColor: ({ matchUtilities: r, theme: e }) => { r({ shadow: t => ({ "--tw-shadow-color": N(t), "--tw-shadow": "var(--tw-shadow-colored)" }) }, { values: J(e("boxShadowColor")), type: ["color"] }) }, outlineStyle: ({ addUtilities: r }) => { r({ ".outline-none": { outline: "2px solid transparent", "outline-offset": "2px" }, ".outline": { "outline-style": "solid" }, ".outline-dashed": { "outline-style": "dashed" }, ".outline-dotted": { "outline-style": "dotted" }, ".outline-double": { "outline-style": "double" }, ".outline-hidden": { "outline-style": "hidden" } }) }, outlineWidth: O("outlineWidth", [["outline", ["outline-width"]]], { type: ["length", "number", "percentage"] }), outlineOffset: O("outlineOffset", [["outline-offset", ["outline-offset"]]], { type: ["length", "number", "percentage"] }), outlineColor: ({ matchUtilities: r, theme: e }) => { r({ outline: t => ({ "outline-color": N(t) }) }, { values: J(e("outlineColor")), type: ["color"] }) }, ringWidth: ({ matchUtilities: r, addDefaults: e, addUtilities: t, theme: i, config: s }) => { let n = (() => { if (K(s(), "respectDefaultRingColorOpacity")) return i("ringColor.DEFAULT"); let a = i("ringOpacity.DEFAULT", "0.5"); return i("ringColor")?.DEFAULT ? Ce(i("ringColor")?.DEFAULT, a, `rgb(147 197 253 / ${a})`) : `rgb(147 197 253 / ${a})` })(); e("ring-width", { "--tw-ring-inset": " ", "--tw-ring-offset-width": i("ringOffsetWidth.DEFAULT", "0px"), "--tw-ring-offset-color": i("ringOffsetColor.DEFAULT", "#fff"), "--tw-ring-color": n, "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), r({ ring: a => ({ "@defaults ring-width": {}, "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)", "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${a} + var(--tw-ring-offset-width)) var(--tw-ring-color)`, "box-shadow": ["var(--tw-ring-offset-shadow)", "var(--tw-ring-shadow)", "var(--tw-shadow, 0 0 #0000)"].join(", ") }) }, { values: i("ringWidth"), type: "length" }), t({ ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" } }) }, ringColor: ({ matchUtilities: r, theme: e, corePlugins: t }) => { r({ ring: i => t("ringOpacity") ? te({ color: i, property: "--tw-ring-color", variable: "--tw-ring-opacity" }) : { "--tw-ring-color": N(i) } }, { values: Object.fromEntries(Object.entries(J(e("ringColor"))).filter(([i]) => i !== "DEFAULT")), type: "color" }) }, ringOpacity: r => { let { config: e } = r; return O("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], { filterDefault: !K(e(), "respectDefaultRingColorOpacity") })(r) }, ringOffsetWidth: O("ringOffsetWidth", [["ring-offset", ["--tw-ring-offset-width"]]], { type: "length" }), ringOffsetColor: ({ matchUtilities: r, theme: e }) => { r({ "ring-offset": t => ({ "--tw-ring-offset-color": N(t) }) }, { values: J(e("ringOffsetColor")), type: "color" }) }, blur: ({ matchUtilities: r, theme: e }) => { r({ blur: t => ({ "--tw-blur": `blur(${t})`, "@defaults filter": {}, filter: Ae }) }, { values: e("blur") }) }, brightness: ({ matchUtilities: r, theme: e }) => { r({ brightness: t => ({ "--tw-brightness": `brightness(${t})`, "@defaults filter": {}, filter: Ae }) }, { values: e("brightness") }) }, contrast: ({ matchUtilities: r, theme: e }) => { r({ contrast: t => ({ "--tw-contrast": `contrast(${t})`, "@defaults filter": {}, filter: Ae }) }, { values: e("contrast") }) }, dropShadow: ({ matchUtilities: r, theme: e }) => { r({ "drop-shadow": t => ({ "--tw-drop-shadow": Array.isArray(t) ? t.map(i => `drop-shadow(${i})`).join(" ") : `drop-shadow(${t})`, "@defaults filter": {}, filter: Ae }) }, { values: e("dropShadow") }) }, grayscale: ({ matchUtilities: r, theme: e }) => { r({ grayscale: t => ({ "--tw-grayscale": `grayscale(${t})`, "@defaults filter": {}, filter: Ae }) }, { values: e("grayscale") }) }, hueRotate: ({ matchUtilities: r, theme: e }) => { r({ "hue-rotate": t => ({ "--tw-hue-rotate": `hue-rotate(${t})`, "@defaults filter": {}, filter: Ae }) }, { values: e("hueRotate"), supportsNegativeValues: !0 }) }, invert: ({ matchUtilities: r, theme: e }) => { r({ invert: t => ({ "--tw-invert": `invert(${t})`, "@defaults filter": {}, filter: Ae }) }, { values: e("invert") }) }, saturate: ({ matchUtilities: r, theme: e }) => { r({ saturate: t => ({ "--tw-saturate": `saturate(${t})`, "@defaults filter": {}, filter: Ae }) }, { values: e("saturate") }) }, sepia: ({ matchUtilities: r, theme: e }) => { r({ sepia: t => ({ "--tw-sepia": `sepia(${t})`, "@defaults filter": {}, filter: Ae }) }, { values: e("sepia") }) }, filter: ({ addDefaults: r, addUtilities: e }) => { r("filter", { "--tw-blur": " ", "--tw-brightness": " ", "--tw-contrast": " ", "--tw-grayscale": " ", "--tw-hue-rotate": " ", "--tw-invert": " ", "--tw-saturate": " ", "--tw-sepia": " ", "--tw-drop-shadow": " " }), e({ ".filter": { "@defaults filter": {}, filter: Ae }, ".filter-none": { filter: "none" } }) }, backdropBlur: ({ matchUtilities: r, theme: e }) => { r({ "backdrop-blur": t => ({ "--tw-backdrop-blur": `blur(${t})`, "@defaults backdrop-filter": {}, "backdrop-filter": Oe }) }, { values: e("backdropBlur") }) }, backdropBrightness: ({ matchUtilities: r, theme: e }) => { r({ "backdrop-brightness": t => ({ "--tw-backdrop-brightness": `brightness(${t})`, "@defaults backdrop-filter": {}, "backdrop-filter": Oe }) }, { values: e("backdropBrightness") }) }, backdropContrast: ({ matchUtilities: r, theme: e }) => { r({ "backdrop-contrast": t => ({ "--tw-backdrop-contrast": `contrast(${t})`, "@defaults backdrop-filter": {}, "backdrop-filter": Oe }) }, { values: e("backdropContrast") }) }, backdropGrayscale: ({ matchUtilities: r, theme: e }) => { r({ "backdrop-grayscale": t => ({ "--tw-backdrop-grayscale": `grayscale(${t})`, "@defaults backdrop-filter": {}, "backdrop-filter": Oe }) }, { values: e("backdropGrayscale") }) }, backdropHueRotate: ({ matchUtilities: r, theme: e }) => { r({ "backdrop-hue-rotate": t => ({ "--tw-backdrop-hue-rotate": `hue-rotate(${t})`, "@defaults backdrop-filter": {}, "backdrop-filter": Oe }) }, { values: e("backdropHueRotate"), supportsNegativeValues: !0 }) }, backdropInvert: ({ matchUtilities: r, theme: e }) => { r({ "backdrop-invert": t => ({ "--tw-backdrop-invert": `invert(${t})`, "@defaults backdrop-filter": {}, "backdrop-filter": Oe }) }, { values: e("backdropInvert") }) }, backdropOpacity: ({ matchUtilities: r, theme: e }) => { r({ "backdrop-opacity": t => ({ "--tw-backdrop-opacity": `opacity(${t})`, "@defaults backdrop-filter": {}, "backdrop-filter": Oe }) }, { values: e("backdropOpacity") }) }, backdropSaturate: ({ matchUtilities: r, theme: e }) => { r({ "backdrop-saturate": t => ({ "--tw-backdrop-saturate": `saturate(${t})`, "@defaults backdrop-filter": {}, "backdrop-filter": Oe }) }, { values: e("backdropSaturate") }) }, backdropSepia: ({ matchUtilities: r, theme: e }) => { r({ "backdrop-sepia": t => ({ "--tw-backdrop-sepia": `sepia(${t})`, "@defaults backdrop-filter": {}, "backdrop-filter": Oe }) }, { values: e("backdropSepia") }) }, backdropFilter: ({ addDefaults: r, addUtilities: e }) => { r("backdrop-filter", { "--tw-backdrop-blur": " ", "--tw-backdrop-brightness": " ", "--tw-backdrop-contrast": " ", "--tw-backdrop-grayscale": " ", "--tw-backdrop-hue-rotate": " ", "--tw-backdrop-invert": " ", "--tw-backdrop-opacity": " ", "--tw-backdrop-saturate": " ", "--tw-backdrop-sepia": " " }), e({ ".backdrop-filter": { "@defaults backdrop-filter": {}, "backdrop-filter": Oe }, ".backdrop-filter-none": { "backdrop-filter": "none" } }) }, transitionProperty: ({ matchUtilities: r, theme: e }) => { let t = e("transitionTimingFunction.DEFAULT"), i = e("transitionDuration.DEFAULT"); r({ transition: s => ({ "transition-property": s, ...s === "none" ? {} : { "transition-timing-function": t, "transition-duration": i } }) }, { values: e("transitionProperty") }) }, transitionDelay: O("transitionDelay", [["delay", ["transitionDelay"]]]), transitionDuration: O("transitionDuration", [["duration", ["transitionDuration"]]], { filterDefault: !0 }), transitionTimingFunction: O("transitionTimingFunction", [["ease", ["transitionTimingFunction"]]], { filterDefault: !0 }), willChange: O("willChange", [["will-change", ["will-change"]]]), content: O("content", [["content", ["--tw-content", ["content", "var(--tw-content)"]]]]) } }); function Et(r) { let e = [], t = !1; for (let i = 0; i < r.length; i++) { let s = r[i]; if (s === ":" && !t && e.length === 0) return !1; if (Tk.has(s) && r[i - 1] !== "\\" && (t = !t), !t && r[i - 1] !== "\\") { if (Ip.has(s)) e.push(s); else if (Rp.has(s)) { let n = Rp.get(s); if (e.length <= 0 || e.pop() !== n) return !1 } } } return !(e.length > 0) } var Ip, Rp, Tk, Aa = C(() => { l(); Ip = new Map([["{", "}"], ["[", "]"], ["(", ")"]]), Rp = new Map(Array.from(Ip.entries()).map(([r, e]) => [e, r])), Tk = new Set(['"', "'", "`"]) }); function Np(r, ...e) { for (let t of e) { let i = Bp(t, is); if (i !== null && Bp(r, is, i) !== null) { let n = `${is}(${i})`, a = t.indexOf(n), o = t.slice(a + n.length).split(" ")[0]; r = r.replace(n, n + o); continue } r = t.replace(Lp, r) } return r } function Fp(r, { selector: e, candidate: t, context: i, base: s = t.split(new RegExp(`\\${i?.tailwindConfig?.separator ?? ":"}(?![^[]*\\])`)).pop() }) { let n = (0, Oa.default)().astSync(e); i?.tailwindConfig?.prefix && (r = At(i.tailwindConfig.prefix, r)), r = r.replace(Lp, `.${fe(t)}`); let a = (0, Oa.default)().astSync(r); n.each(u => { u.some(c => c.type === "class" && c.value === s) || u.remove() }), n.walkClasses(u => { u.raws && u.value.includes(s) && (u.raws.value = fe((0, Mp.default)(u.raws.value))) }), n.walkClasses(u => { u.value === s && u.replaceWith(...a.nodes) }); function o(u) { let f = []; for (let c of u.nodes) Ea(c) && (f.push(c), u.removeChild(c)), c?.nodes && f.push(...o(c)); return f } return n.each(u => { u.walkPseudos(c => { Pk.has(c.value) && c.replaceWith(c.nodes) }); let f = o(u); f.length > 0 && u.nodes.push(f.sort(Ik)) }), n.toString() } function Ik(r, e) { return r.type !== "pseudo" && e.type !== "pseudo" || r.type === "combinator" ^ e.type === "combinator" ? 0 : r.type === "pseudo" ^ e.type === "pseudo" ? (r.type === "pseudo") - (e.type === "pseudo") : Ea(r) - Ea(e) } function Ea(r) { return r.type !== "pseudo" || qk.includes(r.value) ? !1 : r.value.startsWith("::") || Dk.includes(r.value) } function Bp(r, e, t) { let i = r.indexOf(t ? `${e}(${t})` : e); if (i === -1) return null; i += e.length + 1; let s = "", n = 0; for (let a of r.slice(i)) if (a !== "(" && a !== ")") s += a; else if (a === "(") s += a, n++; else if (a === ")") { if (--n < 0) break; s += a } return s } var Oa, Mp, is, Lp, Pk, Dk, qk, zp = C(() => { l(); Oa = H(Se()), Mp = H(ii()); Ot(); Xi(); is = ":merge", Lp = "&", Pk = new Set([is]); Dk = [":before", ":after", ":first-line", ":first-letter"], qk = ["::file-selector-button"] }); function Mk(r) { return Rk.transformSync(r) } function* Lk(r) { let e = 1 / 0; for (; e >= 0;) { let t; if (e === 1 / 0 && r.endsWith("]")) { let n = r.indexOf("["); t = ["-", "/"].includes(r[n - 1]) ? n - 1 : -1 } else t = r.lastIndexOf("-", e); if (t < 0) break; let i = r.slice(0, t), s = r.slice(t + 1); yield [i, s], e = t - 1 } } function Nk(r, e) { if (r.length === 0 || e.tailwindConfig.prefix === "") return r; for (let t of r) { let [i] = t; if (i.options.respectPrefix) { let s = U.root({ nodes: [t[1].clone()] }), n = t[1].raws.tailwind.classCandidate; s.walkRules(a => { let o = n.startsWith("-"); a.selector = At(e.tailwindConfig.prefix, a.selector, o) }), t[1] = s.nodes[0] } } return r } function Fk(r, e) { if (r.length === 0) return r; let t = []; for (let [i, s] of r) { let n = U.root({ nodes: [s.clone()] }); n.walkRules(a => { a.selector = mf(a.selector, o => o === e ? `!${o}` : o), a.walkDecls(o => o.important = !0) }), t.push([{ ...i, important: !0 }, n.nodes[0]]) } return t } function Bk(r, e, t) { if (e.length === 0) return e; let i; if (r.endsWith("]") && !r.startsWith("[") && (i = r.slice(r.lastIndexOf("[") + 1, -1), r = r.slice(0, r.indexOf(i) - 1 - 1)), jp(r) && !t.variantMap.has(r)) { let s = oe(r.slice(1, -1)); if (!os(s)) return []; let n = $r(s), a = Array.from(t.variantOrder.values()).pop() << 1n; t.variantMap.set(r, [[a, n]]), t.variantOrder.set(r, a) } if (t.variantMap.has(r)) { let s = t.variantMap.get(r).slice(), n = []; for (let [a, o] of e) { if (a.layer === "user") continue; let u = U.root({ nodes: [o.clone()] }); for (let [f, c, h] of s) { let y = function () { p.raws.neededBackup || (p.raws.neededBackup = !0, p.walkRules(k => k.raws.originalSelector = k.selector)) }, v = function (k) { return y(), p.each(T => { T.type === "rule" && (T.selectors = T.selectors.map(P => k({ get className() { return Mk(P) }, selector: P }))) }), p }, p = h ?? u.clone(), d = [], b = c({ get container() { return y(), p }, separator: t.tailwindConfig.separator, modifySelectors: v, wrap(k) { let T = p.nodes; p.removeAll(), k.append(T), p.append(k) }, format(k) { d.push(k) }, args: i }); if (Array.isArray(b)) { for (let [k, T] of b.entries()) s.push([f | BigInt(k << b.length), T, p.clone()]); continue } if (typeof b == "string" && d.push(b), b === null) continue; p.raws.neededBackup && (delete p.raws.neededBackup, p.walkRules(k => { let T = k.raws.originalSelector; if (!T || (delete k.raws.originalSelector, T === k.selector)) return; let P = k.selector, R = (0, Ta.default)(Y => { Y.walkClasses(L => { L.value = `${r}${t.tailwindConfig.separator}${L.value}` }) }).processSync(T); d.push(P.replace(R, "&")), k.selector = T })), p.nodes[0].raws.tailwind = { ...p.nodes[0].raws.tailwind, parentLayer: a.layer }; let x = [{ ...a, sort: f | a.sort, collectedFormats: (a.collectedFormats ?? []).concat(d) }, p.nodes[0]]; n.push(x) } } return n } return [] } function Pa(r, e, t = {}) { return !Pe(r) && !Array.isArray(r) ? [[r], t] : Array.isArray(r) ? Pa(r[0], e, r[1]) : (e.has(r) || e.set(r, _t(r)), [e.get(r), t]) } function $k(r) { return zk.test(r) } function jk(r) { if (!r.includes("://")) return !1; try { let e = new URL(r); return e.scheme !== "" && e.host !== "" } catch (e) { return !1 } } function Uk(r) { let e = !0; return r.walkDecls(t => { if (!$p(t.name, t.value)) return e = !1, !1 }), e } function $p(r, e) { if (jk(`${r}:${e}`)) return !1; try { return U.parse(`a{${r}:${e}}`).toResult(), !0 } catch (t) { return !1 } } function Vk(r, e) { let [, t, i] = r.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/) ?? []; if (i === void 0 || !$k(t) || !Et(i)) return null; let s = oe(i); return $p(t, s) ? [[{ sort: e.arbitraryPropertiesSort, layer: "utilities" }, () => ({ [Sa(r)]: { [t]: s } })]] : null } function* Wk(r, e) { e.candidateRuleMap.has(r) && (yield [e.candidateRuleMap.get(r), "DEFAULT"]), yield* function* (o) { o !== null && (yield [o, "DEFAULT"]) }(Vk(r, e)); let t = r, i = !1, s = e.tailwindConfig.prefix, n = s.length, a = t.startsWith(s) || t.startsWith(`-${s}`); t[n] === "-" && a && (i = !0, t = s + t.slice(n + 1)), i && e.candidateRuleMap.has(t) && (yield [e.candidateRuleMap.get(t), "-DEFAULT"]); for (let [o, u] of Lk(t)) e.candidateRuleMap.has(o) && (yield [e.candidateRuleMap.get(o), i ? `-${u}` : u]) } function Gk(r, e) { return r === Ie ? [Ie] : Array.from(vr(r, e)) } function* Hk(r, e) { for (let t of r) t[1].raws.tailwind = { ...t[1].raws.tailwind, classCandidate: e }, yield t } function* ss(r, e, t = r) {
                let i = e.tailwindConfig.separator, [s, ...n] = Gk(r, i).reverse(), a = !1; if (s.startsWith("!") && (a = !0, s = s.slice(1)), K(e.tailwindConfig, "variantGrouping") && s.startsWith("(") && s.endsWith(")")) { let o = n.slice().reverse().join(i); for (let u of vr(s.slice(1, -1), ",")) yield* ss(o + i + u, e, t) } for (let o of Wk(s, e)) {
                    let u = [], f = new Map, [c, h] = o, p = c.length === 1; for (let [d, y] of c) { let v = []; if (typeof y == "function") for (let b of [].concat(y(h, { isOnlyPlugin: p }))) { let [x, k] = Pa(b, e.postCssNodeCache); for (let T of x) v.push([{ ...d, options: { ...d.options, ...k } }, T]) } else if (h === "DEFAULT" || h === "-DEFAULT") { let b = y, [x, k] = Pa(b, e.postCssNodeCache); for (let T of x) v.push([{ ...d, options: { ...d.options, ...k } }, T]) } v.length > 0 && (f.set(v, d.options?.type), u.push(v)) } if (jp(h)) {
                        if (u.length > 1) {
                            let d = u.map(v => new Set([...f.get(v) ?? []])); for (let v of d) for (let b of v) { let x = !1; for (let k of d) v !== k && k.has(b) && (k.delete(b), x = !0); x && v.delete(b) } let y = []; for (let [v, b] of d.entries()) for (let x of b) {
                                let k = u[v].map(([, T]) => T).flat().map(T => T.toString().split(`
`).slice(1, -1).map(P => P.trim()).map(P => `      ${P}`).join(`
`)).join(`

`); y.push(`  Use \`${r.replace("[", `[${x}:`)}\` for \`${k.trim()}\``); break
                            } V.warn([`The class \`${r}\` is ambiguous and matches multiple utilities.`, ...y, `If this is content and not a class, replace it with \`${r.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`]); continue
                        } u = u.map(d => d.filter(y => Uk(y[1])))
                    } u = u.flat(), u = Array.from(Hk(u, s)), u = Nk(u, e), a && (u = Fk(u, s)); for (let d of n) u = Bk(d, u, e); for (let d of u) { if (d[1].raws.tailwind = { ...d[1].raws.tailwind, candidate: r }, d[0].collectedFormats) { let y = Np("&", ...d[0].collectedFormats), v = U.root({ nodes: [d[1].clone()] }); v.walkRules(b => { Da(b) || (b.selector = Fp(y, { selector: b.selector, candidate: t, base: r.split(new RegExp(`\\${e?.tailwindConfig?.separator ?? ":"}(?![^[]*\\])`)).pop(), context: e })) }), d[1] = v.nodes[0] } yield d }
                }
            } function Da(r) { return r.parent && r.parent.type === "atrule" && r.parent.name === "keyframes" } function ns(r, e) { let t = []; for (let s of r) { if (e.notClassCache.has(s)) continue; if (e.classCache.has(s)) { t.push(e.classCache.get(s)); continue } let n = Array.from(ss(s, e)); if (n.length === 0) { e.notClassCache.add(s); continue } e.classCache.set(s, n), t.push(n) } let i = (s => { if (s === !0) return n => { n.walkDecls(a => { a.parent.type === "rule" && !Da(a.parent) && (a.important = !0) }) }; if (typeof s == "string") return n => { n.selectors = n.selectors.map(a => `${s} ${a}`) } })(e.tailwindConfig.important); return t.flat(1).map(([{ sort: s, layer: n, options: a }, o]) => { if (a.respectImportant && i) { let u = U.root({ nodes: [o.clone()] }); u.walkRules(f => { Da(f) || i(f) }), o = u.nodes[0] } return [s | e.layerOrder[n], o] }) } function jp(r) { return r.startsWith("[") && r.endsWith("]") } var Ta, Rk, zk, as = C(() => { l(); He(); Ta = H(Se()); ka(); Qt(); Xi(); Sr(); ve(); We(); zp(); Ca(); Mn(); ls(); Aa(); Tn(); Ve(); Rk = (0, Ta.default)(r => r.first.filter(({ type: e }) => e === "class").pop().value); zk = /^[a-z_-]/ }); function Yk(r) { try { return pt.createHash("md5").update(r, "utf-8").digest("binary") } catch (e) { return "" } } function Up(r, e) { let t = e.toString(); if (!t.includes("@tailwind")) return !1; let i = jn.get(r), s = Yk(t), n = i !== s; return jn.set(r, s), n } var Vp = C(() => { l(); Xr(); We() }); function Yp(r, e) { let t = r.tailwindConfig.prefix; return typeof t == "function" ? t(e) : t + e } function Qp(r) { if (r.includes("{")) { if (!Qk(r)) throw new Error("Your { and } are unbalanced."); return r.split(/{(.*)}/gim).flatMap(e => Qp(e)).filter(Boolean) } return [r.trim()] } function Qk(r) { let e = 0; for (let t of r) if (t === "{") e++; else if (t === "}" && --e < 0) return !1; return e === 0 } function Jk(r, e, { before: t = [] } = {}) { if (t = [].concat(t), t.length <= 0) { r.push(e); return } let i = r.length - 1; for (let s of t) { let n = r.indexOf(s); n !== -1 && (i = Math.min(i, n)) } r.splice(i, 0, e) } function Jp(r) { return Array.isArray(r) ? r.flatMap(e => !Array.isArray(e) && !Pe(e) ? e : _t(e)) : Jp([r]) } function Xp(r, e) { return (0, Gp.default)(i => { let s = []; return e && e(i), i.walkClasses(n => { s.push(n.value) }), s }).transformSync(r) } function Xk(r, e = { containsNonOnDemandable: !1 }, t = 0) { let i = []; if (r.type === "rule") { let s = function (n) { n.walkPseudos(a => { a.value === ":not" && a.remove() }) }; for (let n of r.selectors) { let a = Xp(n, s); a.length === 0 && (e.containsNonOnDemandable = !0); for (let o of a) i.push(o) } } else r.type === "atrule" && r.walkRules(s => { for (let n of s.selectors.flatMap(a => Xp(a))) i.push(n) }); return t === 0 ? [e.containsNonOnDemandable || i.length === 0, i] : i } function us(r) { return Jp(r).flatMap(e => { let t = new Map, [i, s] = Xk(e); return i && s.unshift(Ie), s.map(n => (t.has(e) || t.set(e, e), [n, t.get(e)])) }) } function os(r) { return r.startsWith("@") || r.includes("&") } function $r(r) { r = r.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim(); let e = Qp(r).map(t => { if (!t.startsWith("@")) return ({ format: n }) => n(t); let [, i, s] = /@(.*?)( .+|[({].*)/g.exec(t); return ({ wrap: n }) => n(U.atRule({ name: i, params: s.trim() })) }).reverse(); return t => { for (let i of e) i(t) } } function Kk(r, e, { variantList: t, variantMap: i, offsets: s, classList: n }) { function a(p, d) { return p ? (0, Wp.default)(r, p, d) : r } function o(p) { return At(r.prefix, p) } function u(p, d) { return p === Ie ? Ie : d.respectPrefix ? e.tailwindConfig.prefix + p : p } function f(p, d, y = {}) { let [v, ...b] = Be(p), x = a(["theme", v, ...b], d); return Me(v)(x, y) } let c = Object.assign((p, d = void 0) => f(p, d), { withAlpha: (p, d) => f(p, void 0, { opacityValue: d }) }), h = { postcss: U, prefix: o, e: fe, config: a, theme: c, corePlugins: p => Array.isArray(r.corePlugins) ? r.corePlugins.includes(p) : a(["corePlugins", p], !0), variants: () => [], addBase(p) { for (let [d, y] of us(p)) { let v = u(d, {}), b = s.base++; e.candidateRuleMap.has(v) || e.candidateRuleMap.set(v, []), e.candidateRuleMap.get(v).push([{ sort: b, layer: "base" }, y]) } }, addDefaults(p, d) { let y = { [`@defaults ${p}`]: d }; for (let [v, b] of us(y)) { let x = u(v, {}); e.candidateRuleMap.has(x) || e.candidateRuleMap.set(x, []), e.candidateRuleMap.get(x).push([{ sort: s.base++, layer: "defaults" }, b]) } }, addComponents(p, d) { d = Object.assign({}, { respectPrefix: !0, respectImportant: !1 }, Array.isArray(d) ? {} : d); for (let [v, b] of us(p)) { let x = u(v, d); n.add(x), e.candidateRuleMap.has(x) || e.candidateRuleMap.set(x, []), e.candidateRuleMap.get(x).push([{ sort: s.components++, layer: "components", options: d }, b]) } }, addUtilities(p, d) { d = Object.assign({}, { respectPrefix: !0, respectImportant: !0 }, Array.isArray(d) ? {} : d); for (let [v, b] of us(p)) { let x = u(v, d); n.add(x), e.candidateRuleMap.has(x) || e.candidateRuleMap.set(x, []), e.candidateRuleMap.get(x).push([{ sort: s.utilities++, layer: "utilities", options: d }, b]) } }, matchUtilities: function (p, d) { d = { ...{ respectPrefix: !0, respectImportant: !0 }, ...d }; let v = s.utilities++; for (let b in p) { let T = function (R, { isOnlyPlugin: Y }) { let { type: L = "any" } = d; L = [].concat(L); let [I, Q] = Ln(L, R, d, r); return I === void 0 ? [] : !L.includes(Q) && !Y ? [] : Et(I) ? [].concat(k(I)).filter(Boolean).map(Fe => ({ [Ki(b, R)]: Fe })) : [] }, x = u(b, d), k = p[b]; n.add([x, d]); let P = [{ sort: v, layer: "utilities", options: d }, T]; e.candidateRuleMap.has(x) || e.candidateRuleMap.set(x, []), e.candidateRuleMap.get(x).push(P) } }, matchComponents: function (p, d) { d = { ...{ respectPrefix: !0, respectImportant: !1 }, ...d }; let v = s.components++; for (let b in p) { let T = function (R, { isOnlyPlugin: Y }) { let { type: L = "any" } = d; L = [].concat(L); let [I, Q] = Ln(L, R, d, r); if (I === void 0) return []; if (!L.includes(Q)) if (Y) V.warn([`Unnecessary typehint \`${Q}\` in \`${b}-${R}\`.`, `You can safely update it to \`${b}-${R.replace(Q + ":", "")}\`.`]); else return []; return Et(I) ? [].concat(k(I)).filter(Boolean).map(Fe => ({ [Ki(b, R)]: Fe })) : [] }, x = u(b, d), k = p[b]; n.add([x, d]); let P = [{ sort: v, layer: "components", options: d }, T]; e.candidateRuleMap.has(x) || e.candidateRuleMap.set(x, []), e.candidateRuleMap.get(x).push(P) } }, addVariant(p, d, y = {}) { d = [].concat(d).map(v => { if (typeof v != "string") return b => { let { args: x, modifySelectors: k, container: T, separator: P, wrap: R, format: Y } = b, L = v(Object.assign({ modifySelectors: k, container: T, separator: P }, v[Hp] && { args: x, wrap: R, format: Y })); if (typeof L == "string" && !os(L)) throw new Error(`Your custom variant \`${p}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`); return Array.isArray(L) ? L.filter(I => typeof I == "string").map(I => $r(I)) : L && typeof L == "string" && $r(L)(b) }; if (!os(v)) throw new Error(`Your custom variant \`${p}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`); return $r(v) }), Jk(t, p, y), i.set(p, d) } }; return K(r, "matchVariant") && (h.matchVariant = function (p, d) { for (let y in p) { for (let [v, b] of Object.entries(d?.values ?? {})) h.addVariant(`${y}-${v}`, p[y](b)); h.addVariant(y, Object.assign(({ args: v }) => p[y](v), { [Hp]: !0 }), d) } }), h } function fs(r) { return qa.has(r) || qa.set(r, new Map), qa.get(r) } function Kp(r, e) { let t = !1; for (let i of r) { if (!i) continue; let s = Un.parse(i), n = s.hash ? s.href.replace(s.hash, "") : s.href; n = s.search ? n.replace(s.search, "") : n; let a = xe.statSync(decodeURIComponent(n), { throwIfNoEntry: !1 })?.mtimeMs; !a || ((!e.has(i) || a > e.get(i)) && (t = !0), e.set(i, a)) } return t } function Zp(r) { r.walkAtRules(e => { ["responsive", "variants"].includes(e.name) && (Zp(e), e.before(e.nodes), e.remove()) }) } function Zk(r) { let e = []; return r.each(t => { t.type === "atrule" && ["responsive", "variants"].includes(t.name) && (t.name = "layer", t.params = "utilities") }), r.walkAtRules("layer", t => { if (Zp(t), t.params === "base") { for (let i of t.nodes) e.push(function ({ addBase: s }) { s(i, { respectPrefix: !1 }) }); t.remove() } else if (t.params === "components") { for (let i of t.nodes) e.push(function ({ addComponents: s }) { s(i, { respectPrefix: !1 }) }); t.remove() } else if (t.params === "utilities") { for (let i of t.nodes) e.push(function ({ addUtilities: s }) { s(i, { respectPrefix: !1 }) }); t.remove() } }), e } function eS(r, e) { let t = Object.entries({ ...we, ...Dp }).map(([o, u]) => r.tailwindConfig.corePlugins.includes(o) ? u : null).filter(Boolean), i = r.tailwindConfig.plugins.map(o => (o.__isOptionsFunction && (o = o()), typeof o == "function" ? o : o.handler)), s = Zk(e), n = [we.pseudoElementVariants, we.pseudoClassVariants], a = [we.directionVariants, we.reducedMotionVariants, we.prefersContrastVariants, we.darkVariants, we.printVariant, we.screenVariants, we.orientationVariants]; return [...t, ...n, ...i, ...a, ...s] } function tS(r, e) { let t = [], i = new Map, s = { defaults: 0n, base: 0n, components: 0n, utilities: 0n, user: 0n }, n = new Set, a = Kk(e.tailwindConfig, e, { variantList: t, variantMap: i, offsets: s, classList: n }); for (let p of r) if (Array.isArray(p)) for (let d of p) d(a); else p?.(a); let o = (p => p.reduce((d, y) => y > d ? y : d))([s.base, s.defaults, s.components, s.utilities, s.user]), u = BigInt(o.toString(2).length); e.arbitraryPropertiesSort = (1n << u << 0n) - 1n, e.layerOrder = { defaults: 1n << u << 0n, base: 1n << u << 1n, components: 1n << u << 2n, utilities: 1n << u << 3n, user: 1n << u << 4n }, u += 5n; let f = 0; e.variantOrder = new Map(t.map((p, d) => { let y = i.get(p).length, v = 1n << BigInt(d + f) << u; return f += y - 1, [p, v] }).sort(([, p], [, d]) => at(p - d))), e.minimumScreen = [...e.variantOrder.values()].shift(); for (let [p, d] of i.entries()) { let y = e.variantOrder.get(p); e.variantMap.set(p, d.map((v, b) => [y << BigInt(b), v])) } let c = (e.tailwindConfig.safelist ?? []).filter(Boolean); if (c.length > 0) { let p = []; for (let d of c) { if (typeof d == "string") { e.changedContent.push({ content: d, extension: "html" }); continue } if (d instanceof RegExp) { V.warn("root-regex", ["Regular expressions in `safelist` work differently in Tailwind CSS v3.0.", "Update your `safelist` configuration to eliminate this warning.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]); continue } p.push(d) } if (p.length > 0) { let d = new Map, y = e.tailwindConfig.prefix.length; for (let v of n) { let b = Array.isArray(v) ? (() => { let [x, k] = v, P = Object.keys(k?.values ?? {}).map(R => zr(x, R)); return k?.supportsNegativeValues && (P = [...P, ...P.map(R => "-" + R)], P = [...P, ...P.map(R => R.slice(0, y) + "-" + R.slice(y))]), P })() : [v]; for (let x of b) for (let { pattern: k, variants: T = [] } of p) if (k.lastIndex = 0, d.has(k) || d.set(k, 0), !!k.test(x)) { d.set(k, d.get(k) + 1), e.changedContent.push({ content: x, extension: "html" }); for (let P of T) e.changedContent.push({ content: P + e.tailwindConfig.separator + x, extension: "html" }) } } for (let [v, b] of d.entries()) b === 0 && V.warn([`The safelist pattern \`${v}\` doesn't match any Tailwind CSS classes.`, "Fix this pattern or remove it from your `safelist` configuration.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]) } } let h = new Set([Yp(e, "group"), Yp(e, "peer")]); e.getClassOrder = function (d) { let y = new Map; for (let [v, b] of ns(new Set(d), e)) y.has(b.raws.tailwind.candidate) || y.set(b.raws.tailwind.candidate, v); return d.map(v => { let b = y.get(v) ?? null; return b === null && h.has(v) && (b = e.layerOrder.components), [v, b] }) }, e.getClassList = function () { let d = []; for (let y of n) if (Array.isArray(y)) { let [v, b] = y, x = []; for (let [k, T] of Object.entries(b?.values ?? {})) d.push(zr(v, k)), b?.supportsNegativeValues && rt(T) && x.push(zr(v, `-${k}`)); d.push(...x) } else d.push(y); return d } } function Ia(r, e = [], t = U.root()) { let i = { disposables: [], ruleCache: new Set, classCache: new Map, applyClassCache: new Map, notClassCache: new Set, postCssNodeCache: new Map, candidateRuleMap: new Map, tailwindConfig: r, changedContent: e, variantMap: new Map, stylesheetCache: null }, s = eS(i, t); return tS(s, i), i } function ed(r, e, t, i, s, n) { let a = e.opts.from, o = i !== null; ge.DEBUG && console.log("Source path:", a); let u; if (o && Tt.has(a)) u = Tt.get(a); else if (jr.has(s)) { let h = jr.get(s); Qe.get(h).add(a), Tt.set(a, h), u = h } let f = Up(a, r); if (u && !Kp([...n], fs(u)) && !f) return [u, !1]; if (Tt.has(a)) { let h = Tt.get(a); if (Qe.has(h) && (Qe.get(h).delete(a), Qe.get(h).size === 0)) { Qe.delete(h); for (let [p, d] of jr) d === h && jr.delete(p); for (let p of h.disposables.splice(0)) p(h) } } ge.DEBUG && console.log("Setting up new context..."); let c = Ia(t, [], r); return Kp([...n], fs(c)), jr.set(s, c), Tt.set(a, c), Qe.has(c) || Qe.set(c, new Set), Qe.get(c).add(a), [c, !0] } var Wp, Gp, Hp, qa, Tt, jr, Qe, ls = C(() => { l(); ct(); Vn(); He(); Wp = H(pa()), Gp = H(Se()); Ve(); Fr(); ka(); Xi(); Qt(); Ot(); Ca(); Sr(); Zi(); qp(); We(); We(); ei(); ve(); Kr(); Aa(); as(); Vp(); Hp = Symbol(); qa = new WeakMap; Tt = Df, jr = qf, Qe = Ci }); var td, rd = C(() => { l(); td = () => !1 }); var id, sd = C(() => { l(); id = () => "" }); function rS(r) { let e = r, t = id(r); return t !== "." && (e = r.substr(t.length), e.charAt(0) === "/" && (e = e.substr(1))), e.substr(0, 2) === "./" && (e = e.substr(2)), e.charAt(0) === "/" && (e = e.substr(1)), { base: t, glob: e } } function Ra(r) { if (r.startsWith("!")) return null; let e; if (td(r)) { let { base: t, glob: i } = rS(r); e = { type: "dir-dependency", dir: ie.resolve(t), glob: i } } else e = { type: "dependency", file: ie.resolve(r) }; return e.type === "dir-dependency" && m.env.ROLLUP_WATCH === "true" && (e = { type: "dependency", file: e.dir }), e } var nd = C(() => { l(); rd(); sd(); tt() }); function Ma(r) { return r.content.files.length === 0 && V.warn("content-problems", ["The `content` option in your Tailwind CSS configuration is missing or empty.", "Configure your content sources or your generated CSS will be missing styles.", "https://tailwindcss.com/docs/content-configuration"]), r } var ad = C(() => { l(); ve() }); function iS(r, e) { if (La.has(r)) return La.get(r); let t = e.content.files.filter(i => typeof i == "string").map(i => xl(i)); return La.set(r, t).get(r) } function sS(r) { let e = $n(r); if (e !== null) { let [i, s, n, a] = ld.get(e) || [], o = As(e).map(p => p.file), u = !1, f = new Map; for (let p of o) { let d = xe.statSync(p).mtimeMs; f.set(p, d), (!a || !a.has(p) || d > a.get(p)) && (u = !0) } if (!u) return [i, e, s, n]; for (let p of o) delete Cs.cache[p]; let c = Ar(Cs(e)); c = Ma(c); let h = Jr(c); return ld.set(e, [c, h, o, f]), [c, e, h, o] } let t = Ar(r.config === void 0 ? r : r.config); return t = Ma(t), [t, null, Jr(t), []] } function nS(r, e, t) { let i = r.tailwindConfig.content.files.filter(s => typeof s.raw == "string").map(({ raw: s, extension: n = "html" }) => ({ content: s, extension: n })); for (let s of aS(e, t)) { let n = xe.readFileSync(s, "utf8"), a = ie.extname(s).slice(1); i.push({ content: n, extension: a }) } return i } function aS(r, e) { let t = new Set; ge.DEBUG && console.time("Finding changed files"); let i = gl.sync(r); for (let s of i) { let n = e.has(s) ? e.get(s) : -1 / 0, a = xe.statSync(s).mtimeMs; a > n && (t.add(s), e.set(s, a)) } return ge.DEBUG && console.timeEnd("Finding changed files"), t } function Na(r) { return ({ tailwindDirectives: e, registerDependency: t }) => (i, s) => { let [n, a, o, u] = sS(r), f = new Set(u); if (e.size > 0) { f.add(s.opts.from); for (let p of s.messages) p.type === "dependency" && f.add(p.file) } let [c] = ed(i, s, n, a, o, f), h = iS(c, n); if (e.size > 0) { let p = fs(c); for (let d of h) { let y = Ra(d); y && t(y) } for (let d of nS(c, h, p)) c.changedContent.push(d) } for (let p of u) t({ type: "dependency", file: p }); return c } } var od, ld, La, ud = C(() => { l(); ct(); tt(); yl(); od = H(_s()); vl(); Cl(); Al(); zn(); Pf(); We(); ls(); nd(); ad(); ld = new od.default({ maxSize: 100 }), La = new WeakMap }); function Fa(r) { let e = new Set, t = new Set, i = new Set; if (r.walkAtRules(s => { s.name === "apply" && i.add(s), s.name === "import" && (s.params === '"tailwindcss/base"' || s.params === "'tailwindcss/base'" ? (s.name = "tailwind", s.params = "base") : s.params === '"tailwindcss/components"' || s.params === "'tailwindcss/components'" ? (s.name = "tailwind", s.params = "components") : s.params === '"tailwindcss/utilities"' || s.params === "'tailwindcss/utilities'" ? (s.name = "tailwind", s.params = "utilities") : (s.params === '"tailwindcss/screens"' || s.params === "'tailwindcss/screens'" || s.params === '"tailwindcss/variants"' || s.params === "'tailwindcss/variants'") && (s.name = "tailwind", s.params = "variants")), s.name === "tailwind" && (s.params === "screens" && (s.params = "variants"), e.add(s.params)), ["layer", "responsive", "variants"].includes(s.name) && (["responsive", "variants"].includes(s.name) && V.warn(`${s.name}-at-rule-deprecated`, [`The \`@${s.name}\` directive has been deprecated in Tailwind CSS v3.0.`, "Use `@layer utilities` or `@layer components` instead.", "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"]), t.add(s)) }), !e.has("base") || !e.has("components") || !e.has("utilities")) { for (let s of t) if (s.name === "layer" && ["base", "components", "utilities"].includes(s.params)) { if (!e.has(s.params)) throw s.error(`\`@layer ${s.params}\` is used but no matching \`@tailwind ${s.params}\` directive is present.`) } else if (s.name === "responsive") { if (!e.has("utilities")) throw s.error("`@responsive` is used but `@tailwind utilities` is missing.") } else if (s.name === "variants" && !e.has("utilities")) throw s.error("`@variants` is used but `@tailwind utilities` is missing.") } return { tailwindDirectives: e, applyDirectives: i } } var fd = C(() => { l(); ve() }); function lt(r, e = void 0, t = void 0) { return r.map(i => { let s = i.clone(); return e !== void 0 && (s.source = e, "walk" in s && s.walk(n => { n.source = e })), t !== void 0 && (s.raws.tailwind = { ...s.raws.tailwind, ...t }), s }) } var cd = C(() => { l() }); function pd(r) { let e = Array.from(oS(r)); return t => { let i = []; for (let s of e) i = [...i, ...t.match(s) ?? []]; return i.filter(s => s !== void 0).map(fS) } } function* oS(r) { let e = r.tailwindConfig.separator, t = K(r.tailwindConfig, "variantGrouping"), i = xr([/\[[^\s:'"`]+:[^\s\]]+\]/, Ue([/-?(?:\w+)/, Ju(xr([Ue([/-(?:\w+-)*\[[^\s:]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\><$]*)?/]), Ue([/-(?:\w+-)*\[[^\s]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\$]*)?/]), /[-\/][^\s'"`\\$={><]*/]))])]); yield Ue(["((?=((", xr([Ue([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, e]), Ue([/[^\s"'`\[\\]+/, e])], !0), ")+))\\2)?", /!?/, t ? xr([Ue([/\(/, i, Xu([/,/, i]), /\)/]), i]) : i]), yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g } function fS(r) { if (!r.includes("-[")) return r; let e = 0, t = [], i = r.matchAll(lS); i = Array.from(i).flatMap(s => { let [, ...n] = s; return n.map((a, o) => Object.assign([], s, { index: s.index + o, 0: a })) }); for (let s of i) { let n = s[0], a = t[t.length - 1]; if (n === a ? t.pop() : (n === "'" || n === '"' || n === "`") && t.push(n), !a) { if (n === "[") { e++; continue } else if (n === "]") { e--; continue } if (e < 0 || e === 0 && !uS.test(n)) return r.substring(0, s.index) } } return r } var lS, uS, dd = C(() => { l(); Ve(); En(); lS = /([\[\]'"`])([^\[\]'"`])?/g, uS = /[^"'`\s<>\]]+/ }); function cS(r, e) { let t = r.tailwindConfig.content.extract; return t[e] || t.DEFAULT || md[e] || md.DEFAULT(r) } function pS(r, e) { let t = r.content.transform; return t[e] || t.DEFAULT || gd[e] || gd.DEFAULT } function dS(r, e, t, i) {
                Ur.has(e) || Ur.set(e, new hd.default({ maxSize: 25e3 })); for (let s of r.split(`
`)) if (s = s.trim(), !i.has(s)) if (i.add(s), Ur.get(e).has(s)) for (let n of Ur.get(e).get(s)) t.add(n); else { let n = e(s).filter(o => o !== "!*"), a = new Set(n); for (let o of a) t.add(o); Ur.get(e).set(s, a) }
            } function hS(r, e) { let t = r.sort(([s], [n]) => at(s - n)), i = { base: new Set, defaults: new Set, components: new Set, utilities: new Set, variants: new Set, user: new Set }; for (let [s, n] of t) { if (s >= e.minimumScreen) { i.variants.add(n); continue } if (s & e.layerOrder.base) { i.base.add(n); continue } if (s & e.layerOrder.defaults) { i.defaults.add(n); continue } if (s & e.layerOrder.components) { i.components.add(n); continue } if (s & e.layerOrder.utilities) { i.utilities.add(n); continue } if (s & e.layerOrder.user) { i.user.add(n); continue } } return i } function Ba(r) { return e => { let t = { base: null, components: null, utilities: null, variants: null }; if (e.walkAtRules(y => { y.name === "tailwind" && Object.keys(t).includes(y.params) && (t[y.params] = y) }), Object.values(t).every(y => y === null)) return e; let i = new Set([Ie]), s = new Set; ut.DEBUG && console.time("Reading changed files"); for (let { content: y, extension: v } of r.changedContent) { let b = pS(r.tailwindConfig, v), x = cS(r, v); dS(b(y), x, i, s) } ut.DEBUG && console.timeEnd("Reading changed files"); let n = r.classCache.size; ut.DEBUG && console.time("Generate rules"); let a = ns(i, r); if (ut.DEBUG && console.timeEnd("Generate rules"), ut.DEBUG && console.time("Build stylesheet"), r.stylesheetCache === null || r.classCache.size !== n) { for (let y of a) r.ruleCache.add(y); r.stylesheetCache = hS([...r.ruleCache], r) } ut.DEBUG && console.timeEnd("Build stylesheet"); let { defaults: o, base: u, components: f, utilities: c, variants: h } = r.stylesheetCache; t.base && (t.base.before(lt([...u, ...o], t.base.source, { layer: "base" })), t.base.remove()), t.components && (t.components.before(lt([...f], t.components.source, { layer: "components" })), t.components.remove()), t.utilities && (t.utilities.before(lt([...c], t.utilities.source, { layer: "utilities" })), t.utilities.remove()); let p = Array.from(h).filter(y => { let v = y.raws.tailwind?.parentLayer; return v === "components" ? t.components !== null : v === "utilities" ? t.utilities !== null : !0 }); t.variants ? (t.variants.before(lt(p, t.variants.source, { layer: "variants" })), t.variants.remove()) : p.length > 0 && e.append(lt(p, e.source, { layer: "variants" })); let d = p.some(y => y.raws.tailwind?.parentLayer === "utilities"); t.utilities && c.size === 0 && !d && V.warn("content-problems", ["No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.", "https://tailwindcss.com/docs/content-configuration"]), ut.DEBUG && (console.log("Potential classes: ", i.size), console.log("Active contexts: ", Ci.size)), r.changedContent = [], e.walkAtRules("layer", y => { Object.keys(t).includes(y.params) && y.remove() }) } } var hd, ut, md, gd, Ur, yd = C(() => { l(); hd = H(_s()); We(); as(); Zi(); ve(); cd(); dd(); ut = ge, md = { DEFAULT: pd }, gd = { DEFAULT: r => r, svelte: r => r.replace(/(?:^|\s)class:/g, " ") }; Ur = new WeakMap }); function cs(r) { let e = new Map; U.root({ nodes: [r.clone()] }).walkRules(n => { (0, za.default)(a => { a.walkClasses(o => { let u = o.parent.toString(), f = e.get(u); f || e.set(u, f = new Set), f.add(o.value) }) }).processSync(n.selector) }); let i = Array.from(e.values(), n => Array.from(n)), s = i.flat(); return Object.assign(s, { groups: i }) } function wd(r) { return mS.transformSync(r) } function bd(r, e) { let t = new Set; for (let i of r) t.add(i.split(e).pop()); return Array.from(t) } function xd(r, e) { let t = r.tailwindConfig.prefix; return typeof t == "function" ? t(e) : t + e } function* vd(r) { for (yield r; r.parent;)yield r.parent, r = r.parent } function gS(r, e = {}) { let t = r.nodes; r.nodes = []; let i = r.clone(e); return r.nodes = t, i } function yS(r) { for (let e of vd(r)) if (r !== e) { if (e.type === "root") break; r = gS(e, { nodes: [r] }) } return r } function wS(r, e) { let t = new Map, i = e.layerOrder.user >> 4n; return r.walkRules((s, n) => { for (let o of vd(s)) if (o.raws.tailwind?.layer !== void 0) return; let a = yS(s); for (let o of cs(s)) { let u = t.get(o) || []; t.set(o, u), u.push([{ layer: "user", sort: BigInt(n) + i, important: !1 }, a]) } }), t } function bS(r, e) { for (let t of r) { if (e.notClassCache.has(t) || e.applyClassCache.has(t)) continue; if (e.classCache.has(t)) { e.applyClassCache.set(t, e.classCache.get(t).map(([s, n]) => [s, n.clone()])); continue } let i = Array.from(ss(t, e)); if (i.length === 0) { e.notClassCache.add(t); continue } e.applyClassCache.set(t, i) } return e.applyClassCache } function xS(r) { let e = null; return { get: t => (e = e || r(), e.get(t)), has: t => (e = e || r(), e.has(t)) } } function vS(r) { return { get: e => r.flatMap(t => t.get(e) || []), has: e => r.some(t => t.has(e)) } } function kd(r) { let e = r.split(/[\s\t\n]+/g); return e[e.length - 1] === "!important" ? [e.slice(0, -1), !0] : [e, !1] } function Sd(r, e, t) { let i = new Set, s = []; if (r.walkAtRules("apply", u => { let [f] = kd(u.params); for (let c of f) i.add(c); s.push(u) }), s.length === 0) return; let n = vS([t, bS(i, e)]); function a(u, f, c) { let h = `.${fe(c)}`, p = [...new Set([h, h.replace(/\\2c /g, "\\,")])], d = wd(f); return wd(u).map(y => { let v = []; for (let b of d) { let x = b; for (let k of p) x = x.replace(k, y); x !== b && v.push(x) } return v.join(", ") }).join(", ") } let o = new Map; for (let u of s) { let [f] = o.get(u.parent) || [[], u.source]; o.set(u.parent, [f, u.source]); let [c, h] = kd(u.params); if (u.parent.type === "atrule") { if (u.parent.name === "screen") { let p = u.parent.params; throw u.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${c.map(d => `${p}:${d}`).join(" ")} instead.`) } throw u.error(`@apply is not supported within nested at-rules like @${u.parent.name}. You can fix this by un-nesting @${u.parent.name}.`) } for (let p of c) { if ([xd(e, "group"), xd(e, "peer")].includes(p)) throw u.error(`@apply should not be used with the '${p}' utility`); if (!n.has(p)) throw u.error(`The \`${p}\` class does not exist. If \`${p}\` is a custom class, make sure it is defined within a \`@layer\` directive.`); let d = n.get(p); f.push([p, h, d]) } } for (let [u, [f, c]] of o) { let h = []; for (let [d, y, v] of f) { let b = [d, ...bd([d], e.tailwindConfig.separator)]; for (let [x, k] of v) { let T = cs(u), P = cs(k); if (P = P.groups.filter(I => I.some(Q => b.includes(Q))).flat(), P = P.concat(bd(P, e.tailwindConfig.separator)), T.some(I => P.includes(I))) throw k.error(`You cannot \`@apply\` the \`${d}\` utility here because it creates a circular dependency.`); let Y = U.root({ nodes: [k.clone()] }); Y.walk(I => { I.source = c }), (k.type !== "atrule" || k.type === "atrule" && k.name !== "keyframes") && Y.walkRules(I => { if (!cs(I).some(Gt => Gt === d)) { I.remove(); return } let Q = typeof e.tailwindConfig.important == "string" ? e.tailwindConfig.important : null, Fe = u.raws.tailwind !== void 0 && Q && u.selector.indexOf(Q) === 0 ? u.selector.slice(Q.length) : u.selector; I.selector = a(Fe, I.selector, d), Q && Fe !== u.selector && (I.selector = `${Q} ${I.selector}`), I.walkDecls(Gt => { Gt.important = x.important || y }) }), h.push([{ ...x, sort: x.sort | e.layerOrder[x.layer] }, Y.nodes[0]]) } } let p = h.sort(([d], [y]) => at(d.sort - y.sort)).map(d => d[1]); u.after(p) } for (let u of s) u.parent.nodes.length > 1 ? u.remove() : u.parent.remove(); Sd(r, e, t) } function $a(r) { return e => { let t = xS(() => wS(e, r)); Sd(e, r, t) } } var za, mS, Cd = C(() => { l(); He(); za = H(Se()); as(); Zi(); Ot(); mS = (0, za.default)(r => r.nodes.map(e => e.toString())) }); var _d = w(($4, ps) => { l(); (function () { "use strict"; function r(i, s, n) { if (!i) return null; r.caseSensitive || (i = i.toLowerCase()); var a = r.threshold === null ? null : r.threshold * i.length, o = r.thresholdAbsolute, u; a !== null && o !== null ? u = Math.min(a, o) : a !== null ? u = a : o !== null ? u = o : u = null; var f, c, h, p, d, y = s.length; for (d = 0; d < y; d++)if (c = s[d], n && (c = c[n]), !!c && (r.caseSensitive ? h = c : h = c.toLowerCase(), p = t(i, h, u), (u === null || p < u) && (u = p, n && r.returnWinningObject ? f = s[d] : f = c, r.returnFirstMatch))) return f; return f || r.nullResultValue } r.threshold = .4, r.thresholdAbsolute = 20, r.caseSensitive = !1, r.nullResultValue = null, r.returnWinningObject = null, r.returnFirstMatch = !1, typeof ps != "undefined" && ps.exports ? ps.exports = r : window.didYouMean = r; var e = Math.pow(2, 32) - 1; function t(i, s, n) { n = n || n === 0 ? n : e; var a = i.length, o = s.length; if (a === 0) return Math.min(n + 1, o); if (o === 0) return Math.min(n + 1, a); if (Math.abs(a - o) > n) return n + 1; var u = [], f, c, h, p, d; for (f = 0; f <= o; f++)u[f] = [f]; for (c = 0; c <= a; c++)u[0][c] = c; for (f = 1; f <= o; f++) { for (h = e, p = 1, f > n && (p = f - n), d = o + 1, d > n + f && (d = n + f), c = 1; c <= a; c++)c < p || c > d ? u[f][c] = n + 1 : s.charAt(f - 1) === i.charAt(c - 1) ? u[f][c] = u[f - 1][c - 1] : u[f][c] = Math.min(u[f - 1][c - 1] + 1, Math.min(u[f][c - 1] + 1, u[f - 1][c] + 1)), u[f][c] < h && (h = u[f][c]); if (h > n) return n + 1 } return u[o][a] } })() }); var Od = w((j4, Ad) => { l(); var ja = "(".charCodeAt(0), Ua = ")".charCodeAt(0), ds = "'".charCodeAt(0), Va = '"'.charCodeAt(0), Wa = "\\".charCodeAt(0), Pt = "/".charCodeAt(0), Ga = ",".charCodeAt(0), Ha = ":".charCodeAt(0), hs = "*".charCodeAt(0), kS = "u".charCodeAt(0), SS = "U".charCodeAt(0), CS = "+".charCodeAt(0), _S = /^[a-f0-9?-]+$/i; Ad.exports = function (r) { for (var e = [], t = r, i, s, n, a, o, u, f, c, h = 0, p = t.charCodeAt(h), d = t.length, y = [{ nodes: e }], v = 0, b, x = "", k = "", T = ""; h < d;)if (p <= 32) { i = h; do i += 1, p = t.charCodeAt(i); while (p <= 32); a = t.slice(h, i), n = e[e.length - 1], p === Ua && v ? T = a : n && n.type === "div" ? (n.after = a, n.sourceEndIndex += a.length) : p === Ga || p === Ha || p === Pt && t.charCodeAt(i + 1) !== hs && (!b || b && b.type === "function" && b.value !== "calc") ? k = a : e.push({ type: "space", sourceIndex: h, sourceEndIndex: i, value: a }), h = i } else if (p === ds || p === Va) { i = h, s = p === ds ? "'" : '"', a = { type: "string", sourceIndex: h, quote: s }; do if (o = !1, i = t.indexOf(s, i + 1), ~i) for (u = i; t.charCodeAt(u - 1) === Wa;)u -= 1, o = !o; else t += s, i = t.length - 1, a.unclosed = !0; while (o); a.value = t.slice(h + 1, i), a.sourceEndIndex = a.unclosed ? i : i + 1, e.push(a), h = i + 1, p = t.charCodeAt(h) } else if (p === Pt && t.charCodeAt(h + 1) === hs) i = t.indexOf("*/", h), a = { type: "comment", sourceIndex: h, sourceEndIndex: i + 2 }, i === -1 && (a.unclosed = !0, i = t.length, a.sourceEndIndex = i), a.value = t.slice(h + 2, i), e.push(a), h = i + 2, p = t.charCodeAt(h); else if ((p === Pt || p === hs) && b && b.type === "function" && b.value === "calc") a = t[h], e.push({ type: "word", sourceIndex: h - k.length, sourceEndIndex: h + a.length, value: a }), h += 1, p = t.charCodeAt(h); else if (p === Pt || p === Ga || p === Ha) a = t[h], e.push({ type: "div", sourceIndex: h - k.length, sourceEndIndex: h + a.length, value: a, before: k, after: "" }), k = "", h += 1, p = t.charCodeAt(h); else if (ja === p) { i = h; do i += 1, p = t.charCodeAt(i); while (p <= 32); if (c = h, a = { type: "function", sourceIndex: h - x.length, value: x, before: t.slice(c + 1, i) }, h = i, x === "url" && p !== ds && p !== Va) { i -= 1; do if (o = !1, i = t.indexOf(")", i + 1), ~i) for (u = i; t.charCodeAt(u - 1) === Wa;)u -= 1, o = !o; else t += ")", i = t.length - 1, a.unclosed = !0; while (o); f = i; do f -= 1, p = t.charCodeAt(f); while (p <= 32); c < f ? (h !== f + 1 ? a.nodes = [{ type: "word", sourceIndex: h, sourceEndIndex: f + 1, value: t.slice(h, f + 1) }] : a.nodes = [], a.unclosed && f + 1 !== i ? (a.after = "", a.nodes.push({ type: "space", sourceIndex: f + 1, sourceEndIndex: i, value: t.slice(f + 1, i) })) : (a.after = t.slice(f + 1, i), a.sourceEndIndex = i)) : (a.after = "", a.nodes = []), h = i + 1, a.sourceEndIndex = a.unclosed ? i : h, p = t.charCodeAt(h), e.push(a) } else v += 1, a.after = "", a.sourceEndIndex = h + 1, e.push(a), y.push(a), e = a.nodes = [], b = a; x = "" } else if (Ua === p && v) h += 1, p = t.charCodeAt(h), b.after = T, b.sourceEndIndex += T.length, T = "", v -= 1, y[y.length - 1].sourceEndIndex = h, y.pop(), b = y[v], e = b.nodes; else { i = h; do p === Wa && (i += 1), i += 1, p = t.charCodeAt(i); while (i < d && !(p <= 32 || p === ds || p === Va || p === Ga || p === Ha || p === Pt || p === ja || p === hs && b && b.type === "function" && b.value === "calc" || p === Pt && b.type === "function" && b.value === "calc" || p === Ua && v)); a = t.slice(h, i), ja === p ? x = a : (kS === a.charCodeAt(0) || SS === a.charCodeAt(0)) && CS === a.charCodeAt(1) && _S.test(a.slice(2)) ? e.push({ type: "unicode-range", sourceIndex: h, sourceEndIndex: i, value: a }) : e.push({ type: "word", sourceIndex: h, sourceEndIndex: i, value: a }), h = i } for (h = y.length - 1; h; h -= 1)y[h].unclosed = !0, y[h].sourceEndIndex = t.length; return y[0].nodes } }); var Td = w((U4, Ed) => { l(); Ed.exports = function r(e, t, i) { var s, n, a, o; for (s = 0, n = e.length; s < n; s += 1)a = e[s], i || (o = t(a, s, e)), o !== !1 && a.type === "function" && Array.isArray(a.nodes) && r(a.nodes, t, i), i && t(a, s, e) } }); var Id = w((V4, qd) => { l(); function Pd(r, e) { var t = r.type, i = r.value, s, n; return e && (n = e(r)) !== void 0 ? n : t === "word" || t === "space" ? i : t === "string" ? (s = r.quote || "", s + i + (r.unclosed ? "" : s)) : t === "comment" ? "/*" + i + (r.unclosed ? "" : "*/") : t === "div" ? (r.before || "") + i + (r.after || "") : Array.isArray(r.nodes) ? (s = Dd(r.nodes, e), t !== "function" ? s : i + "(" + (r.before || "") + s + (r.after || "") + (r.unclosed ? "" : ")")) : i } function Dd(r, e) { var t, i; if (Array.isArray(r)) { for (t = "", i = r.length - 1; ~i; i -= 1)t = Pd(r[i], e) + t; return t } return Pd(r, e) } qd.exports = Dd }); var Md = w((W4, Rd) => { l(); var ms = "-".charCodeAt(0), gs = "+".charCodeAt(0), Ya = ".".charCodeAt(0), AS = "e".charCodeAt(0), OS = "E".charCodeAt(0); function ES(r) { var e = r.charCodeAt(0), t; if (e === gs || e === ms) { if (t = r.charCodeAt(1), t >= 48 && t <= 57) return !0; var i = r.charCodeAt(2); return t === Ya && i >= 48 && i <= 57 } return e === Ya ? (t = r.charCodeAt(1), t >= 48 && t <= 57) : e >= 48 && e <= 57 } Rd.exports = function (r) { var e = 0, t = r.length, i, s, n; if (t === 0 || !ES(r)) return !1; for (i = r.charCodeAt(e), (i === gs || i === ms) && e++; e < t && (i = r.charCodeAt(e), !(i < 48 || i > 57));)e += 1; if (i = r.charCodeAt(e), s = r.charCodeAt(e + 1), i === Ya && s >= 48 && s <= 57) for (e += 2; e < t && (i = r.charCodeAt(e), !(i < 48 || i > 57));)e += 1; if (i = r.charCodeAt(e), s = r.charCodeAt(e + 1), n = r.charCodeAt(e + 2), (i === AS || i === OS) && (s >= 48 && s <= 57 || (s === gs || s === ms) && n >= 48 && n <= 57)) for (e += s === gs || s === ms ? 3 : 2; e < t && (i = r.charCodeAt(e), !(i < 48 || i > 57));)e += 1; return { number: r.slice(0, e), unit: r.slice(e) } } }); var Vr = w((G4, Fd) => { l(); var TS = Od(), Ld = Td(), Nd = Id(); function Je(r) { return this instanceof Je ? (this.nodes = TS(r), this) : new Je(r) } Je.prototype.toString = function () { return Array.isArray(this.nodes) ? Nd(this.nodes) : "" }; Je.prototype.walk = function (r, e) { return Ld(this.nodes, r, e), this }; Je.unit = Md(); Je.walk = Ld; Je.stringify = Nd; Fd.exports = Je }); function Ja(r) { return typeof r == "object" && r !== null } function PS(r, e) { let t = Be(e); do if (t.pop(), (0, Wr.default)(r, t) !== void 0) break; while (t.length); return t.length ? t : void 0 } function Dt(r) { return typeof r == "string" ? r : r.reduce((e, t, i) => t.includes(".") ? `${e}[${t}]` : i === 0 ? t : `${e}.${t}`, "") } function zd(r) { return r.map(e => `'${e}'`).join(", ") } function $d(r) { return zd(Object.keys(r)) } function Xa(r, e, t, i = {}) { let s = Array.isArray(e) ? Dt(e) : e.replace(/^['"]+|['"]+$/g, ""), n = Array.isArray(e) ? e : Be(s), a = (0, Wr.default)(r.theme, n, t); if (a === void 0) { let u = `'${s}' does not exist in your theme config.`, f = n.slice(0, -1), c = (0, Wr.default)(r.theme, f); if (Ja(c)) { let h = Object.keys(c).filter(d => Xa(r, [...f, d]).isValid), p = (0, Bd.default)(n[n.length - 1], h); p ? u += ` Did you mean '${Dt([...f, p])}'?` : h.length > 0 && (u += ` '${Dt(f)}' has the following valid keys: ${zd(h)}`) } else { let h = PS(r.theme, s); if (h) { let p = (0, Wr.default)(r.theme, h); Ja(p) ? u += ` '${Dt(h)}' has the following keys: ${$d(p)}` : u += ` '${Dt(h)}' is not an object.` } else u += ` Your theme has the following top-level keys: ${$d(r.theme)}` } return { isValid: !1, error: u } } if (!(typeof a == "string" || typeof a == "number" || typeof a == "function" || a instanceof String || a instanceof Number || Array.isArray(a))) { let u = `'${s}' was found but does not resolve to a string.`; if (Ja(a)) { let f = Object.keys(a).filter(c => Xa(r, [...n, c]).isValid); f.length && (u += ` Did you mean something like '${Dt([...n, f[0]])}'?`) } return { isValid: !1, error: u } } let [o] = n; return { isValid: !0, value: Me(o)(a, i) } } function DS(r, e, t) { e = e.map(s => jd(r, s, t)); let i = [""]; for (let s of e) s.type === "div" && s.value === "," ? i.push("") : i[i.length - 1] += Qa.default.stringify(s); return i } function jd(r, e, t) { if (e.type === "function" && t[e.value] !== void 0) { let i = DS(r, e.nodes, t); e.type = "word", e.value = t[e.value](r, ...i) } return e } function qS(r, e, t) { return (0, Qa.default)(e).walk(i => { jd(r, i, t) }).toString() } function Ud({ tailwindConfig: r }) { let e = { theme: (t, i, ...s) => { i = i.replace(/^['"]+|['"]+$/g, ""); let n = i.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), a; n && (i = n[1], a = n[2]); let { isValid: o, value: u, error: f } = Xa(r, i, s.length ? s : void 0, { opacityValue: a }); if (!o) throw t.error(f); return a !== void 0 && (u = gt(u), u = Ce(u, a, u)), u }, screen: (t, i) => { i = i.replace(/^['"]+/g, "").replace(/['"]+$/g, ""); let n = Ye(r.theme.screens).find(({ name: a }) => a === i); if (!n) throw t.error(`The '${i}' screen does not exist in your theme.`); return ot(n) } }; return t => { t.walk(i => { let s = IS[i.type]; s !== void 0 && (i[s] = qS(i, i[s], e)) }) } } var Wr, Bd, Qa, IS, Vd = C(() => { l(); Wr = H(pa()), Bd = H(_d()); Fr(); Qa = H(Vr()); ts(); es(); ei(); br(); Sr(); IS = { atrule: "params", decl: "value" } }); function Wd({ tailwindConfig: { theme: r } }) { return function (e) { e.walkAtRules("screen", t => { let i = t.params, n = Ye(r.screens).find(({ name: a }) => a === i); if (!n) throw t.error(`No \`${i}\` screen found.`); t.name = "media", t.params = ot(n) }) } } var Gd = C(() => { l(); ts(); es() }); function RS(r) { let e = r.filter(o => o.type !== "pseudo" || o.nodes.length > 0 ? !0 : o.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(o.value)).reverse(), t = new Set(["tag", "class", "id", "attribute"]), i = e.findIndex(o => t.has(o.type)); if (i === -1) return e.reverse().join("").trim(); let s = e[i], n = Hd[s.type] ? Hd[s.type](s) : s; e = e.slice(0, i); let a = e.findIndex(o => o.type === "combinator" && o.value === ">"); return a !== -1 && (e.splice(0, a), e.unshift(ys.default.universal())), [n, ...e.reverse()].join("").trim() } function LS(r) { return Ka.has(r) || Ka.set(r, MS.transformSync(r)), Ka.get(r) } function Za({ tailwindConfig: r }) { return e => { let t = new Map, i = new Set; if (e.walkAtRules("defaults", s => { if (s.nodes && s.nodes.length > 0) { i.add(s); return } let n = s.params; t.has(n) || t.set(n, new Set), t.get(n).add(s.parent), s.remove() }), K(r, "optimizeUniversalDefaults")) for (let s of i) { let n = new Map, a = t.get(s.params) ?? []; for (let o of a) for (let u of LS(o.selector)) { let f = u.includes(":-") || u.includes("::-") ? u : "__DEFAULT__", c = n.get(f) ?? new Set; n.set(f, c), c.add(u) } if (K(r, "optimizeUniversalDefaults")) { if (n.size === 0) { s.remove(); continue } for (let [, o] of n) { let u = U.rule({ source: s.source }); u.selectors = [...o], u.append(s.nodes.map(f => f.clone())), s.before(u) } } s.remove() } else if (i.size) { let s = U.rule({ selectors: ["*", "::before", "::after"] }); for (let a of i) s.append(a.nodes), s.parent || a.before(s), s.source || (s.source = a.source), a.remove(); let n = s.clone({ selectors: ["::backdrop"] }); s.after(n) } } } var ys, Hd, MS, Ka, Yd = C(() => { l(); He(); ys = H(Se()); Ve(); Hd = { id(r) { return ys.default.attribute({ attribute: "id", operator: "=", value: r.value, quoteMark: '"' }) } }; MS = (0, ys.default)(r => r.map(e => { let t = e.split(i => i.type === "combinator" && i.value === " ").pop(); return RS(t) })), Ka = new Map }); function eo() { function r(e) { let t = null; e.each(i => { if (!NS.has(i.type)) { t = null; return } if (t === null) { t = i; return } let s = Qd[i.type]; i.type === "atrule" && i.name === "font-face" ? t = i : s.every(n => (i[n] ?? "").replace(/\s+/g, " ") === (t[n] ?? "").replace(/\s+/g, " ")) ? (i.nodes && t.append(i.nodes), i.remove()) : t = i }), e.each(i => { i.type === "atrule" && r(i) }) } return e => { r(e) } } var Qd, NS, Jd = C(() => { l(); Qd = { atrule: ["name", "params"], rule: ["selector"] }, NS = new Set(Object.keys(Qd)) }); function to() { return r => { r.walkRules(e => { let t = new Map, i = new Set([]), s = new Map; e.walkDecls(n => { if (n.parent === e) { if (t.has(n.prop)) { if (t.get(n.prop).value === n.value) { i.add(t.get(n.prop)), t.set(n.prop, n); return } s.has(n.prop) || s.set(n.prop, new Set), s.get(n.prop).add(t.get(n.prop)), s.get(n.prop).add(n) } t.set(n.prop, n) } }); for (let n of i) n.remove(); for (let n of s.values()) { let a = new Map; for (let o of n) { let u = BS(o.value); u !== null && (a.has(u) || a.set(u, new Set), a.get(u).add(o)) } for (let o of a.values()) { let u = Array.from(o).slice(0, -1); for (let f of u) f.remove() } } }) } } function BS(r) { let e = /^-?\d*.?\d+([\w%]+)?$/g.exec(r); return e ? e[1] ?? FS : null } var FS, Xd = C(() => { l(); FS = Symbol("unitless-number") }); function zS(r) { if (!r.walkAtRules) return; let e = new Set; if (r.walkAtRules("apply", t => { e.add(t.parent) }), e.size !== 0) for (let t of e) { let i = [], s = []; for (let n of t.nodes) n.type === "atrule" && n.name === "apply" ? (s.length > 0 && (i.push(s), s = []), i.push([n])) : s.push(n); if (s.length > 0 && i.push(s), i.length !== 1) { for (let n of [...i].reverse()) { let a = t.clone({ nodes: [] }); a.append(n), t.after(a) } t.remove() } } } function ws() { return r => { zS(r) } } var Kd = C(() => { l() }); function Zd(r) {
                return (e, t) => {
                    let i = !1; e.walkAtRules("tailwind", s => {
                        if (i) return !1; if (s.parent && s.parent.type !== "root") return i = !0, s.warn(t, ["Nested @tailwind rules were detected, but are not supported.", "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix", "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"].join(`
`)), !1
                    }), e.walkRules(s => {
                        if (i) return !1; s.walkRules(n => (i = !0, n.warn(t, ["Nested CSS was detected, but CSS nesting has not been configured correctly.", "Please enable a CSS nesting plugin *before* Tailwind in your configuration.", "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"].join(`
`)), !1))
                    })
                }
            } var eh = C(() => { l() }); function bs(r) { return function (e, t) { let { tailwindDirectives: i, applyDirectives: s } = Fa(e); Zd()(e, t), ws()(e, t); let n = r({ tailwindDirectives: i, applyDirectives: s, registerDependency(a) { t.messages.push({ plugin: "tailwindcss", parent: t.opts.from, ...a }) }, createContext(a, o) { return Ia(a, o, e) } })(e, t); if (n.tailwindConfig.separator === "-") throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead."); _f(n.tailwindConfig), Ba(n)(e, t), ws()(e, t), $a(n)(e, t), Ud(n)(e, t), Wd(n)(e, t), Za(n)(e, t), eo(n)(e, t), to(n)(e, t) } } var th = C(() => { l(); fd(); yd(); Cd(); Vd(); Gd(); Yd(); Jd(); Xd(); Kd(); eh(); ls(); Ve() }); var rh = w((AP, ro) => {
                l(); ud(); th(); We(); ro.exports = function (e) {
                    return {
                        postcssPlugin: "tailwindcss", plugins: [ge.DEBUG && function (t) {
                            return console.log(`
`), console.time("JIT TOTAL"), t
                        }, function (t, i) { let s = Na(e); if (t.type === "document") { let n = t.nodes.filter(a => a.type === "root"); for (let a of n) a.type === "root" && bs(s)(a, i); return } bs(s)(t, i) }, ge.DEBUG && function (t) {
                            return console.timeEnd("JIT TOTAL"), console.log(`
`), t
                        }].filter(Boolean)
                    }
                }; ro.exports.postcss = !0
            }); var io = w((OP, ih) => { l(); ih.exports = () => ["and_chr 92", "and_uc 12.12", "chrome 92", "chrome 91", "edge 91", "firefox 89", "ios_saf 14.5-14.7", "ios_saf 14.0-14.4", "safari 14.1", "samsung 14.0"] }); var xs = {}; de(xs, { agents: () => $S, feature: () => jS }); function jS() { return { status: "cr", title: "CSS Feature Queries", stats: { ie: { "6": "n", "7": "n", "8": "n", "9": "n", "10": "n", "11": "n", "5.5": "n" }, edge: { "12": "y", "13": "y", "14": "y", "15": "y", "16": "y", "17": "y", "18": "y", "79": "y", "80": "y", "81": "y", "83": "y", "84": "y", "85": "y", "86": "y", "87": "y", "88": "y", "89": "y", "90": "y", "91": "y", "92": "y" }, firefox: { "2": "n", "3": "n", "4": "n", "5": "n", "6": "n", "7": "n", "8": "n", "9": "n", "10": "n", "11": "n", "12": "n", "13": "n", "14": "n", "15": "n", "16": "n", "17": "n", "18": "n", "19": "n", "20": "n", "21": "n", "22": "y", "23": "y", "24": "y", "25": "y", "26": "y", "27": "y", "28": "y", "29": "y", "30": "y", "31": "y", "32": "y", "33": "y", "34": "y", "35": "y", "36": "y", "37": "y", "38": "y", "39": "y", "40": "y", "41": "y", "42": "y", "43": "y", "44": "y", "45": "y", "46": "y", "47": "y", "48": "y", "49": "y", "50": "y", "51": "y", "52": "y", "53": "y", "54": "y", "55": "y", "56": "y", "57": "y", "58": "y", "59": "y", "60": "y", "61": "y", "62": "y", "63": "y", "64": "y", "65": "y", "66": "y", "67": "y", "68": "y", "69": "y", "70": "y", "71": "y", "72": "y", "73": "y", "74": "y", "75": "y", "76": "y", "77": "y", "78": "y", "79": "y", "80": "y", "81": "y", "82": "y", "83": "y", "84": "y", "85": "y", "86": "y", "87": "y", "88": "y", "89": "y", "90": "y", "91": "y", "92": "y", "93": "y", "3.5": "n", "3.6": "n" }, chrome: { "4": "n", "5": "n", "6": "n", "7": "n", "8": "n", "9": "n", "10": "n", "11": "n", "12": "n", "13": "n", "14": "n", "15": "n", "16": "n", "17": "n", "18": "n", "19": "n", "20": "n", "21": "n", "22": "n", "23": "n", "24": "n", "25": "n", "26": "n", "27": "n", "28": "y", "29": "y", "30": "y", "31": "y", "32": "y", "33": "y", "34": "y", "35": "y", "36": "y", "37": "y", "38": "y", "39": "y", "40": "y", "41": "y", "42": "y", "43": "y", "44": "y", "45": "y", "46": "y", "47": "y", "48": "y", "49": "y", "50": "y", "51": "y", "52": "y", "53": "y", "54": "y", "55": "y", "56": "y", "57": "y", "58": "y", "59": "y", "60": "y", "61": "y", "62": "y", "63": "y", "64": "y", "65": "y", "66": "y", "67": "y", "68": "y", "69": "y", "70": "y", "71": "y", "72": "y", "73": "y", "74": "y", "75": "y", "76": "y", "77": "y", "78": "y", "79": "y", "80": "y", "81": "y", "83": "y", "84": "y", "85": "y", "86": "y", "87": "y", "88": "y", "89": "y", "90": "y", "91": "y", "92": "y", "93": "y", "94": "y", "95": "y" }, safari: { "4": "n", "5": "n", "6": "n", "7": "n", "8": "n", "9": "y", "10": "y", "11": "y", "12": "y", "13": "y", "14": "y", "15": "y", "9.1": "y", "10.1": "y", "11.1": "y", "12.1": "y", "13.1": "y", "14.1": "y", TP: "y", "3.1": "n", "3.2": "n", "5.1": "n", "6.1": "n", "7.1": "n" }, opera: { "9": "n", "11": "n", "12": "n", "15": "y", "16": "y", "17": "y", "18": "y", "19": "y", "20": "y", "21": "y", "22": "y", "23": "y", "24": "y", "25": "y", "26": "y", "27": "y", "28": "y", "29": "y", "30": "y", "31": "y", "32": "y", "33": "y", "34": "y", "35": "y", "36": "y", "37": "y", "38": "y", "39": "y", "40": "y", "41": "y", "42": "y", "43": "y", "44": "y", "45": "y", "46": "y", "47": "y", "48": "y", "49": "y", "50": "y", "51": "y", "52": "y", "53": "y", "54": "y", "55": "y", "56": "y", "57": "y", "58": "y", "60": "y", "62": "y", "63": "y", "64": "y", "65": "y", "66": "y", "67": "y", "68": "y", "69": "y", "70": "y", "71": "y", "72": "y", "73": "y", "74": "y", "75": "y", "76": "y", "77": "y", "78": "y", "12.1": "y", "9.5-9.6": "n", "10.0-10.1": "n", "10.5": "n", "10.6": "n", "11.1": "n", "11.5": "n", "11.6": "n" }, ios_saf: { "8": "n", "9.0-9.2": "y", "9.3": "y", "10.0-10.2": "y", "10.3": "y", "11.0-11.2": "y", "11.3-11.4": "y", "12.0-12.1": "y", "12.2-12.4": "y", "13.0-13.1": "y", "13.2": "y", "13.3": "y", "13.4-13.7": "y", "14.0-14.4": "y", "14.5-14.7": "y", "3.2": "n", "4.0-4.1": "n", "4.2-4.3": "n", "5.0-5.1": "n", "6.0-6.1": "n", "7.0-7.1": "n", "8.1-8.4": "n" }, op_mini: { all: "y" }, android: { "3": "n", "4": "n", "92": "y", "4.4": "y", "4.4.3-4.4.4": "y", "2.1": "n", "2.2": "n", "2.3": "n", "4.1": "n", "4.2-4.3": "n" }, bb: { "7": "n", "10": "n" }, op_mob: { "10": "n", "11": "n", "12": "n", "64": "y", "11.1": "n", "11.5": "n", "12.1": "n" }, and_chr: { "92": "y" }, and_ff: { "90": "y" }, ie_mob: { "10": "n", "11": "n" }, and_uc: { "12.12": "y" }, samsung: { "4": "y", "5.0-5.4": "y", "6.2-6.4": "y", "7.2-7.4": "y", "8.2": "y", "9.2": "y", "10.1": "y", "11.1-11.2": "y", "12.0": "y", "13.0": "y", "14.0": "y" }, and_qq: { "10.4": "y" }, baidu: { "7.12": "y" }, kaios: { "2.5": "y" } } } } var $S, vs = C(() => { l(); $S = { ie: { prefix: "ms" }, edge: { prefix: "webkit", prefix_exceptions: { "12": "ms", "13": "ms", "14": "ms", "15": "ms", "16": "ms", "17": "ms", "18": "ms" } }, firefox: { prefix: "moz" }, chrome: { prefix: "webkit" }, safari: { prefix: "webkit" }, opera: { prefix: "webkit", prefix_exceptions: { "9": "o", "11": "o", "12": "o", "9.5-9.6": "o", "10.0-10.1": "o", "10.5": "o", "10.6": "o", "11.1": "o", "11.5": "o", "11.6": "o", "12.1": "o" } }, ios_saf: { prefix: "webkit" }, op_mini: { prefix: "o" }, android: { prefix: "webkit" }, bb: { prefix: "webkit" }, op_mob: { prefix: "o", prefix_exceptions: { "64": "webkit" } }, and_chr: { prefix: "webkit" }, and_ff: { prefix: "moz" }, ie_mob: { prefix: "ms" }, and_uc: { prefix: "webkit", prefix_exceptions: { "12.12": "webkit" } }, samsung: { prefix: "webkit" }, and_qq: { prefix: "webkit" }, baidu: { prefix: "webkit" }, kaios: { prefix: "moz" } } }); var sh = w(() => { l() }); var Z = w((PP, Xe) => { l(); var { list: so } = ue(); Xe.exports.error = function (r) { let e = new Error(r); throw e.autoprefixer = !0, e }; Xe.exports.uniq = function (r) { return [...new Set(r)] }; Xe.exports.removeNote = function (r) { return r.includes(" ") ? r.split(" ")[0] : r }; Xe.exports.escapeRegexp = function (r) { return r.replace(/[$()*+-.?[\\\]^{|}]/g, "\\$&") }; Xe.exports.regexp = function (r, e = !0) { return e && (r = this.escapeRegexp(r)), new RegExp(`(^|[\\s,(])(${r}($|[\\s(,]))`, "gi") }; Xe.exports.editList = function (r, e) { let t = so.comma(r), i = e(t, []); if (t === i) return r; let s = r.match(/,\s*/); return s = s ? s[0] : ", ", i.join(s) }; Xe.exports.splitSelector = function (r) { return so.comma(r).map(e => so.space(e).map(t => t.split(/(?=\.|#)/g))) } }); var Ke = w((DP, oh) => { l(); var US = io(), nh = (vs(), xs).agents, VS = Z(), ah = class { static prefixes() { if (this.prefixesCache) return this.prefixesCache; this.prefixesCache = []; for (let e in nh) this.prefixesCache.push(`-${nh[e].prefix}-`); return this.prefixesCache = VS.uniq(this.prefixesCache).sort((e, t) => t.length - e.length), this.prefixesCache } static withPrefix(e) { return this.prefixesRegexp || (this.prefixesRegexp = new RegExp(this.prefixes().join("|"))), this.prefixesRegexp.test(e) } constructor(e, t, i, s) { this.data = e, this.options = i || {}, this.browserslistOpts = s || {}, this.selected = this.parse(t) } parse(e) { let t = {}; for (let i in this.browserslistOpts) t[i] = this.browserslistOpts[i]; return t.path = this.options.from, US(e, t) } prefix(e) { let [t, i] = e.split(" "), s = this.data[t], n = s.prefix_exceptions && s.prefix_exceptions[i]; return n || (n = s.prefix), `-${n}-` } isSelected(e) { return this.selected.includes(e) } }; oh.exports = ah }); var Gr = w((qP, lh) => { l(); lh.exports = { prefix(r) { let e = r.match(/^(-\w+-)/); return e ? e[0] : "" }, unprefixed(r) { return r.replace(/^-\w+-/, "") } } }); var qt = w((IP, fh) => { l(); var WS = Ke(), uh = Gr(), GS = Z(); function no(r, e) { let t = new r.constructor; for (let i of Object.keys(r || {})) { let s = r[i]; i === "parent" && typeof s == "object" ? e && (t[i] = e) : i === "source" || i === null ? t[i] = s : Array.isArray(s) ? t[i] = s.map(n => no(n, t)) : i !== "_autoprefixerPrefix" && i !== "_autoprefixerValues" && i !== "proxyCache" && (typeof s == "object" && s !== null && (s = no(s, t)), t[i] = s) } return t } var ks = class { static hack(e) { return this.hacks || (this.hacks = {}), e.names.map(t => (this.hacks[t] = e, this.hacks[t])) } static load(e, t, i) { let s = this.hacks && this.hacks[e]; return s ? new s(e, t, i) : new this(e, t, i) } static clone(e, t) { let i = no(e); for (let s in t) i[s] = t[s]; return i } constructor(e, t, i) { this.prefixes = t, this.name = e, this.all = i } parentPrefix(e) { let t; return typeof e._autoprefixerPrefix != "undefined" ? t = e._autoprefixerPrefix : e.type === "decl" && e.prop[0] === "-" ? t = uh.prefix(e.prop) : e.type === "root" ? t = !1 : e.type === "rule" && e.selector.includes(":-") && /:(-\w+-)/.test(e.selector) ? t = e.selector.match(/:(-\w+-)/)[1] : e.type === "atrule" && e.name[0] === "-" ? t = uh.prefix(e.name) : t = this.parentPrefix(e.parent), WS.prefixes().includes(t) || (t = !1), e._autoprefixerPrefix = t, e._autoprefixerPrefix } process(e, t) { if (!this.check(e)) return; let i = this.parentPrefix(e), s = this.prefixes.filter(a => !i || i === GS.removeNote(a)), n = []; for (let a of s) this.add(e, a, n.concat([a]), t) && n.push(a); return n } clone(e, t) { return ks.clone(e, t) } }; fh.exports = ks }); var D = w((RP, dh) => {
                l(); var HS = qt(), YS = Ke(), ch = Z(), ph = class extends HS {
                    check() { return !0 } prefixed(e, t) { return t + e } normalize(e) { return e } otherPrefixes(e, t) { for (let i of YS.prefixes()) if (i !== t && e.includes(i)) return !0; return !1 } set(e, t) { return e.prop = this.prefixed(e.prop, t), e } needCascade(e) {
                        return e._autoprefixerCascade || (e._autoprefixerCascade = this.all.options.cascade !== !1 && e.raw("before").includes(`
`)), e._autoprefixerCascade
                    } maxPrefixed(e, t) { if (t._autoprefixerMax) return t._autoprefixerMax; let i = 0; for (let s of e) s = ch.removeNote(s), s.length > i && (i = s.length); return t._autoprefixerMax = i, t._autoprefixerMax } calcBefore(e, t, i = "") { let n = this.maxPrefixed(e, t) - ch.removeNote(i).length, a = t.raw("before"); return n > 0 && (a += Array(n).fill(" ").join("")), a } restoreBefore(e) {
                        let t = e.raw("before").split(`
`), i = t[t.length - 1]; this.all.group(e).up(s => {
                            let n = s.raw("before").split(`
`), a = n[n.length - 1]; a.length < i.length && (i = a)
                        }), t[t.length - 1] = i, e.raws.before = t.join(`
`)
                    } insert(e, t, i) { let s = this.set(this.clone(e), t); if (!(!s || e.parent.some(a => a.prop === s.prop && a.value === s.value))) return this.needCascade(e) && (s.raws.before = this.calcBefore(i, e, t)), e.parent.insertBefore(e, s) } isAlready(e, t) { let i = this.all.group(e).up(s => s.prop === t); return i || (i = this.all.group(e).down(s => s.prop === t)), i } add(e, t, i, s) { let n = this.prefixed(e.prop, t); if (!(this.isAlready(e, n) || this.otherPrefixes(e.value, t))) return this.insert(e, t, i, s) } process(e, t) { if (!this.needCascade(e)) { super.process(e, t); return } let i = super.process(e, t); !i || !i.length || (this.restoreBefore(e), e.raws.before = this.calcBefore(i, e)) } old(e, t) { return [this.prefixed(e, t)] }
                }; dh.exports = ph
            }); var mh = w((MP, hh) => { l(); hh.exports = function r(e) { return { mul: t => new r(e * t), div: t => new r(e / t), simplify: () => new r(e), toString: () => e.toString() } } }); var wh = w((LP, yh) => { l(); var QS = mh(), JS = qt(), ao = Z(), XS = /(min|max)-resolution\s*:\s*\d*\.?\d+(dppx|dpcm|dpi|x)/gi, KS = /(min|max)-resolution(\s*:\s*)(\d*\.?\d+)(dppx|dpcm|dpi|x)/i, gh = class extends JS { prefixName(e, t) { return e === "-moz-" ? t + "--moz-device-pixel-ratio" : e + t + "-device-pixel-ratio" } prefixQuery(e, t, i, s, n) { return s = new QS(s), n === "dpi" ? s = s.div(96) : n === "dpcm" && (s = s.mul(2.54).div(96)), s = s.simplify(), e === "-o-" && (s = s.n + "/" + s.d), this.prefixName(e, t) + i + s } clean(e) { if (!this.bad) { this.bad = []; for (let t of this.prefixes) this.bad.push(this.prefixName(t, "min")), this.bad.push(this.prefixName(t, "max")) } e.params = ao.editList(e.params, t => t.filter(i => this.bad.every(s => !i.includes(s)))) } process(e) { let t = this.parentPrefix(e), i = t ? [t] : this.prefixes; e.params = ao.editList(e.params, (s, n) => { for (let a of s) { if (!a.includes("min-resolution") && !a.includes("max-resolution")) { n.push(a); continue } for (let o of i) { let u = a.replace(XS, f => { let c = f.match(KS); return this.prefixQuery(o, c[1], c[2], c[3], c[4]) }); n.push(u) } n.push(a) } return ao.uniq(n) }) } }; yh.exports = gh }); var Sh = w((NP, kh) => { l(); var { list: ZS } = ue(), bh = Vr(), e2 = Ke(), xh = Gr(), vh = class { constructor(e) { this.props = ["transition", "transition-property"], this.prefixes = e } add(e, t) { let i, s, n = this.prefixes.add[e.prop], a = this.ruleVendorPrefixes(e), o = a || n && n.prefixes || [], u = this.parse(e.value), f = u.map(d => this.findProp(d)), c = []; if (f.some(d => d[0] === "-")) return; for (let d of u) { if (s = this.findProp(d), s[0] === "-") continue; let y = this.prefixes.add[s]; if (!(!y || !y.prefixes)) for (i of y.prefixes) { if (a && !a.some(b => i.includes(b))) continue; let v = this.prefixes.prefixed(s, i); v !== "-ms-transform" && !f.includes(v) && (this.disabled(s, i) || c.push(this.clone(s, v, d))) } } u = u.concat(c); let h = this.stringify(u), p = this.stringify(this.cleanFromUnprefixed(u, "-webkit-")); if (o.includes("-webkit-") && this.cloneBefore(e, `-webkit-${e.prop}`, p), this.cloneBefore(e, e.prop, p), o.includes("-o-")) { let d = this.stringify(this.cleanFromUnprefixed(u, "-o-")); this.cloneBefore(e, `-o-${e.prop}`, d) } for (i of o) if (i !== "-webkit-" && i !== "-o-") { let d = this.stringify(this.cleanOtherPrefixes(u, i)); this.cloneBefore(e, i + e.prop, d) } h !== e.value && !this.already(e, e.prop, h) && (this.checkForWarning(t, e), e.cloneBefore(), e.value = h) } findProp(e) { let t = e[0].value; if (/^\d/.test(t)) { for (let [i, s] of e.entries()) if (i !== 0 && s.type === "word") return s.value } return t } already(e, t, i) { return e.parent.some(s => s.prop === t && s.value === i) } cloneBefore(e, t, i) { this.already(e, t, i) || e.cloneBefore({ prop: t, value: i }) } checkForWarning(e, t) { if (t.prop !== "transition-property") return; let i = !1, s = !1; t.parent.each(n => { if (n.type !== "decl" || n.prop.indexOf("transition-") !== 0) return; let a = ZS.comma(n.value); if (n.prop === "transition-property") { a.forEach(o => { let u = this.prefixes.add[o]; u && u.prefixes && u.prefixes.length > 0 && (i = !0) }); return } return s = s || a.length > 1, !1 }), i && s && t.warn(e, "Replace transition-property to transition, because Autoprefixer could not support any cases of transition-property and other transition-*") } remove(e) { let t = this.parse(e.value); t = t.filter(a => { let o = this.prefixes.remove[this.findProp(a)]; return !o || !o.remove }); let i = this.stringify(t); if (e.value === i) return; if (t.length === 0) { e.remove(); return } let s = e.parent.some(a => a.prop === e.prop && a.value === i), n = e.parent.some(a => a !== e && a.prop === e.prop && a.value.length > i.length); if (s || n) { e.remove(); return } e.value = i } parse(e) { let t = bh(e), i = [], s = []; for (let n of t.nodes) s.push(n), n.type === "div" && n.value === "," && (i.push(s), s = []); return i.push(s), i.filter(n => n.length > 0) } stringify(e) { if (e.length === 0) return ""; let t = []; for (let i of e) i[i.length - 1].type !== "div" && i.push(this.div(e)), t = t.concat(i); return t[0].type === "div" && (t = t.slice(1)), t[t.length - 1].type === "div" && (t = t.slice(0, -2 + 1 || void 0)), bh.stringify({ nodes: t }) } clone(e, t, i) { let s = [], n = !1; for (let a of i) !n && a.type === "word" && a.value === e ? (s.push({ type: "word", value: t }), n = !0) : s.push(a); return s } div(e) { for (let t of e) for (let i of t) if (i.type === "div" && i.value === ",") return i; return { type: "div", value: ",", after: " " } } cleanOtherPrefixes(e, t) { return e.filter(i => { let s = xh.prefix(this.findProp(i)); return s === "" || s === t }) } cleanFromUnprefixed(e, t) { let i = e.map(n => this.findProp(n)).filter(n => n.slice(0, t.length) === t).map(n => this.prefixes.unprefixed(n)), s = []; for (let n of e) { let a = this.findProp(n), o = xh.prefix(a); !i.includes(a) && (o === t || o === "") && s.push(n) } return s } disabled(e, t) { let i = ["order", "justify-content", "align-self", "align-content"]; if (e.includes("flex") || i.includes(e)) { if (this.prefixes.options.flexbox === !1) return !0; if (this.prefixes.options.flexbox === "no-2009") return t.includes("2009") } } ruleVendorPrefixes(e) { let { parent: t } = e; if (t.type !== "rule") return !1; if (!t.selector.includes(":-")) return !1; let i = e2.prefixes().filter(s => t.selector.includes(":" + s)); return i.length > 0 ? i : !1 } }; kh.exports = vh }); var It = w((FP, _h) => { l(); var t2 = Z(), Ch = class { constructor(e, t, i, s) { this.unprefixed = e, this.prefixed = t, this.string = i || t, this.regexp = s || t2.regexp(t) } check(e) { return e.includes(this.string) ? !!e.match(this.regexp) : !1 } }; _h.exports = Ch }); var ce = w((BP, Oh) => { l(); var r2 = qt(), i2 = It(), s2 = Gr(), n2 = Z(), Ah = class extends r2 { static save(e, t) { let i = t.prop, s = []; for (let n in t._autoprefixerValues) { let a = t._autoprefixerValues[n]; if (a === t.value) continue; let o, u = s2.prefix(i); if (u === "-pie-") continue; if (u === n) { o = t.value = a, s.push(o); continue } let f = e.prefixed(i, n), c = t.parent; if (!c.every(y => y.prop !== f)) { s.push(o); continue } let h = a.replace(/\s+/, " "); if (c.some(y => y.prop === t.prop && y.value.replace(/\s+/, " ") === h)) { s.push(o); continue } let d = this.clone(t, { value: a }); o = t.parent.insertBefore(t, d), s.push(o) } return s } check(e) { let t = e.value; return t.includes(this.name) ? !!t.match(this.regexp()) : !1 } regexp() { return this.regexpCache || (this.regexpCache = n2.regexp(this.name)) } replace(e, t) { return e.replace(this.regexp(), `$1${t}$2`) } value(e) { return e.raws.value && e.raws.value.value === e.value ? e.raws.value.raw : e.value } add(e, t) { e._autoprefixerValues || (e._autoprefixerValues = {}); let i = e._autoprefixerValues[t] || this.value(e), s; do if (s = i, i = this.replace(i, t), i === !1) return; while (i !== s); e._autoprefixerValues[t] = i } old(e) { return new i2(this.name, e + this.name) } }; Oh.exports = Ah }); var Ze = w((zP, Eh) => { l(); Eh.exports = {} }); var lo = w(($P, Dh) => {
                l(); var Th = Vr(), a2 = ce(), o2 = Ze().insertAreas, l2 = /(^|[^-])linear-gradient\(\s*(top|left|right|bottom)/i, u2 = /(^|[^-])radial-gradient\(\s*\d+(\w*|%)\s+\d+(\w*|%)\s*,/i, f2 = /(!\s*)?autoprefixer:\s*ignore\s+next/i, c2 = /(!\s*)?autoprefixer\s*grid:\s*(on|off|(no-)?autoplace)/i, p2 = ["width", "height", "min-width", "max-width", "min-height", "max-height", "inline-size", "min-inline-size", "max-inline-size", "block-size", "min-block-size", "max-block-size"]; function oo(r) { return r.parent.some(e => e.prop === "grid-template" || e.prop === "grid-template-areas") } function d2(r) { let e = r.parent.some(i => i.prop === "grid-template-rows"), t = r.parent.some(i => i.prop === "grid-template-columns"); return e && t } var Ph = class {
                    constructor(e) { this.prefixes = e } add(e, t) { let i = this.prefixes.add["@resolution"], s = this.prefixes.add["@keyframes"], n = this.prefixes.add["@viewport"], a = this.prefixes.add["@supports"]; e.walkAtRules(c => { if (c.name === "keyframes") { if (!this.disabled(c, t)) return s && s.process(c) } else if (c.name === "viewport") { if (!this.disabled(c, t)) return n && n.process(c) } else if (c.name === "supports") { if (this.prefixes.options.supports !== !1 && !this.disabled(c, t)) return a.process(c) } else if (c.name === "media" && c.params.includes("-resolution") && !this.disabled(c, t)) return i && i.process(c) }), e.walkRules(c => { if (!this.disabled(c, t)) return this.prefixes.add.selectors.map(h => h.process(c, t)) }); function o(c) { return c.parent.nodes.some(h => { if (h.type !== "decl") return !1; let p = h.prop === "display" && /(inline-)?grid/.test(h.value), d = h.prop.startsWith("grid-template"), y = /^grid-([A-z]+-)?gap/.test(h.prop); return p || d || y }) } function u(c) { return c.parent.some(h => h.prop === "display" && /(inline-)?flex/.test(h.value)) } let f = this.gridStatus(e, t) && this.prefixes.add["grid-area"] && this.prefixes.add["grid-area"].prefixes; return e.walkDecls(c => { if (this.disabledDecl(c, t)) return; let h = c.parent, p = c.prop, d = c.value; if (p === "grid-row-span") { t.warn("grid-row-span is not part of final Grid Layout. Use grid-row.", { node: c }); return } else if (p === "grid-column-span") { t.warn("grid-column-span is not part of final Grid Layout. Use grid-column.", { node: c }); return } else if (p === "display" && d === "box") { t.warn("You should write display: flex by final spec instead of display: box", { node: c }); return } else if (p === "text-emphasis-position") (d === "under" || d === "over") && t.warn("You should use 2 values for text-emphasis-position For example, `under left` instead of just `under`.", { node: c }); else if (/^(align|justify|place)-(items|content)$/.test(p) && u(c)) (d === "start" || d === "end") && t.warn(`${d} value has mixed support, consider using flex-${d} instead`, { node: c }); else if (p === "text-decoration-skip" && d === "ink") t.warn("Replace text-decoration-skip: ink to text-decoration-skip-ink: auto, because spec had been changed", { node: c }); else { if (f && this.gridStatus(c, t)) if (c.value === "subgrid" && t.warn("IE does not support subgrid", { node: c }), /^(align|justify|place)-items$/.test(p) && o(c)) { let v = p.replace("-items", "-self"); t.warn(`IE does not support ${p} on grid containers. Try using ${v} on child elements instead: ${c.parent.selector} > * { ${v}: ${c.value} }`, { node: c }) } else if (/^(align|justify|place)-content$/.test(p) && o(c)) t.warn(`IE does not support ${c.prop} on grid containers`, { node: c }); else if (p === "display" && c.value === "contents") { t.warn("Please do not use display: contents; if you have grid setting enabled", { node: c }); return } else if (c.prop === "grid-gap") { let v = this.gridStatus(c, t); v === "autoplace" && !d2(c) && !oo(c) ? t.warn("grid-gap only works if grid-template(-areas) is being used or both rows and columns have been declared and cells have not been manually placed inside the explicit grid", { node: c }) : (v === !0 || v === "no-autoplace") && !oo(c) && t.warn("grid-gap only works if grid-template(-areas) is being used", { node: c }) } else if (p === "grid-auto-columns") { t.warn("grid-auto-columns is not supported by IE", { node: c }); return } else if (p === "grid-auto-rows") { t.warn("grid-auto-rows is not supported by IE", { node: c }); return } else if (p === "grid-auto-flow") { let v = h.some(x => x.prop === "grid-template-rows"), b = h.some(x => x.prop === "grid-template-columns"); oo(c) ? t.warn("grid-auto-flow is not supported by IE", { node: c }) : d.includes("dense") ? t.warn("grid-auto-flow: dense is not supported by IE", { node: c }) : !v && !b && t.warn("grid-auto-flow works only if grid-template-rows and grid-template-columns are present in the same rule", { node: c }); return } else if (d.includes("auto-fit")) { t.warn("auto-fit value is not supported by IE", { node: c, word: "auto-fit" }); return } else if (d.includes("auto-fill")) { t.warn("auto-fill value is not supported by IE", { node: c, word: "auto-fill" }); return } else p.startsWith("grid-template") && d.includes("[") && t.warn("Autoprefixer currently does not support line names. Try using grid-template-areas instead.", { node: c, word: "[" }); if (d.includes("radial-gradient")) if (u2.test(c.value)) t.warn("Gradient has outdated direction syntax. New syntax is like `closest-side at 0 0` instead of `0 0, closest-side`.", { node: c }); else { let v = Th(d); for (let b of v.nodes) if (b.type === "function" && b.value === "radial-gradient") for (let x of b.nodes) x.type === "word" && (x.value === "cover" ? t.warn("Gradient has outdated direction syntax. Replace `cover` to `farthest-corner`.", { node: c }) : x.value === "contain" && t.warn("Gradient has outdated direction syntax. Replace `contain` to `closest-side`.", { node: c })) } d.includes("linear-gradient") && l2.test(d) && t.warn("Gradient has outdated direction syntax. New syntax is like `to left` instead of `right`.", { node: c }) } p2.includes(c.prop) && (c.value.includes("-fill-available") || (c.value.includes("fill-available") ? t.warn("Replace fill-available to stretch, because spec had been changed", { node: c }) : c.value.includes("fill") && Th(d).nodes.some(b => b.type === "word" && b.value === "fill") && t.warn("Replace fill to stretch, because spec had been changed", { node: c }))); let y; if (c.prop === "transition" || c.prop === "transition-property") return this.prefixes.transition.add(c, t); if (c.prop === "align-self") { if (this.displayType(c) !== "grid" && this.prefixes.options.flexbox !== !1 && (y = this.prefixes.add["align-self"], y && y.prefixes && y.process(c)), this.gridStatus(c, t) !== !1 && (y = this.prefixes.add["grid-row-align"], y && y.prefixes)) return y.process(c, t) } else if (c.prop === "justify-self") { if (this.gridStatus(c, t) !== !1 && (y = this.prefixes.add["grid-column-align"], y && y.prefixes)) return y.process(c, t) } else if (c.prop === "place-self") { if (y = this.prefixes.add["place-self"], y && y.prefixes && this.gridStatus(c, t) !== !1) return y.process(c, t) } else if (y = this.prefixes.add[c.prop], y && y.prefixes) return y.process(c, t) }), this.gridStatus(e, t) && o2(e, this.disabled), e.walkDecls(c => { if (this.disabledValue(c, t)) return; let h = this.prefixes.unprefixed(c.prop), p = this.prefixes.values("add", h); if (Array.isArray(p)) for (let d of p) d.process && d.process(c, t); a2.save(this.prefixes, c) }) } remove(e, t) {
                        let i = this.prefixes.remove["@resolution"]; e.walkAtRules((s, n) => { this.prefixes.remove[`@${s.name}`] ? this.disabled(s, t) || s.parent.removeChild(n) : s.name === "media" && s.params.includes("-resolution") && i && i.clean(s) }); for (let s of this.prefixes.remove.selectors) e.walkRules((n, a) => { s.check(n) && (this.disabled(n, t) || n.parent.removeChild(a)) }); return e.walkDecls((s, n) => {
                            if (this.disabled(s, t)) return; let a = s.parent, o = this.prefixes.unprefixed(s.prop); if ((s.prop === "transition" || s.prop === "transition-property") && this.prefixes.transition.remove(s), this.prefixes.remove[s.prop] && this.prefixes.remove[s.prop].remove) {
                                let u = this.prefixes.group(s).down(f => this.prefixes.normalize(f.prop) === o); if (o === "flex-flow" && (u = !0), s.prop === "-webkit-box-orient") { let f = { "flex-direction": !0, "flex-flow": !0 }; if (!s.parent.some(c => f[c.prop])) return } if (u && !this.withHackValue(s)) {
                                    s.raw("before").includes(`
`) && this.reduceSpaces(s), a.removeChild(n); return
                                }
                            } for (let u of this.prefixes.values("remove", o)) { if (!u.check || !u.check(s.value)) continue; if (o = u.unprefixed, this.prefixes.group(s).down(c => c.value.includes(o))) { a.removeChild(n); return } }
                        })
                    } withHackValue(e) { return e.prop === "-webkit-background-clip" && e.value === "text" } disabledValue(e, t) { return this.gridStatus(e, t) === !1 && e.type === "decl" && e.prop === "display" && e.value.includes("grid") || this.prefixes.options.flexbox === !1 && e.type === "decl" && e.prop === "display" && e.value.includes("flex") || e.type === "decl" && e.prop === "content" ? !0 : this.disabled(e, t) } disabledDecl(e, t) { if (this.gridStatus(e, t) === !1 && e.type === "decl" && (e.prop.includes("grid") || e.prop === "justify-items")) return !0; if (this.prefixes.options.flexbox === !1 && e.type === "decl") { let i = ["order", "justify-content", "align-items", "align-content"]; if (e.prop.includes("flex") || i.includes(e.prop)) return !0 } return this.disabled(e, t) } disabled(e, t) { if (!e) return !1; if (e._autoprefixerDisabled !== void 0) return e._autoprefixerDisabled; if (e.parent) { let s = e.prev(); if (s && s.type === "comment" && f2.test(s.text)) return e._autoprefixerDisabled = !0, e._autoprefixerSelfDisabled = !0, !0 } let i = null; if (e.nodes) { let s; e.each(n => { n.type === "comment" && /(!\s*)?autoprefixer:\s*(off|on)/i.test(n.text) && (typeof s != "undefined" ? t.warn("Second Autoprefixer control comment was ignored. Autoprefixer applies control comment to whole block, not to next rules.", { node: n }) : s = /on/i.test(n.text)) }), s !== void 0 && (i = !s) } if (!e.nodes || i === null) if (e.parent) { let s = this.disabled(e.parent, t); e.parent._autoprefixerSelfDisabled === !0 ? i = !1 : i = s } else i = !1; return e._autoprefixerDisabled = i, i } reduceSpaces(e) {
                        let t = !1; if (this.prefixes.group(e).up(() => (t = !0, !0)), t) return; let i = e.raw("before").split(`
`), s = i[i.length - 1].length, n = !1; this.prefixes.group(e).down(a => {
                            i = a.raw("before").split(`
`); let o = i.length - 1; i[o].length > s && (n === !1 && (n = i[o].length - s), i[o] = i[o].slice(0, -n), a.raws.before = i.join(`
`))
                        })
                    } displayType(e) { for (let t of e.parent.nodes) if (t.prop === "display") { if (t.value.includes("flex")) return "flex"; if (t.value.includes("grid")) return "grid" } return !1 } gridStatus(e, t) { if (!e) return !1; if (e._autoprefixerGridStatus !== void 0) return e._autoprefixerGridStatus; let i = null; if (e.nodes) { let s; e.each(n => { if (n.type === "comment" && c2.test(n.text)) { let a = /:\s*autoplace/i.test(n.text), o = /no-autoplace/i.test(n.text); typeof s != "undefined" ? t.warn("Second Autoprefixer grid control comment was ignored. Autoprefixer applies control comments to the whole block, not to the next rules.", { node: n }) : a ? s = "autoplace" : o ? s = !0 : s = /on/i.test(n.text) } }), s !== void 0 && (i = s) } if (e.type === "atrule" && e.name === "supports") { let s = e.params; s.includes("grid") && s.includes("auto") && (i = !1) } if (!e.nodes || i === null) if (e.parent) { let s = this.gridStatus(e.parent, t); e.parent._autoprefixerSelfDisabled === !0 ? i = !1 : i = s } else typeof this.prefixes.options.grid != "undefined" ? i = this.prefixes.options.grid : typeof m.env.AUTOPREFIXER_GRID != "undefined" ? m.env.AUTOPREFIXER_GRID === "autoplace" ? i = "autoplace" : i = !0 : i = !1; return e._autoprefixerGridStatus = i, i }
                }; Dh.exports = Ph
            }); var Ih = w((jP, qh) => { l(); qh.exports = { A: { A: { "2": "J D E F A B iB" }, B: { "1": "C K L G M N O R S T U V W X Y Z a P b H" }, C: { "1": "0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T kB U V W X Y Z a P b H dB", "2": "jB aB I c J D E F A B C K L G M N O d e f lB mB" }, D: { "1": "0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v w x y z AB BB CB DB EB FB GB bB HB cB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB R S T U V W X Y Z a P b H dB nB oB", "2": "I c J D E F A B C K L G M N O d e f g h i j k l" }, E: { "1": "F A B C K L G tB fB YB ZB uB vB wB", "2": "I c J D E pB eB qB rB sB" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 G M N O d e f g h i j k l m n o p q r s t u v w x y z AB BB CB DB EB FB GB HB IB JB Q KB LB MB NB OB PB QB RB SB TB UB VB WB XB ZB", "2": "F B C xB yB zB 0B YB gB 1B" }, G: { "1": "7B 8B 9B AC BC CC DC EC FC GC HC IC JC KC", "2": "E eB 2B hB 3B 4B 5B 6B" }, H: { "1": "LC" }, I: { "1": "H QC RC", "2": "aB I MC NC OC PC hB" }, J: { "2": "D A" }, K: { "1": "Q", "2": "A B C YB gB ZB" }, L: { "1": "H" }, M: { "1": "P" }, N: { "2": "A B" }, O: { "1": "SC" }, P: { "1": "I TC UC VC WC XC fB YC ZC aC bC" }, Q: { "1": "cC" }, R: { "1": "dC" }, S: { "1": "eC" } }, B: 4, C: "CSS Feature Queries" } }); var Nh = w((UP, Lh) => { l(); function Rh(r) { return r[r.length - 1] } var Mh = { parse(r) { let e = [""], t = [e]; for (let i of r) { if (i === "(") { e = [""], Rh(t).push(e), t.push(e); continue } if (i === ")") { t.pop(), e = Rh(t), e.push(""); continue } e[e.length - 1] += i } return t[0] }, stringify(r) { let e = ""; for (let t of r) { if (typeof t == "object") { e += `(${Mh.stringify(t)})`; continue } e += t } return e } }; Lh.exports = Mh }); var jh = w((VP, $h) => { l(); var h2 = Ih(), { feature: m2 } = (vs(), xs), { parse: g2 } = ue(), y2 = Ke(), uo = Nh(), w2 = ce(), b2 = Z(), Fh = m2(h2), Bh = []; for (let r in Fh.stats) { let e = Fh.stats[r]; for (let t in e) { let i = e[t]; /y/.test(i) && Bh.push(r + " " + t) } } var zh = class { constructor(e, t) { this.Prefixes = e, this.all = t } prefixer() { if (this.prefixerCache) return this.prefixerCache; let e = this.all.browsers.selected.filter(i => Bh.includes(i)), t = new y2(this.all.browsers.data, e, this.all.options); return this.prefixerCache = new this.Prefixes(this.all.data, t, this.all.options), this.prefixerCache } parse(e) { let t = e.split(":"), i = t[0], s = t[1]; return s || (s = ""), [i.trim(), s.trim()] } virtual(e) { let [t, i] = this.parse(e), s = g2("a{}").first; return s.append({ prop: t, value: i, raws: { before: "" } }), s } prefixed(e) { let t = this.virtual(e); if (this.disabled(t.first)) return t.nodes; let i = { warn: () => null }, s = this.prefixer().add[t.first.prop]; s && s.process && s.process(t.first, i); for (let n of t.nodes) { for (let a of this.prefixer().values("add", t.first.prop)) a.process(n); w2.save(this.all, n) } return t.nodes } isNot(e) { return typeof e == "string" && /not\s*/i.test(e) } isOr(e) { return typeof e == "string" && /\s*or\s*/i.test(e) } isProp(e) { return typeof e == "object" && e.length === 1 && typeof e[0] == "string" } isHack(e, t) { return !new RegExp(`(\\(|\\s)${b2.escapeRegexp(t)}:`).test(e) } toRemove(e, t) { let [i, s] = this.parse(e), n = this.all.unprefixed(i), a = this.all.cleaner(); if (a.remove[i] && a.remove[i].remove && !this.isHack(t, n)) return !0; for (let o of a.values("remove", n)) if (o.check(s)) return !0; return !1 } remove(e, t) { let i = 0; for (; i < e.length;) { if (!this.isNot(e[i - 1]) && this.isProp(e[i]) && this.isOr(e[i + 1])) { if (this.toRemove(e[i][0], t)) { e.splice(i, 2); continue } i += 2; continue } typeof e[i] == "object" && (e[i] = this.remove(e[i], t)), i += 1 } return e } cleanBrackets(e) { return e.map(t => typeof t != "object" ? t : t.length === 1 && typeof t[0] == "object" ? this.cleanBrackets(t[0]) : this.cleanBrackets(t)) } convert(e) { let t = [""]; for (let i of e) t.push([`${i.prop}: ${i.value}`]), t.push(" or "); return t[t.length - 1] = "", t } normalize(e) { if (typeof e != "object") return e; if (e = e.filter(t => t !== ""), typeof e[0] == "string") { let t = e[0].trim(); if (t.includes(":") || t === "selector" || t === "not selector") return [uo.stringify(e)] } return e.map(t => this.normalize(t)) } add(e, t) { return e.map(i => { if (this.isProp(i)) { let s = this.prefixed(i[0]); return s.length > 1 ? this.convert(s) : i } return typeof i == "object" ? this.add(i, t) : i }) } process(e) { let t = uo.parse(e.params); t = this.normalize(t), t = this.remove(t, e.params), t = this.add(t, e.params), t = this.cleanBrackets(t), e.params = uo.stringify(t) } disabled(e) { if (!this.all.options.grid && (e.prop === "display" && e.value.includes("grid") || e.prop.includes("grid") || e.prop === "justify-items")) return !0; if (this.all.options.flexbox === !1) { if (e.prop === "display" && e.value.includes("flex")) return !0; let t = ["order", "justify-content", "align-items", "align-content"]; if (e.prop.includes("flex") || t.includes(e.prop)) return !0 } return !1 } }; $h.exports = zh }); var Wh = w((WP, Vh) => { l(); var Uh = class { constructor(e, t) { this.prefix = t, this.prefixed = e.prefixed(this.prefix), this.regexp = e.regexp(this.prefix), this.prefixeds = e.possible().map(i => [e.prefixed(i), e.regexp(i)]), this.unprefixed = e.name, this.nameRegexp = e.regexp() } isHack(e) { let t = e.parent.index(e) + 1, i = e.parent.nodes; for (; t < i.length;) { let s = i[t].selector; if (!s) return !0; if (s.includes(this.unprefixed) && s.match(this.nameRegexp)) return !1; let n = !1; for (let [a, o] of this.prefixeds) if (s.includes(a) && s.match(o)) { n = !0; break } if (!n) return !0; t += 1 } return !0 } check(e) { return !(!e.selector.includes(this.prefixed) || !e.selector.match(this.regexp) || this.isHack(e)) } }; Vh.exports = Uh }); var Rt = w((GP, Hh) => { l(); var { list: x2 } = ue(), v2 = Wh(), k2 = qt(), S2 = Ke(), C2 = Z(), Gh = class extends k2 { constructor(e, t, i) { super(e, t, i); this.regexpCache = new Map } check(e) { return e.selector.includes(this.name) ? !!e.selector.match(this.regexp()) : !1 } prefixed(e) { return this.name.replace(/^(\W*)/, `$1${e}`) } regexp(e) { if (!this.regexpCache.has(e)) { let t = e ? this.prefixed(e) : this.name; this.regexpCache.set(e, new RegExp(`(^|[^:"'=])${C2.escapeRegexp(t)}`, "gi")) } return this.regexpCache.get(e) } possible() { return S2.prefixes() } prefixeds(e) { if (e._autoprefixerPrefixeds) { if (e._autoprefixerPrefixeds[this.name]) return e._autoprefixerPrefixeds } else e._autoprefixerPrefixeds = {}; let t = {}; if (e.selector.includes(",")) { let s = x2.comma(e.selector).filter(n => n.includes(this.name)); for (let n of this.possible()) t[n] = s.map(a => this.replace(a, n)).join(", ") } else for (let i of this.possible()) t[i] = this.replace(e.selector, i); return e._autoprefixerPrefixeds[this.name] = t, e._autoprefixerPrefixeds } already(e, t, i) { let s = e.parent.index(e) - 1; for (; s >= 0;) { let n = e.parent.nodes[s]; if (n.type !== "rule") return !1; let a = !1; for (let o in t[this.name]) { let u = t[this.name][o]; if (n.selector === u) { if (i === o) return !0; a = !0; break } } if (!a) return !1; s -= 1 } return !1 } replace(e, t) { return e.replace(this.regexp(), `$1${this.prefixed(t)}`) } add(e, t) { let i = this.prefixeds(e); if (this.already(e, i, t)) return; let s = this.clone(e, { selector: i[this.name][t] }); e.parent.insertBefore(e, s) } old(e) { return new v2(this, e) } }; Hh.exports = Gh }); var Jh = w((HP, Qh) => { l(); var _2 = qt(), Yh = class extends _2 { add(e, t) { let i = t + e.name; if (e.parent.some(a => a.name === i && a.params === e.params)) return; let n = this.clone(e, { name: i }); return e.parent.insertBefore(e, n) } process(e) { let t = this.parentPrefix(e); for (let i of this.prefixes) (!t || t === i) && this.add(e, i) } }; Qh.exports = Yh }); var Kh = w((YP, Xh) => { l(); var A2 = Rt(), fo = class extends A2 { prefixed(e) { return e === "-webkit-" ? ":-webkit-full-screen" : e === "-moz-" ? ":-moz-full-screen" : `:${e}fullscreen` } }; fo.names = [":fullscreen"]; Xh.exports = fo }); var em = w((QP, Zh) => { l(); var O2 = Rt(), co = class extends O2 { possible() { return super.possible().concat(["-moz- old", "-ms- old"]) } prefixed(e) { return e === "-webkit-" ? "::-webkit-input-placeholder" : e === "-ms-" ? "::-ms-input-placeholder" : e === "-ms- old" ? ":-ms-input-placeholder" : e === "-moz- old" ? ":-moz-placeholder" : `::${e}placeholder` } }; co.names = ["::placeholder"]; Zh.exports = co }); var rm = w((JP, tm) => { l(); var E2 = Rt(), po = class extends E2 { prefixed(e) { return e === "-ms-" ? ":-ms-input-placeholder" : `:${e}placeholder-shown` } }; po.names = [":placeholder-shown"]; tm.exports = po }); var sm = w((XP, im) => { l(); var T2 = Rt(), P2 = Z(), ho = class extends T2 { constructor(e, t, i) { super(e, t, i); this.prefixes && (this.prefixes = P2.uniq(this.prefixes.map(s => "-webkit-"))) } prefixed(e) { return e === "-webkit-" ? "::-webkit-file-upload-button" : `::${e}file-selector-button` } }; ho.names = ["::file-selector-button"]; im.exports = ho }); var re = w((KP, nm) => { l(); nm.exports = function (r) { let e; return r === "-webkit- 2009" || r === "-moz-" ? e = 2009 : r === "-ms-" ? e = 2012 : r === "-webkit-" && (e = "final"), r === "-webkit- 2009" && (r = "-webkit-"), [e, r] } }); var um = w((ZP, lm) => { l(); var am = ue().list, om = re(), D2 = D(), Mt = class extends D2 { prefixed(e, t) { let i; return [i, t] = om(t), i === 2009 ? t + "box-flex" : super.prefixed(e, t) } normalize() { return "flex" } set(e, t) { let i = om(t)[0]; if (i === 2009) return e.value = am.space(e.value)[0], e.value = Mt.oldValues[e.value] || e.value, super.set(e, t); if (i === 2012) { let s = am.space(e.value); s.length === 3 && s[2] === "0" && (e.value = s.slice(0, 2).concat("0px").join(" ")) } return super.set(e, t) } }; Mt.names = ["flex", "box-flex"]; Mt.oldValues = { auto: "1", none: "0" }; lm.exports = Mt }); var pm = w((e3, cm) => { l(); var fm = re(), q2 = D(), mo = class extends q2 { prefixed(e, t) { let i; return [i, t] = fm(t), i === 2009 ? t + "box-ordinal-group" : i === 2012 ? t + "flex-order" : super.prefixed(e, t) } normalize() { return "order" } set(e, t) { return fm(t)[0] === 2009 && /\d/.test(e.value) ? (e.value = (parseInt(e.value) + 1).toString(), super.set(e, t)) : super.set(e, t) } }; mo.names = ["order", "flex-order", "box-ordinal-group"]; cm.exports = mo }); var hm = w((t3, dm) => { l(); var I2 = D(), go = class extends I2 { check(e) { let t = e.value; return !t.toLowerCase().includes("alpha(") && !t.includes("DXImageTransform.Microsoft") && !t.includes("data:image/svg+xml") } }; go.names = ["filter"]; dm.exports = go }); var gm = w((r3, mm) => { l(); var R2 = D(), yo = class extends R2 { insert(e, t, i, s) { if (t !== "-ms-") return super.insert(e, t, i); let n = this.clone(e), a = e.prop.replace(/end$/, "start"), o = t + e.prop.replace(/end$/, "span"); if (!e.parent.some(u => u.prop === o)) { if (n.prop = o, e.value.includes("span")) n.value = e.value.replace(/span\s/i, ""); else { let u; if (e.parent.walkDecls(a, f => { u = f }), u) { let f = Number(e.value) - Number(u.value) + ""; n.value = f } else e.warn(s, `Can not prefix ${e.prop} (${a} is not found)`) } e.cloneBefore(n) } } }; yo.names = ["grid-row-end", "grid-column-end"]; mm.exports = yo }); var wm = w((i3, ym) => { l(); var M2 = D(), wo = class extends M2 { check(e) { return !e.value.split(/\s+/).some(t => { let i = t.toLowerCase(); return i === "reverse" || i === "alternate-reverse" }) } }; wo.names = ["animation", "animation-direction"]; ym.exports = wo }); var xm = w((s3, bm) => { l(); var L2 = re(), N2 = D(), bo = class extends N2 { insert(e, t, i) { let s; if ([s, t] = L2(t), s !== 2009) return super.insert(e, t, i); let n = e.value.split(/\s+/).filter(h => h !== "wrap" && h !== "nowrap" && "wrap-reverse"); if (n.length === 0 || e.parent.some(h => h.prop === t + "box-orient" || h.prop === t + "box-direction")) return; let o = n[0], u = o.includes("row") ? "horizontal" : "vertical", f = o.includes("reverse") ? "reverse" : "normal", c = this.clone(e); return c.prop = t + "box-orient", c.value = u, this.needCascade(e) && (c.raws.before = this.calcBefore(i, e, t)), e.parent.insertBefore(e, c), c = this.clone(e), c.prop = t + "box-direction", c.value = f, this.needCascade(e) && (c.raws.before = this.calcBefore(i, e, t)), e.parent.insertBefore(e, c) } }; bo.names = ["flex-flow", "box-direction", "box-orient"]; bm.exports = bo }); var km = w((n3, vm) => { l(); var F2 = re(), B2 = D(), xo = class extends B2 { normalize() { return "flex" } prefixed(e, t) { let i; return [i, t] = F2(t), i === 2009 ? t + "box-flex" : i === 2012 ? t + "flex-positive" : super.prefixed(e, t) } }; xo.names = ["flex-grow", "flex-positive"]; vm.exports = xo }); var Cm = w((a3, Sm) => { l(); var z2 = re(), $2 = D(), vo = class extends $2 { set(e, t) { if (z2(t)[0] !== 2009) return super.set(e, t) } }; vo.names = ["flex-wrap"]; Sm.exports = vo }); var Am = w((o3, _m) => { l(); var j2 = D(), Lt = Ze(), ko = class extends j2 { insert(e, t, i, s) { if (t !== "-ms-") return super.insert(e, t, i); let n = Lt.parse(e), [a, o] = Lt.translate(n, 0, 2), [u, f] = Lt.translate(n, 1, 3);[["grid-row", a], ["grid-row-span", o], ["grid-column", u], ["grid-column-span", f]].forEach(([c, h]) => { Lt.insertDecl(e, c, h) }), Lt.warnTemplateSelectorNotFound(e, s), Lt.warnIfGridRowColumnExists(e, s) } }; ko.names = ["grid-area"]; _m.exports = ko }); var Em = w((l3, Om) => { l(); var U2 = D(), Hr = Ze(), So = class extends U2 { insert(e, t, i) { if (t !== "-ms-") return super.insert(e, t, i); if (e.parent.some(a => a.prop === "-ms-grid-row-align")) return; let [[s, n]] = Hr.parse(e); n ? (Hr.insertDecl(e, "grid-row-align", s), Hr.insertDecl(e, "grid-column-align", n)) : (Hr.insertDecl(e, "grid-row-align", s), Hr.insertDecl(e, "grid-column-align", s)) } }; So.names = ["place-self"]; Om.exports = So }); var Pm = w((u3, Tm) => { l(); var V2 = D(), Co = class extends V2 { check(e) { let t = e.value; return !t.includes("/") || t.includes("span") } normalize(e) { return e.replace("-start", "") } prefixed(e, t) { let i = super.prefixed(e, t); return t === "-ms-" && (i = i.replace("-start", "")), i } }; Co.names = ["grid-row-start", "grid-column-start"]; Tm.exports = Co }); var Im = w((f3, qm) => { l(); var Dm = re(), W2 = D(), Nt = class extends W2 { check(e) { return e.parent && !e.parent.some(t => t.prop && t.prop.startsWith("grid-")) } prefixed(e, t) { let i; return [i, t] = Dm(t), i === 2012 ? t + "flex-item-align" : super.prefixed(e, t) } normalize() { return "align-self" } set(e, t) { let i = Dm(t)[0]; if (i === 2012) return e.value = Nt.oldValues[e.value] || e.value, super.set(e, t); if (i === "final") return super.set(e, t) } }; Nt.names = ["align-self", "flex-item-align"]; Nt.oldValues = { "flex-end": "end", "flex-start": "start" }; qm.exports = Nt }); var Mm = w((c3, Rm) => { l(); var G2 = D(), H2 = Z(), _o = class extends G2 { constructor(e, t, i) { super(e, t, i); this.prefixes && (this.prefixes = H2.uniq(this.prefixes.map(s => s === "-ms-" ? "-webkit-" : s))) } }; _o.names = ["appearance"]; Rm.exports = _o }); var Fm = w((p3, Nm) => { l(); var Lm = re(), Y2 = D(), Ao = class extends Y2 { normalize() { return "flex-basis" } prefixed(e, t) { let i; return [i, t] = Lm(t), i === 2012 ? t + "flex-preferred-size" : super.prefixed(e, t) } set(e, t) { let i; if ([i, t] = Lm(t), i === 2012 || i === "final") return super.set(e, t) } }; Ao.names = ["flex-basis", "flex-preferred-size"]; Nm.exports = Ao }); var zm = w((d3, Bm) => { l(); var Q2 = D(), Oo = class extends Q2 { normalize() { return this.name.replace("box-image", "border") } prefixed(e, t) { let i = super.prefixed(e, t); return t === "-webkit-" && (i = i.replace("border", "box-image")), i } }; Oo.names = ["mask-border", "mask-border-source", "mask-border-slice", "mask-border-width", "mask-border-outset", "mask-border-repeat", "mask-box-image", "mask-box-image-source", "mask-box-image-slice", "mask-box-image-width", "mask-box-image-outset", "mask-box-image-repeat"]; Bm.exports = Oo }); var jm = w((h3, $m) => { l(); var J2 = D(), Ee = class extends J2 { insert(e, t, i) { let s = e.prop === "mask-composite", n; s ? n = e.value.split(",") : n = e.value.match(Ee.regexp) || [], n = n.map(f => f.trim()).filter(f => f); let a = n.length, o; if (a && (o = this.clone(e), o.value = n.map(f => Ee.oldValues[f] || f).join(", "), n.includes("intersect") && (o.value += ", xor"), o.prop = t + "mask-composite"), s) return a ? (this.needCascade(e) && (o.raws.before = this.calcBefore(i, e, t)), e.parent.insertBefore(e, o)) : void 0; let u = this.clone(e); return u.prop = t + u.prop, a && (u.value = u.value.replace(Ee.regexp, "")), this.needCascade(e) && (u.raws.before = this.calcBefore(i, e, t)), e.parent.insertBefore(e, u), a ? (this.needCascade(e) && (o.raws.before = this.calcBefore(i, e, t)), e.parent.insertBefore(e, o)) : e } }; Ee.names = ["mask", "mask-composite"]; Ee.oldValues = { add: "source-over", subtract: "source-out", intersect: "source-in", exclude: "xor" }; Ee.regexp = new RegExp(`\\s+(${Object.keys(Ee.oldValues).join("|")})\\b(?!\\))\\s*(?=[,])`, "ig"); $m.exports = Ee }); var Wm = w((m3, Vm) => { l(); var Um = re(), X2 = D(), Ft = class extends X2 { prefixed(e, t) { let i; return [i, t] = Um(t), i === 2009 ? t + "box-align" : i === 2012 ? t + "flex-align" : super.prefixed(e, t) } normalize() { return "align-items" } set(e, t) { let i = Um(t)[0]; return (i === 2009 || i === 2012) && (e.value = Ft.oldValues[e.value] || e.value), super.set(e, t) } }; Ft.names = ["align-items", "flex-align", "box-align"]; Ft.oldValues = { "flex-end": "end", "flex-start": "start" }; Vm.exports = Ft }); var Hm = w((g3, Gm) => { l(); var K2 = D(), Eo = class extends K2 { set(e, t) { return t === "-ms-" && e.value === "contain" && (e.value = "element"), super.set(e, t) } insert(e, t, i) { if (!(e.value === "all" && t === "-ms-")) return super.insert(e, t, i) } }; Eo.names = ["user-select"]; Gm.exports = Eo }); var Jm = w((y3, Qm) => { l(); var Ym = re(), Z2 = D(), To = class extends Z2 { normalize() { return "flex-shrink" } prefixed(e, t) { let i; return [i, t] = Ym(t), i === 2012 ? t + "flex-negative" : super.prefixed(e, t) } set(e, t) { let i; if ([i, t] = Ym(t), i === 2012 || i === "final") return super.set(e, t) } }; To.names = ["flex-shrink", "flex-negative"]; Qm.exports = To }); var Km = w((w3, Xm) => { l(); var eC = D(), Po = class extends eC { prefixed(e, t) { return `${t}column-${e}` } normalize(e) { return e.includes("inside") ? "break-inside" : e.includes("before") ? "break-before" : "break-after" } set(e, t) { return (e.prop === "break-inside" && e.value === "avoid-column" || e.value === "avoid-page") && (e.value = "avoid"), super.set(e, t) } insert(e, t, i) { if (e.prop !== "break-inside") return super.insert(e, t, i); if (!(/region/i.test(e.value) || /page/i.test(e.value))) return super.insert(e, t, i) } }; Po.names = ["break-inside", "page-break-inside", "column-break-inside", "break-before", "page-break-before", "column-break-before", "break-after", "page-break-after", "column-break-after"]; Xm.exports = Po }); var eg = w((b3, Zm) => { l(); var tC = D(), Do = class extends tC { prefixed(e, t) { return t + "print-color-adjust" } normalize() { return "color-adjust" } }; Do.names = ["color-adjust", "print-color-adjust"]; Zm.exports = Do }); var rg = w((x3, tg) => { l(); var rC = D(), Bt = class extends rC { insert(e, t, i) { if (t === "-ms-") { let s = this.set(this.clone(e), t); this.needCascade(e) && (s.raws.before = this.calcBefore(i, e, t)); let n = "ltr"; return e.parent.nodes.forEach(a => { a.prop === "direction" && (a.value === "rtl" || a.value === "ltr") && (n = a.value) }), s.value = Bt.msValues[n][e.value] || e.value, e.parent.insertBefore(e, s) } return super.insert(e, t, i) } }; Bt.names = ["writing-mode"]; Bt.msValues = { ltr: { "horizontal-tb": "lr-tb", "vertical-rl": "tb-rl", "vertical-lr": "tb-lr" }, rtl: { "horizontal-tb": "rl-tb", "vertical-rl": "bt-rl", "vertical-lr": "bt-lr" } }; tg.exports = Bt }); var sg = w((v3, ig) => { l(); var iC = D(), qo = class extends iC { set(e, t) { return e.value = e.value.replace(/\s+fill(\s)/, "$1"), super.set(e, t) } }; qo.names = ["border-image"]; ig.exports = qo }); var og = w((k3, ag) => { l(); var ng = re(), sC = D(), zt = class extends sC { prefixed(e, t) { let i; return [i, t] = ng(t), i === 2012 ? t + "flex-line-pack" : super.prefixed(e, t) } normalize() { return "align-content" } set(e, t) { let i = ng(t)[0]; if (i === 2012) return e.value = zt.oldValues[e.value] || e.value, super.set(e, t); if (i === "final") return super.set(e, t) } }; zt.names = ["align-content", "flex-line-pack"]; zt.oldValues = { "flex-end": "end", "flex-start": "start", "space-between": "justify", "space-around": "distribute" }; ag.exports = zt }); var ug = w((S3, lg) => { l(); var nC = D(), pe = class extends nC { prefixed(e, t) { return t === "-moz-" ? t + (pe.toMozilla[e] || e) : super.prefixed(e, t) } normalize(e) { return pe.toNormal[e] || e } }; pe.names = ["border-radius"]; pe.toMozilla = {}; pe.toNormal = {}; for (let r of ["top", "bottom"]) for (let e of ["left", "right"]) { let t = `border-${r}-${e}-radius`, i = `border-radius-${r}${e}`; pe.names.push(t), pe.names.push(i), pe.toMozilla[t] = i, pe.toNormal[i] = t } lg.exports = pe }); var cg = w((C3, fg) => { l(); var aC = D(), Io = class extends aC { prefixed(e, t) { return e.includes("-start") ? t + e.replace("-block-start", "-before") : t + e.replace("-block-end", "-after") } normalize(e) { return e.includes("-before") ? e.replace("-before", "-block-start") : e.replace("-after", "-block-end") } }; Io.names = ["border-block-start", "border-block-end", "margin-block-start", "margin-block-end", "padding-block-start", "padding-block-end", "border-before", "border-after", "margin-before", "margin-after", "padding-before", "padding-after"]; fg.exports = Io }); var dg = w((_3, pg) => { l(); var oC = D(), { parseTemplate: lC, warnMissedAreas: uC, getGridGap: fC, warnGridGap: cC, inheritGridGap: pC } = Ze(), Ro = class extends oC { insert(e, t, i, s) { if (t !== "-ms-") return super.insert(e, t, i); if (e.parent.some(d => d.prop === "-ms-grid-rows")) return; let n = fC(e), a = pC(e, n), { rows: o, columns: u, areas: f } = lC({ decl: e, gap: a || n }), c = Object.keys(f).length > 0, h = Boolean(o), p = Boolean(u); return cC({ gap: n, hasColumns: p, decl: e, result: s }), uC(f, e, s), (h && p || c) && e.cloneBefore({ prop: "-ms-grid-rows", value: o, raws: {} }), p && e.cloneBefore({ prop: "-ms-grid-columns", value: u, raws: {} }), e } }; Ro.names = ["grid-template"]; pg.exports = Ro }); var mg = w((A3, hg) => { l(); var dC = D(), Mo = class extends dC { prefixed(e, t) { return t + e.replace("-inline", "") } normalize(e) { return e.replace(/(margin|padding|border)-(start|end)/, "$1-inline-$2") } }; Mo.names = ["border-inline-start", "border-inline-end", "margin-inline-start", "margin-inline-end", "padding-inline-start", "padding-inline-end", "border-start", "border-end", "margin-start", "margin-end", "padding-start", "padding-end"]; hg.exports = Mo }); var yg = w((O3, gg) => { l(); var hC = D(), Lo = class extends hC { check(e) { return !e.value.includes("flex-") && e.value !== "baseline" } prefixed(e, t) { return t + "grid-row-align" } normalize() { return "align-self" } }; Lo.names = ["grid-row-align"]; gg.exports = Lo }); var bg = w((E3, wg) => { l(); var mC = D(), $t = class extends mC { keyframeParents(e) { let { parent: t } = e; for (; t;) { if (t.type === "atrule" && t.name === "keyframes") return !0; ({ parent: t } = t) } return !1 } contain3d(e) { if (e.prop === "transform-origin") return !1; for (let t of $t.functions3d) if (e.value.includes(`${t}(`)) return !0; return !1 } set(e, t) { return e = super.set(e, t), t === "-ms-" && (e.value = e.value.replace(/rotatez/gi, "rotate")), e } insert(e, t, i) { if (t === "-ms-") { if (!this.contain3d(e) && !this.keyframeParents(e)) return super.insert(e, t, i) } else if (t === "-o-") { if (!this.contain3d(e)) return super.insert(e, t, i) } else return super.insert(e, t, i) } }; $t.names = ["transform", "transform-origin"]; $t.functions3d = ["matrix3d", "translate3d", "translateZ", "scale3d", "scaleZ", "rotate3d", "rotateX", "rotateY", "perspective"]; wg.exports = $t }); var kg = w((T3, vg) => { l(); var xg = re(), gC = D(), No = class extends gC { normalize() { return "flex-direction" } insert(e, t, i) { let s; if ([s, t] = xg(t), s !== 2009) return super.insert(e, t, i); if (e.parent.some(c => c.prop === t + "box-orient" || c.prop === t + "box-direction")) return; let a = e.value, o, u; a === "inherit" || a === "initial" || a === "unset" ? (o = a, u = a) : (o = a.includes("row") ? "horizontal" : "vertical", u = a.includes("reverse") ? "reverse" : "normal"); let f = this.clone(e); return f.prop = t + "box-orient", f.value = o, this.needCascade(e) && (f.raws.before = this.calcBefore(i, e, t)), e.parent.insertBefore(e, f), f = this.clone(e), f.prop = t + "box-direction", f.value = u, this.needCascade(e) && (f.raws.before = this.calcBefore(i, e, t)), e.parent.insertBefore(e, f) } old(e, t) { let i; return [i, t] = xg(t), i === 2009 ? [t + "box-orient", t + "box-direction"] : super.old(e, t) } }; No.names = ["flex-direction", "box-direction", "box-orient"]; vg.exports = No }); var Cg = w((P3, Sg) => { l(); var yC = D(), Fo = class extends yC { check(e) { return e.value === "pixelated" } prefixed(e, t) { return t === "-ms-" ? "-ms-interpolation-mode" : super.prefixed(e, t) } set(e, t) { return t !== "-ms-" ? super.set(e, t) : (e.prop = "-ms-interpolation-mode", e.value = "nearest-neighbor", e) } normalize() { return "image-rendering" } process(e, t) { return super.process(e, t) } }; Fo.names = ["image-rendering", "interpolation-mode"]; Sg.exports = Fo }); var Ag = w((D3, _g) => { l(); var wC = D(), bC = Z(), Bo = class extends wC { constructor(e, t, i) { super(e, t, i); this.prefixes && (this.prefixes = bC.uniq(this.prefixes.map(s => s === "-ms-" ? "-webkit-" : s))) } }; Bo.names = ["backdrop-filter"]; _g.exports = Bo }); var Eg = w((q3, Og) => { l(); var xC = D(), vC = Z(), zo = class extends xC { constructor(e, t, i) { super(e, t, i); this.prefixes && (this.prefixes = vC.uniq(this.prefixes.map(s => s === "-ms-" ? "-webkit-" : s))) } check(e) { return e.value.toLowerCase() === "text" } }; zo.names = ["background-clip"]; Og.exports = zo }); var Pg = w((I3, Tg) => { l(); var kC = D(), SC = ["none", "underline", "overline", "line-through", "blink", "inherit", "initial", "unset"], $o = class extends kC { check(e) { return e.value.split(/\s+/).some(t => !SC.includes(t)) } }; $o.names = ["text-decoration"]; Tg.exports = $o }); var Ig = w((R3, qg) => { l(); var Dg = re(), CC = D(), jt = class extends CC { prefixed(e, t) { let i; return [i, t] = Dg(t), i === 2009 ? t + "box-pack" : i === 2012 ? t + "flex-pack" : super.prefixed(e, t) } normalize() { return "justify-content" } set(e, t) { let i = Dg(t)[0]; if (i === 2009 || i === 2012) { let s = jt.oldValues[e.value] || e.value; if (e.value = s, i !== 2009 || s !== "distribute") return super.set(e, t) } else if (i === "final") return super.set(e, t) } }; jt.names = ["justify-content", "flex-pack", "box-pack"]; jt.oldValues = { "flex-end": "end", "flex-start": "start", "space-between": "justify", "space-around": "distribute" }; qg.exports = jt }); var Mg = w((M3, Rg) => { l(); var _C = D(), jo = class extends _C { set(e, t) { let i = e.value.toLowerCase(); return t === "-webkit-" && !i.includes(" ") && i !== "contain" && i !== "cover" && (e.value = e.value + " " + e.value), super.set(e, t) } }; jo.names = ["background-size"]; Rg.exports = jo }); var Ng = w((L3, Lg) => { l(); var AC = D(), Uo = Ze(), Vo = class extends AC { insert(e, t, i) { if (t !== "-ms-") return super.insert(e, t, i); let s = Uo.parse(e), [n, a] = Uo.translate(s, 0, 1); s[0] && s[0].includes("span") && (a = s[0].join("").replace(/\D/g, "")), [[e.prop, n], [`${e.prop}-span`, a]].forEach(([u, f]) => { Uo.insertDecl(e, u, f) }) } }; Vo.names = ["grid-row", "grid-column"]; Lg.exports = Vo }); var zg = w((N3, Bg) => { l(); var OC = D(), { prefixTrackProp: Fg, prefixTrackValue: EC, autoplaceGridItems: TC, getGridGap: PC, inheritGridGap: DC } = Ze(), qC = lo(), Wo = class extends OC { prefixed(e, t) { return t === "-ms-" ? Fg({ prop: e, prefix: t }) : super.prefixed(e, t) } normalize(e) { return e.replace(/^grid-(rows|columns)/, "grid-template-$1") } insert(e, t, i, s) { if (t !== "-ms-") return super.insert(e, t, i); let { parent: n, prop: a, value: o } = e, u = a.includes("rows"), f = a.includes("columns"), c = n.some(k => k.prop === "grid-template" || k.prop === "grid-template-areas"); if (c && u) return !1; let h = new qC({ options: {} }), p = h.gridStatus(n, s), d = PC(e); d = DC(e, d) || d; let y = u ? d.row : d.column; (p === "no-autoplace" || p === !0) && !c && (y = null); let v = EC({ value: o, gap: y }); e.cloneBefore({ prop: Fg({ prop: a, prefix: t }), value: v }); let b = n.nodes.find(k => k.prop === "grid-auto-flow"), x = "row"; if (b && !h.disabled(b, s) && (x = b.value.trim()), p === "autoplace") { let k = n.nodes.find(P => P.prop === "grid-template-rows"); if (!k && c) return; if (!k && !c) { e.warn(s, "Autoplacement does not work without grid-template-rows property"); return } !n.nodes.find(P => P.prop === "grid-template-columns") && !c && e.warn(s, "Autoplacement does not work without grid-template-columns property"), f && !c && TC(e, s, d, x) } } }; Wo.names = ["grid-template-rows", "grid-template-columns", "grid-rows", "grid-columns"]; Bg.exports = Wo }); var jg = w((F3, $g) => { l(); var IC = D(), Go = class extends IC { check(e) { return !e.value.includes("flex-") && e.value !== "baseline" } prefixed(e, t) { return t + "grid-column-align" } normalize() { return "justify-self" } }; Go.names = ["grid-column-align"]; $g.exports = Go }); var Vg = w((B3, Ug) => { l(); var RC = D(), Ho = class extends RC { prefixed(e, t) { return t + "scroll-chaining" } normalize() { return "overscroll-behavior" } set(e, t) { return e.value === "auto" ? e.value = "chained" : (e.value === "none" || e.value === "contain") && (e.value = "none"), super.set(e, t) } }; Ho.names = ["overscroll-behavior", "scroll-chaining"]; Ug.exports = Ho }); var Hg = w((z3, Gg) => { l(); var MC = D(), { parseGridAreas: LC, warnMissedAreas: NC, prefixTrackProp: FC, prefixTrackValue: Wg, getGridGap: BC, warnGridGap: zC, inheritGridGap: $C } = Ze(); function jC(r) { return r.trim().slice(1, -1).split(/["']\s*["']?/g) } var Yo = class extends MC { insert(e, t, i, s) { if (t !== "-ms-") return super.insert(e, t, i); let n = !1, a = !1, o = e.parent, u = BC(e); u = $C(e, u) || u, o.walkDecls(/-ms-grid-rows/, h => h.remove()), o.walkDecls(/grid-template-(rows|columns)/, h => { if (h.prop === "grid-template-rows") { a = !0; let { prop: p, value: d } = h; h.cloneBefore({ prop: FC({ prop: p, prefix: t }), value: Wg({ value: d, gap: u.row }) }) } else n = !0 }); let f = jC(e.value); n && !a && u.row && f.length > 1 && e.cloneBefore({ prop: "-ms-grid-rows", value: Wg({ value: `repeat(${f.length}, auto)`, gap: u.row }), raws: {} }), zC({ gap: u, hasColumns: n, decl: e, result: s }); let c = LC({ rows: f, gap: u }); return NC(c, e, s), e } }; Yo.names = ["grid-template-areas"]; Gg.exports = Yo }); var Qg = w(($3, Yg) => { l(); var UC = D(), Qo = class extends UC { set(e, t) { return t === "-webkit-" && (e.value = e.value.replace(/\s*(right|left)\s*/i, "")), super.set(e, t) } }; Qo.names = ["text-emphasis-position"]; Yg.exports = Qo }); var Xg = w((j3, Jg) => { l(); var VC = D(), Jo = class extends VC { set(e, t) { return e.prop === "text-decoration-skip-ink" && e.value === "auto" ? (e.prop = t + "text-decoration-skip", e.value = "ink", e) : super.set(e, t) } }; Jo.names = ["text-decoration-skip-ink", "text-decoration-skip"]; Jg.exports = Jo }); var iy = w((U3, ry) => { l(); "use strict"; ry.exports = { wrap: Kg, limit: Zg, validate: ey, test: Xo, curry: WC, name: ty }; function Kg(r, e, t) { var i = e - r; return ((t - r) % i + i) % i + r } function Zg(r, e, t) { return Math.max(r, Math.min(e, t)) } function ey(r, e, t, i, s) { if (!Xo(r, e, t, i, s)) throw new Error(t + " is outside of range [" + r + "," + e + ")"); return t } function Xo(r, e, t, i, s) { return !(t < r || t > e || s && t === e || i && t === r) } function ty(r, e, t, i) { return (t ? "(" : "[") + r + "," + e + (i ? ")" : "]") } function WC(r, e, t, i) { var s = ty.bind(null, r, e, t, i); return { wrap: Kg.bind(null, r, e), limit: Zg.bind(null, r, e), validate: function (n) { return ey(r, e, n, t, i) }, test: function (n) { return Xo(r, e, n, t, i) }, toString: s, name: s } } }); var ay = w((V3, ny) => { l(); var Ko = Vr(), GC = iy(), HC = It(), YC = ce(), QC = Z(), sy = /top|left|right|bottom/gi, Le = class extends YC { replace(e, t) { let i = Ko(e); for (let s of i.nodes) if (s.type === "function" && s.value === this.name) if (s.nodes = this.newDirection(s.nodes), s.nodes = this.normalize(s.nodes), t === "-webkit- old") { if (!this.oldWebkit(s)) return !1 } else s.nodes = this.convertDirection(s.nodes), s.value = t + s.value; return i.toString() } replaceFirst(e, ...t) { return t.map(s => s === " " ? { type: "space", value: s } : { type: "word", value: s }).concat(e.slice(1)) } normalizeUnit(e, t) { return `${parseFloat(e) / t * 360}deg` } normalize(e) { if (!e[0]) return e; if (/-?\d+(.\d+)?grad/.test(e[0].value)) e[0].value = this.normalizeUnit(e[0].value, 400); else if (/-?\d+(.\d+)?rad/.test(e[0].value)) e[0].value = this.normalizeUnit(e[0].value, 2 * Math.PI); else if (/-?\d+(.\d+)?turn/.test(e[0].value)) e[0].value = this.normalizeUnit(e[0].value, 1); else if (e[0].value.includes("deg")) { let t = parseFloat(e[0].value); t = GC.wrap(0, 360, t), e[0].value = `${t}deg` } return e[0].value === "0deg" ? e = this.replaceFirst(e, "to", " ", "top") : e[0].value === "90deg" ? e = this.replaceFirst(e, "to", " ", "right") : e[0].value === "180deg" ? e = this.replaceFirst(e, "to", " ", "bottom") : e[0].value === "270deg" && (e = this.replaceFirst(e, "to", " ", "left")), e } newDirection(e) { if (e[0].value === "to" || (sy.lastIndex = 0, !sy.test(e[0].value))) return e; e.unshift({ type: "word", value: "to" }, { type: "space", value: " " }); for (let t = 2; t < e.length && e[t].type !== "div"; t++)e[t].type === "word" && (e[t].value = this.revertDirection(e[t].value)); return e } isRadial(e) { let t = "before"; for (let i of e) if (t === "before" && i.type === "space") t = "at"; else if (t === "at" && i.value === "at") t = "after"; else { if (t === "after" && i.type === "space") return !0; if (i.type === "div") break; t = "before" } return !1 } convertDirection(e) { return e.length > 0 && (e[0].value === "to" ? this.fixDirection(e) : e[0].value.includes("deg") ? this.fixAngle(e) : this.isRadial(e) && this.fixRadial(e)), e } fixDirection(e) { e.splice(0, 2); for (let t of e) { if (t.type === "div") break; t.type === "word" && (t.value = this.revertDirection(t.value)) } } fixAngle(e) { let t = e[0].value; t = parseFloat(t), t = Math.abs(450 - t) % 360, t = this.roundFloat(t, 3), e[0].value = `${t}deg` } fixRadial(e) { let t = [], i = [], s, n, a, o, u; for (o = 0; o < e.length - 2; o++)if (s = e[o], n = e[o + 1], a = e[o + 2], s.type === "space" && n.value === "at" && a.type === "space") { u = o + 3; break } else t.push(s); let f; for (o = u; o < e.length; o++)if (e[o].type === "div") { f = e[o]; break } else i.push(e[o]); e.splice(0, o, ...i, f, ...t) } revertDirection(e) { return Le.directions[e.toLowerCase()] || e } roundFloat(e, t) { return parseFloat(e.toFixed(t)) } oldWebkit(e) { let { nodes: t } = e, i = Ko.stringify(e.nodes); if (this.name !== "linear-gradient" || t[0] && t[0].value.includes("deg") || i.includes("px") || i.includes("-corner") || i.includes("-side")) return !1; let s = [[]]; for (let n of t) s[s.length - 1].push(n), n.type === "div" && n.value === "," && s.push([]); this.oldDirection(s), this.colorStops(s), e.nodes = []; for (let n of s) e.nodes = e.nodes.concat(n); return e.nodes.unshift({ type: "word", value: "linear" }, this.cloneDiv(e.nodes)), e.value = "-webkit-gradient", !0 } oldDirection(e) { let t = this.cloneDiv(e[0]); if (e[0][0].value !== "to") return e.unshift([{ type: "word", value: Le.oldDirections.bottom }, t]); { let i = []; for (let n of e[0].slice(2)) n.type === "word" && i.push(n.value.toLowerCase()); i = i.join(" "); let s = Le.oldDirections[i] || i; return e[0] = [{ type: "word", value: s }, t], e[0] } } cloneDiv(e) { for (let t of e) if (t.type === "div" && t.value === ",") return t; return { type: "div", value: ",", after: " " } } colorStops(e) { let t = []; for (let i = 0; i < e.length; i++) { let s, n = e[i], a; if (i === 0) continue; let o = Ko.stringify(n[0]); n[1] && n[1].type === "word" ? s = n[1].value : n[2] && n[2].type === "word" && (s = n[2].value); let u; i === 1 && (!s || s === "0%") ? u = `from(${o})` : i === e.length - 1 && (!s || s === "100%") ? u = `to(${o})` : s ? u = `color-stop(${s}, ${o})` : u = `color-stop(${o})`; let f = n[n.length - 1]; e[i] = [{ type: "word", value: u }], f.type === "div" && f.value === "," && (a = e[i].push(f)), t.push(a) } return t } old(e) { if (e === "-webkit-") { let t = this.name === "linear-gradient" ? "linear" : "radial", i = "-gradient", s = QC.regexp(`-webkit-(${t}-gradient|gradient\\(\\s*${t})`, !1); return new HC(this.name, e + this.name, i, s) } else return super.old(e) } add(e, t) { let i = e.prop; if (i.includes("mask")) { if (t === "-webkit-" || t === "-webkit- old") return super.add(e, t) } else if (i === "list-style" || i === "list-style-image" || i === "content") { if (t === "-webkit-" || t === "-webkit- old") return super.add(e, t) } else return super.add(e, t) } }; Le.names = ["linear-gradient", "repeating-linear-gradient", "radial-gradient", "repeating-radial-gradient"]; Le.directions = { top: "bottom", left: "right", bottom: "top", right: "left" }; Le.oldDirections = { top: "left bottom, left top", left: "right top, left top", bottom: "left top, left bottom", right: "left top, right top", "top right": "left bottom, right top", "top left": "right bottom, left top", "right top": "left bottom, right top", "right bottom": "left top, right bottom", "bottom right": "left top, right bottom", "bottom left": "right top, left bottom", "left top": "right bottom, left top", "left bottom": "right top, left bottom" }; ny.exports = Le }); var uy = w((W3, ly) => { l(); var JC = It(), XC = ce(); function oy(r) { return new RegExp(`(^|[\\s,(])(${r}($|[\\s),]))`, "gi") } var Zo = class extends XC { regexp() { return this.regexpCache || (this.regexpCache = oy(this.name)), this.regexpCache } isStretch() { return this.name === "stretch" || this.name === "fill" || this.name === "fill-available" } replace(e, t) { return t === "-moz-" && this.isStretch() ? e.replace(this.regexp(), "$1-moz-available$3") : t === "-webkit-" && this.isStretch() ? e.replace(this.regexp(), "$1-webkit-fill-available$3") : super.replace(e, t) } old(e) { let t = e + this.name; return this.isStretch() && (e === "-moz-" ? t = "-moz-available" : e === "-webkit-" && (t = "-webkit-fill-available")), new JC(this.name, t, t, oy(t)) } add(e, t) { if (!(e.prop.includes("grid") && t !== "-webkit-")) return super.add(e, t) } }; Zo.names = ["max-content", "min-content", "fit-content", "fill", "fill-available", "stretch"]; ly.exports = Zo }); var py = w((G3, cy) => { l(); var fy = It(), KC = ce(), el = class extends KC { replace(e, t) { return t === "-webkit-" ? e.replace(this.regexp(), "$1-webkit-optimize-contrast") : t === "-moz-" ? e.replace(this.regexp(), "$1-moz-crisp-edges") : super.replace(e, t) } old(e) { return e === "-webkit-" ? new fy(this.name, "-webkit-optimize-contrast") : e === "-moz-" ? new fy(this.name, "-moz-crisp-edges") : super.old(e) } }; el.names = ["pixelated"]; cy.exports = el }); var hy = w((H3, dy) => { l(); var ZC = ce(), tl = class extends ZC { replace(e, t) { let i = super.replace(e, t); return t === "-webkit-" && (i = i.replace(/("[^"]+"|'[^']+')(\s+\d+\w)/gi, "url($1)$2")), i } }; tl.names = ["image-set"]; dy.exports = tl }); var gy = w((Y3, my) => { l(); var e_ = ue().list, t_ = ce(), rl = class extends t_ { replace(e, t) { return e_.space(e).map(i => { if (i.slice(0, +this.name.length + 1) !== this.name + "(") return i; let s = i.lastIndexOf(")"), n = i.slice(s + 1), a = i.slice(this.name.length + 1, s); if (t === "-webkit-") { let o = a.match(/\d*.?\d+%?/); o ? (a = a.slice(o[0].length).trim(), a += `, ${o[0]}`) : a += ", 0.5" } return t + this.name + "(" + a + ")" + n }).join(" ") } }; rl.names = ["cross-fade"]; my.exports = rl }); var wy = w((Q3, yy) => { l(); var r_ = re(), i_ = It(), s_ = ce(), il = class extends s_ { constructor(e, t) { super(e, t); e === "display-flex" && (this.name = "flex") } check(e) { return e.prop === "display" && e.value === this.name } prefixed(e) { let t, i; return [t, e] = r_(e), t === 2009 ? this.name === "flex" ? i = "box" : i = "inline-box" : t === 2012 ? this.name === "flex" ? i = "flexbox" : i = "inline-flexbox" : t === "final" && (i = this.name), e + i } replace(e, t) { return this.prefixed(t) } old(e) { let t = this.prefixed(e); if (!!t) return new i_(this.name, t) } }; il.names = ["display-flex", "inline-flex"]; yy.exports = il }); var xy = w((J3, by) => { l(); var n_ = ce(), sl = class extends n_ { constructor(e, t) { super(e, t); e === "display-grid" && (this.name = "grid") } check(e) { return e.prop === "display" && e.value === this.name } }; sl.names = ["display-grid", "inline-grid"]; by.exports = sl }); var ky = w((X3, vy) => { l(); var a_ = ce(), nl = class extends a_ { constructor(e, t) { super(e, t); e === "filter-function" && (this.name = "filter") } }; nl.names = ["filter", "filter-function"]; vy.exports = nl }); var Ay = w((K3, _y) => { l(); var Sy = Gr(), q = D(), Cy = wh(), o_ = Sh(), l_ = lo(), u_ = jh(), al = Ke(), Ut = Rt(), f_ = Jh(), Te = ce(), Vt = Z(), c_ = Kh(), p_ = em(), d_ = rm(), h_ = sm(), m_ = um(), g_ = pm(), y_ = hm(), w_ = gm(), b_ = wm(), x_ = xm(), v_ = km(), k_ = Cm(), S_ = Am(), C_ = Em(), __ = Pm(), A_ = Im(), O_ = Mm(), E_ = Fm(), T_ = zm(), P_ = jm(), D_ = Wm(), q_ = Hm(), I_ = Jm(), R_ = Km(), M_ = eg(), L_ = rg(), N_ = sg(), F_ = og(), B_ = ug(), z_ = cg(), $_ = dg(), j_ = mg(), U_ = yg(), V_ = bg(), W_ = kg(), G_ = Cg(), H_ = Ag(), Y_ = Eg(), Q_ = Pg(), J_ = Ig(), X_ = Mg(), K_ = Ng(), Z_ = zg(), eA = jg(), tA = Vg(), rA = Hg(), iA = Qg(), sA = Xg(), nA = ay(), aA = uy(), oA = py(), lA = hy(), uA = gy(), fA = wy(), cA = xy(), pA = ky(); Ut.hack(c_); Ut.hack(p_); Ut.hack(d_); Ut.hack(h_); q.hack(m_); q.hack(g_); q.hack(y_); q.hack(w_); q.hack(b_); q.hack(x_); q.hack(v_); q.hack(k_); q.hack(S_); q.hack(C_); q.hack(__); q.hack(A_); q.hack(O_); q.hack(E_); q.hack(T_); q.hack(P_); q.hack(D_); q.hack(q_); q.hack(I_); q.hack(R_); q.hack(M_); q.hack(L_); q.hack(N_); q.hack(F_); q.hack(B_); q.hack(z_); q.hack($_); q.hack(j_); q.hack(U_); q.hack(V_); q.hack(W_); q.hack(G_); q.hack(H_); q.hack(Y_); q.hack(Q_); q.hack(J_); q.hack(X_); q.hack(K_); q.hack(Z_); q.hack(eA); q.hack(tA); q.hack(rA); q.hack(iA); q.hack(sA); Te.hack(nA); Te.hack(aA); Te.hack(oA); Te.hack(lA); Te.hack(uA); Te.hack(fA); Te.hack(cA); Te.hack(pA); var ol = new Map, Yr = class { constructor(e, t, i = {}) { this.data = e, this.browsers = t, this.options = i, [this.add, this.remove] = this.preprocess(this.select(this.data)), this.transition = new o_(this), this.processor = new l_(this) } cleaner() { if (this.cleanerCache) return this.cleanerCache; if (this.browsers.selected.length) { let e = new al(this.browsers.data, []); this.cleanerCache = new Yr(this.data, e, this.options) } else return this; return this.cleanerCache } select(e) { let t = { add: {}, remove: {} }; for (let i in e) { let s = e[i], n = s.browsers.map(u => { let f = u.split(" "); return { browser: `${f[0]} ${f[1]}`, note: f[2] } }), a = n.filter(u => u.note).map(u => `${this.browsers.prefix(u.browser)} ${u.note}`); a = Vt.uniq(a), n = n.filter(u => this.browsers.isSelected(u.browser)).map(u => { let f = this.browsers.prefix(u.browser); return u.note ? `${f} ${u.note}` : f }), n = this.sort(Vt.uniq(n)), this.options.flexbox === "no-2009" && (n = n.filter(u => !u.includes("2009"))); let o = s.browsers.map(u => this.browsers.prefix(u)); s.mistakes && (o = o.concat(s.mistakes)), o = o.concat(a), o = Vt.uniq(o), n.length ? (t.add[i] = n, n.length < o.length && (t.remove[i] = o.filter(u => !n.includes(u)))) : t.remove[i] = o } return t } sort(e) { return e.sort((t, i) => { let s = Vt.removeNote(t).length, n = Vt.removeNote(i).length; return s === n ? i.length - t.length : n - s }) } preprocess(e) { let t = { selectors: [], "@supports": new u_(Yr, this) }; for (let s in e.add) { let n = e.add[s]; if (s === "@keyframes" || s === "@viewport") t[s] = new f_(s, n, this); else if (s === "@resolution") t[s] = new Cy(s, n, this); else if (this.data[s].selector) t.selectors.push(Ut.load(s, n, this)); else { let a = this.data[s].props; if (a) { let o = Te.load(s, n, this); for (let u of a) t[u] || (t[u] = { values: [] }), t[u].values.push(o) } else { let o = t[s] && t[s].values || []; t[s] = q.load(s, n, this), t[s].values = o } } } let i = { selectors: [] }; for (let s in e.remove) { let n = e.remove[s]; if (this.data[s].selector) { let a = Ut.load(s, n); for (let o of n) i.selectors.push(a.old(o)) } else if (s === "@keyframes" || s === "@viewport") for (let a of n) { let o = `@${a}${s.slice(1)}`; i[o] = { remove: !0 } } else if (s === "@resolution") i[s] = new Cy(s, n, this); else { let a = this.data[s].props; if (a) { let o = Te.load(s, [], this); for (let u of n) { let f = o.old(u); if (f) for (let c of a) i[c] || (i[c] = {}), i[c].values || (i[c].values = []), i[c].values.push(f) } } else for (let o of n) { let u = this.decl(s).old(s, o); if (s === "align-self") { let f = t[s] && t[s].prefixes; if (f) { if (o === "-webkit- 2009" && f.includes("-webkit-")) continue; if (o === "-webkit-" && f.includes("-webkit- 2009")) continue } } for (let f of u) i[f] || (i[f] = {}), i[f].remove = !0 } } } return [t, i] } decl(e) { return ol.has(e) || ol.set(e, q.load(e)), ol.get(e) } unprefixed(e) { let t = this.normalize(Sy.unprefixed(e)); return t === "flex-direction" && (t = "flex-flow"), t } normalize(e) { return this.decl(e).normalize(e) } prefixed(e, t) { return e = Sy.unprefixed(e), this.decl(e).prefixed(e, t) } values(e, t) { let i = this[e], s = i["*"] && i["*"].values, n = i[t] && i[t].values; return s && n ? Vt.uniq(s.concat(n)) : s || n || [] } group(e) { let t = e.parent, i = t.index(e), { length: s } = t.nodes, n = this.unprefixed(e.prop), a = (o, u) => { for (i += o; i >= 0 && i < s;) { let f = t.nodes[i]; if (f.type === "decl") { if (o === -1 && f.prop === n && !al.withPrefix(f.value) || this.unprefixed(f.prop) !== n) break; if (u(f) === !0) return !0; if (o === 1 && f.prop === n && !al.withPrefix(f.value)) break } i += o } return !1 }; return { up(o) { return a(-1, o) }, down(o) { return a(1, o) } } } }; _y.exports = Yr }); var Ey = w((Z3, Oy) => { l(); Oy.exports = { "backface-visibility": { mistakes: ["-ms-", "-o-"], feature: "transforms3d", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1"] }, "backdrop-filter": { feature: "css-backdrop-filter", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1"] }, element: { props: ["background", "background-image", "border-image", "mask", "list-style", "list-style-image", "content", "mask-image"], feature: "css-element-function", browsers: ["firefox 89"] }, "user-select": { mistakes: ["-khtml-"], feature: "user-select-none", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1"] }, "background-clip": { feature: "background-clip-text", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, hyphens: { feature: "css-hyphens", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1"] }, ":fullscreen": { selector: !0, feature: "fullscreen", browsers: ["and_chr 92", "and_uc 12.12", "safari 14.1"] }, "::backdrop": { selector: !0, feature: "fullscreen", browsers: ["and_chr 92", "and_uc 12.12", "safari 14.1"] }, "::file-selector-button": { selector: !0, feature: "fullscreen", browsers: ["safari 14.1"] }, "tab-size": { feature: "css3-tabsize", browsers: ["firefox 89"] }, fill: { props: ["width", "min-width", "max-width", "height", "min-height", "max-height", "inline-size", "min-inline-size", "max-inline-size", "block-size", "min-block-size", "max-block-size", "grid", "grid-template", "grid-template-rows", "grid-template-columns", "grid-auto-columns", "grid-auto-rows"], feature: "intrinsic-width", browsers: ["and_chr 92", "chrome 91", "chrome 92", "edge 91", "samsung 14.0"] }, "fill-available": { props: ["width", "min-width", "max-width", "height", "min-height", "max-height", "inline-size", "min-inline-size", "max-inline-size", "block-size", "min-block-size", "max-block-size", "grid", "grid-template", "grid-template-rows", "grid-template-columns", "grid-auto-columns", "grid-auto-rows"], feature: "intrinsic-width", browsers: ["and_chr 92", "chrome 91", "chrome 92", "edge 91", "samsung 14.0"] }, stretch: { props: ["width", "min-width", "max-width", "height", "min-height", "max-height", "inline-size", "min-inline-size", "max-inline-size", "block-size", "min-block-size", "max-block-size", "grid", "grid-template", "grid-template-rows", "grid-template-columns", "grid-auto-columns", "grid-auto-rows"], feature: "intrinsic-width", browsers: ["firefox 89"] }, "fit-content": { props: ["width", "min-width", "max-width", "height", "min-height", "max-height", "inline-size", "min-inline-size", "max-inline-size", "block-size", "min-block-size", "max-block-size", "grid", "grid-template", "grid-template-rows", "grid-template-columns", "grid-auto-columns", "grid-auto-rows"], feature: "intrinsic-width", browsers: ["firefox 89"] }, "text-decoration-style": { feature: "text-decoration", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7"] }, "text-decoration-color": { feature: "text-decoration", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7"] }, "text-decoration-line": { feature: "text-decoration", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7"] }, "text-decoration": { feature: "text-decoration", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7"] }, "text-decoration-skip": { feature: "text-decoration", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7"] }, "text-decoration-skip-ink": { feature: "text-decoration", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7"] }, "text-size-adjust": { feature: "text-size-adjust", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7"] }, "mask-clip": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-composite": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-image": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-origin": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-repeat": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-border-repeat": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-border-source": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, mask: { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-position": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-size": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-border": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-border-outset": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-border-width": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "mask-border-slice": { feature: "css-masks", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "clip-path": { feature: "css-clip-path", browsers: ["and_uc 12.12", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "box-decoration-break": { feature: "css-boxdecorationbreak", browsers: ["and_chr 92", "chrome 91", "chrome 92", "edge 91", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "@resolution": { feature: "css-media-resolution", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1"] }, "border-inline-start": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, "border-inline-end": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, "margin-inline-start": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, "margin-inline-end": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, "padding-inline-start": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, "padding-inline-end": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, "border-block-start": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, "border-block-end": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, "margin-block-start": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, "margin-block-end": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, "padding-block-start": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, "padding-block-end": { feature: "css-logical-props", browsers: ["and_uc 12.12"] }, appearance: { feature: "css-appearance", browsers: ["and_uc 12.12", "ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1", "samsung 14.0"] }, "image-set": { props: ["background", "background-image", "border-image", "cursor", "mask", "mask-image", "list-style", "list-style-image", "content"], feature: "css-image-set", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "samsung 14.0"] }, "cross-fade": { props: ["background", "background-image", "border-image", "mask", "list-style", "list-style-image", "content", "mask-image"], feature: "css-cross-fade", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "samsung 14.0"] }, "text-emphasis": { feature: "text-emphasis", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "samsung 14.0"] }, "text-emphasis-position": { feature: "text-emphasis", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "samsung 14.0"] }, "text-emphasis-style": { feature: "text-emphasis", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "samsung 14.0"] }, "text-emphasis-color": { feature: "text-emphasis", browsers: ["and_chr 92", "and_uc 12.12", "chrome 91", "chrome 92", "edge 91", "samsung 14.0"] }, ":any-link": { selector: !0, feature: "css-any-link", browsers: ["and_uc 12.12"] }, isolate: { props: ["unicode-bidi"], feature: "css-unicode-bidi", browsers: ["ios_saf 14.0-14.4", "ios_saf 14.5-14.7", "safari 14.1"] }, "color-adjust": { feature: "css-color-adjust", browsers: ["chrome 91", "chrome 92", "edge 91", "safari 14.1"] } } }); var Py = w((eD, Ty) => { l(); Ty.exports = {} }); var Ry = w((tD, Iy) => {
                l(); var dA = io(), { agents: hA } = (vs(), xs), ll = sh(), mA = Ke(), gA = Ay(), yA = Ey(), wA = Py(), Dy = { browsers: hA, prefixes: yA }, qy = `
          Replace Autoprefixer \`browsers\` option to Browserslist config.
          Use \`browserslist\` key in \`package.json\` or \`.browserslistrc\` file.

          Using \`browsers\` option can cause errors. Browserslist config can
          be used for Babel, Autoprefixer, postcss-normalize and other tools.

          If you really need to use option, rename it to \`overrideBrowserslist\`.

          Learn more at:
          https://github.com/browserslist/browserslist#readme
          https://twitter.com/browserslist

`; function bA(r) { return Object.prototype.toString.apply(r) === "[object Object]" } var ul = new Map; function xA(r, e) {
                    e.browsers.selected.length !== 0 && (e.add.selectors.length > 0 || Object.keys(e.add).length > 2 || r.warn(`Autoprefixer target browsers do not need any prefixes.You do not need Autoprefixer anymore.
Check your Browserslist config to be sure that your targets are set up correctly.

          Learn more at:
          https://github.com/postcss/autoprefixer#readme
          https://github.com/browserslist/browserslist#readme

`))
                } Iy.exports = Wt; function Wt(...r) { let e; if (r.length === 1 && bA(r[0]) ? (e = r[0], r = void 0) : r.length === 0 || r.length === 1 && !r[0] ? r = void 0 : r.length <= 2 && (Array.isArray(r[0]) || !r[0]) ? (e = r[1], r = r[0]) : typeof r[r.length - 1] == "object" && (e = r.pop()), e || (e = {}), e.browser) throw new Error("Change `browser` option to `overrideBrowserslist` in Autoprefixer"); if (e.browserslist) throw new Error("Change `browserslist` option to `overrideBrowserslist` in Autoprefixer"); e.overrideBrowserslist ? r = e.overrideBrowserslist : e.browsers && (typeof console != "undefined" && console.warn && (ll.red ? console.warn(ll.red(qy.replace(/`[^`]+`/g, s => ll.yellow(s.slice(1, -1))))) : console.warn(qy)), r = e.browsers); let t = { ignoreUnknownVersions: e.ignoreUnknownVersions, stats: e.stats, env: e.env }; function i(s) { let n = Dy, a = new mA(n.browsers, r, s, t), o = a.selected.join(", ") + JSON.stringify(e); return ul.has(o) || ul.set(o, new gA(n.prefixes, a, e)), ul.get(o) } return { postcssPlugin: "autoprefixer", prepare(s) { let n = i({ from: s.opts.from, env: e.env }); return { OnceExit(a) { xA(s, n), e.remove !== !1 && n.processor.remove(a, s), e.add !== !1 && n.processor.add(a, s) } } }, info(s) { return s = s || {}, s.from = s.from || m.cwd(), wA(i(s)) }, options: e, browsers: r } } Wt.postcss = !0; Wt.data = Dy; Wt.defaults = dA.defaults; Wt.info = () => Wt().info()
            }); var My = {}; de(My, { default: () => vA }); var vA, Ly = C(() => { l(); vA = [] }); var Fy = {}; de(Fy, { default: () => kA }); var Ny, kA, By = C(() => { l(); ti(); Ny = H(Ht()), kA = ze(Ny.default.theme) }); var $y = {}; de($y, { default: () => SA }); var zy, SA, jy = C(() => { l(); ti(); zy = H(Ht()), SA = ze(zy.default) }); function Uy(r, e) { return { handler: r, config: e } } var Vy, Wy = C(() => { l(); Uy.withOptions = function (r, e = () => ({})) { let t = function (i) { return { __options: i, handler: r(i), config: e(i) } }; return t.__isOptionsFunction = !0, t.__pluginFunction = r, t.__configFunction = e, t }; Vy = Uy }); var Gy = {}; de(Gy, { default: () => CA }); var CA, Hy = C(() => { l(); Wy(); CA = Vy }); l(); "use strict"; var _A = Ne(rh()), AA = Ne(ue()), OA = Ne(Ry()), EA = Ne((Ly(), My)), TA = Ne((By(), Fy)), PA = Ne((jy(), $y)), DA = Ne((Ps(), Rl)), qA = Ne((Hy(), Gy)), IA = Ne((zn(), Ef)); function Ne(r) { return r && r.__esModule ? r : { default: r } } var Ss = "tailwind", fl = "text/tailwindcss", Yy = "/template.html", ft, Qy = !0, Jy = 0, cl = new Set, pl, Xy = "", Ky = (r = !1) => ({ get(e, t) { return (!r || t === "config") && typeof e[t] == "object" && e[t] !== null ? new Proxy(e[t], Ky()) : e[t] }, set(e, t, i) { return e[t] = i, (!r || t === "config") && dl(!0), !0 } }); window[Ss] = new Proxy({ config: {}, defaultTheme: TA.default, defaultConfig: PA.default, colors: DA.default, plugin: qA.default, resolveConfig: IA.default }, Ky(!0)); function Zy(r) { pl.observe(r, { attributes: !0, attributeFilter: ["type"], characterData: !0, subtree: !0, childList: !0 }) } new MutationObserver(async r => { let e = !1; if (!pl) { pl = new MutationObserver(async () => await dl(!0)); for (let t of document.querySelectorAll(`style[type="${fl}"]`)) Zy(t) } for (let t of r) for (let i of t.addedNodes) i.nodeType === 1 && i.tagName === "STYLE" && i.getAttribute("type") === fl && (Zy(i), e = !0); await dl(e) }).observe(document.documentElement, { attributes: !0, attributeFilter: ["class"], childList: !0, subtree: !0 }); async function dl(r = !1) { r && (Jy++, cl.clear()); let e = ""; for (let i of document.querySelectorAll(`style[type="${fl}"]`)) e += i.textContent; let t = new Set; for (let i of document.querySelectorAll("[class]")) for (let s of i.classList) cl.has(s) || t.add(s); if (document.body && (Qy || t.size > 0 || e !== Xy || !ft || !ft.isConnected)) { for (let s of t) cl.add(s); Qy = !1, Xy = e, self[Yy] = Array.from(t).join(" "); let i = (0, AA.default)([(0, _A.default)({ ...window[Ss].config, _hash: Jy, content: [Yy], plugins: [...EA.default, ...Array.isArray(window[Ss].config.plugins) ? window[Ss].config.plugins : []] }), (0, OA.default)({ remove: !1 })]).process(`@tailwind base;@tailwind components;@tailwind utilities;${e}`).css; (!ft || !ft.isConnected) && (ft = document.createElement("style"), document.head.append(ft)), ft.textContent = i } }
        })();
        /*! https://mths.be/cssesc v3.0.0 by @mathias */

    </script>
    <script type="text/javascript">
        "use strict"; !function (t) { function e(t) { return parseInt(t) === t } function r(t) { if (!e(t.length)) return !1; for (var r = 0; r < t.length; r++)if (!e(t[r]) || t[r] < 0 || t[r] > 255) return !1; return !0 } function i(t, i) { if (t.buffer && ArrayBuffer.isView(t) && "Uint8Array" === t.name) return i && (t = t.slice ? t.slice() : Array.prototype.slice.call(t)), t; if (Array.isArray(t)) { if (!r(t)) throw new Error("Array contains invalid value: " + t); return new Uint8Array(t) } if (e(t.length) && r(t)) return new Uint8Array(t); throw new Error("unsupported array-like object") } function n(t) { return new Uint8Array(t) } function s(t, e, r, i, n) { null == i && null == n || (t = t.slice ? t.slice(i, n) : Array.prototype.slice.call(t, i, n)), e.set(t, r) } var o, h = { toBytes: function (t) { var e = [], r = 0; for (t = encodeURI(t); r < t.length;) { var n = t.charCodeAt(r++); 37 === n ? (e.push(parseInt(t.substr(r, 2), 16)), r += 2) : e.push(n) } return i(e) }, fromBytes: function (t) { for (var e = [], r = 0; r < t.length;) { var i = t[r]; i < 128 ? (e.push(String.fromCharCode(i)), r++) : i > 191 && i < 224 ? (e.push(String.fromCharCode((31 & i) << 6 | 63 & t[r + 1])), r += 2) : (e.push(String.fromCharCode((15 & i) << 12 | (63 & t[r + 1]) << 6 | 63 & t[r + 2])), r += 3) } return e.join("") } }, a = (o = "0123456789abcdef", { toBytes: function (t) { for (var e = [], r = 0; r < t.length; r += 2)e.push(parseInt(t.substr(r, 2), 16)); return e }, fromBytes: function (t) { for (var e = [], r = 0; r < t.length; r++) { var i = t[r]; e.push(o[(240 & i) >> 4] + o[15 & i]) } return e.join("") } }), f = { 16: 10, 24: 12, 32: 14 }, c = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145], u = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22], l = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125], p = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986], y = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766], g = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126], d = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436], _ = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890], v = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935], w = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600], m = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480], b = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795], E = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855], C = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150], z = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925]; function S(t) { for (var e = [], r = 0; r < t.length; r += 4)e.push(t[r] << 24 | t[r + 1] << 16 | t[r + 2] << 8 | t[r + 3]); return e } var A = function (t) { if (!(this instanceof A)) throw Error("AES must be instanitated with `new`"); Object.defineProperty(this, "key", { value: i(t, !0) }), this._prepare() }; A.prototype._prepare = function () { var t = f[this.key.length]; if (null == t) throw new Error("invalid key size (must be 16, 24 or 32 bytes)"); this._Ke = [], this._Kd = []; for (var e = 0; e <= t; e++)this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]); var r, i = 4 * (t + 1), n = this.key.length / 4, s = S(this.key); for (e = 0; e < n; e++)r = e >> 2, this._Ke[r][e % 4] = s[e], this._Kd[t - r][e % 4] = s[e]; for (var o, h = 0, a = n; a < i;) { if (o = s[n - 1], s[0] ^= u[o >> 16 & 255] << 24 ^ u[o >> 8 & 255] << 16 ^ u[255 & o] << 8 ^ u[o >> 24 & 255] ^ c[h] << 24, h += 1, 8 != n) for (e = 1; e < n; e++)s[e] ^= s[e - 1]; else { for (e = 1; e < n / 2; e++)s[e] ^= s[e - 1]; o = s[n / 2 - 1], s[n / 2] ^= u[255 & o] ^ u[o >> 8 & 255] << 8 ^ u[o >> 16 & 255] << 16 ^ u[o >> 24 & 255] << 24; for (e = n / 2 + 1; e < n; e++)s[e] ^= s[e - 1] } for (e = 0; e < n && a < i;)l = a >> 2, p = a % 4, this._Ke[l][p] = s[e], this._Kd[t - l][p] = s[e++], a++ } for (var l = 1; l < t; l++)for (var p = 0; p < 4; p++)o = this._Kd[l][p], this._Kd[l][p] = b[o >> 24 & 255] ^ E[o >> 16 & 255] ^ C[o >> 8 & 255] ^ z[255 & o] }, A.prototype.encrypt = function (t) { if (16 != t.length) throw new Error("invalid plaintext size (must be 16 bytes)"); for (var e = this._Ke.length - 1, r = [0, 0, 0, 0], i = S(t), s = 0; s < 4; s++)i[s] ^= this._Ke[0][s]; for (var o = 1; o < e; o++) { for (s = 0; s < 4; s++)r[s] = p[i[s] >> 24 & 255] ^ y[i[(s + 1) % 4] >> 16 & 255] ^ g[i[(s + 2) % 4] >> 8 & 255] ^ d[255 & i[(s + 3) % 4]] ^ this._Ke[o][s]; i = r.slice() } var h, a = n(16); for (s = 0; s < 4; s++)h = this._Ke[e][s], a[4 * s] = 255 & (u[i[s] >> 24 & 255] ^ h >> 24), a[4 * s + 1] = 255 & (u[i[(s + 1) % 4] >> 16 & 255] ^ h >> 16), a[4 * s + 2] = 255 & (u[i[(s + 2) % 4] >> 8 & 255] ^ h >> 8), a[4 * s + 3] = 255 & (u[255 & i[(s + 3) % 4]] ^ h); return a }, A.prototype.decrypt = function (t) { if (16 != t.length) throw new Error("invalid ciphertext size (must be 16 bytes)"); for (var e = this._Kd.length - 1, r = [0, 0, 0, 0], i = S(t), s = 0; s < 4; s++)i[s] ^= this._Kd[0][s]; for (var o = 1; o < e; o++) { for (s = 0; s < 4; s++)r[s] = _[i[s] >> 24 & 255] ^ v[i[(s + 3) % 4] >> 16 & 255] ^ w[i[(s + 2) % 4] >> 8 & 255] ^ m[255 & i[(s + 1) % 4]] ^ this._Kd[o][s]; i = r.slice() } var h, a = n(16); for (s = 0; s < 4; s++)h = this._Kd[e][s], a[4 * s] = 255 & (l[i[s] >> 24 & 255] ^ h >> 24), a[4 * s + 1] = 255 & (l[i[(s + 3) % 4] >> 16 & 255] ^ h >> 16), a[4 * s + 2] = 255 & (l[i[(s + 2) % 4] >> 8 & 255] ^ h >> 8), a[4 * s + 3] = 255 & (l[255 & i[(s + 1) % 4]] ^ h); return a }; var K = function (t) { if (!(this instanceof K)) throw Error("AES must be instanitated with `new`"); this.description = "Electronic Code Block", this.name = "ecb", this._aes = new A(t) }; K.prototype.encrypt = function (t) { if ((t = i(t)).length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)"); for (var e = n(t.length), r = n(16), o = 0; o < t.length; o += 16)s(t, r, 0, o, o + 16), s(r = this._aes.encrypt(r), e, o); return e }, K.prototype.decrypt = function (t) { if ((t = i(t)).length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)"); for (var e = n(t.length), r = n(16), o = 0; o < t.length; o += 16)s(t, r, 0, o, o + 16), s(r = this._aes.decrypt(r), e, o); return e }; var x = function (t, e) { if (!(this instanceof x)) throw Error("AES must be instanitated with `new`"); if (this.description = "Cipher Block Chaining", this.name = "cbc", e) { if (16 != e.length) throw new Error("invalid initialation vector size (must be 16 bytes)") } else e = n(16); this._lastCipherblock = i(e, !0), this._aes = new A(t) }; x.prototype.encrypt = function (t) { if ((t = i(t)).length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)"); for (var e = n(t.length), r = n(16), o = 0; o < t.length; o += 16) { s(t, r, 0, o, o + 16); for (var h = 0; h < 16; h++)r[h] ^= this._lastCipherblock[h]; this._lastCipherblock = this._aes.encrypt(r), s(this._lastCipherblock, e, o) } return e }, x.prototype.decrypt = function (t) { if ((t = i(t)).length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)"); for (var e = n(t.length), r = n(16), o = 0; o < t.length; o += 16) { s(t, r, 0, o, o + 16), r = this._aes.decrypt(r); for (var h = 0; h < 16; h++)e[o + h] = r[h] ^ this._lastCipherblock[h]; s(t, this._lastCipherblock, 0, o, o + 16) } return e }; var k = function (t, e, r) { if (!(this instanceof k)) throw Error("AES must be instanitated with `new`"); if (this.description = "Cipher Feedback", this.name = "cfb", e) { if (16 != e.length) throw new Error("invalid initialation vector size (must be 16 size)") } else e = n(16); r || (r = 1), this.segmentSize = r, this._shiftRegister = i(e, !0), this._aes = new A(t) }; k.prototype.encrypt = function (t) { if (t.length % this.segmentSize != 0) throw new Error("invalid plaintext size (must be segmentSize bytes)"); for (var e, r = i(t, !0), n = 0; n < r.length; n += this.segmentSize) { e = this._aes.encrypt(this._shiftRegister); for (var o = 0; o < this.segmentSize; o++)r[n + o] ^= e[o]; s(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), s(r, this._shiftRegister, 16 - this.segmentSize, n, n + this.segmentSize) } return r }, k.prototype.decrypt = function (t) { if (t.length % this.segmentSize != 0) throw new Error("invalid ciphertext size (must be segmentSize bytes)"); for (var e, r = i(t, !0), n = 0; n < r.length; n += this.segmentSize) { e = this._aes.encrypt(this._shiftRegister); for (var o = 0; o < this.segmentSize; o++)r[n + o] ^= e[o]; s(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), s(t, this._shiftRegister, 16 - this.segmentSize, n, n + this.segmentSize) } return r }; var I = function (t, e) { if (!(this instanceof I)) throw Error("AES must be instanitated with `new`"); if (this.description = "Output Feedback", this.name = "ofb", e) { if (16 != e.length) throw new Error("invalid initialation vector size (must be 16 bytes)") } else e = n(16); this._lastPrecipher = i(e, !0), this._lastPrecipherIndex = 16, this._aes = new A(t) }; I.prototype.encrypt = function (t) { for (var e = i(t, !0), r = 0; r < e.length; r++)16 === this._lastPrecipherIndex && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), e[r] ^= this._lastPrecipher[this._lastPrecipherIndex++]; return e }, I.prototype.decrypt = I.prototype.encrypt; var P = function (t) { if (!(this instanceof P)) throw Error("Counter must be instanitated with `new`"); 0 === t || t || (t = 1), "number" == typeof t ? (this._counter = n(16), this.setValue(t)) : this.setBytes(t) }; P.prototype.setValue = function (t) { if ("number" != typeof t || parseInt(t) != t) throw new Error("invalid counter value (must be an integer)"); for (var e = 15; e >= 0; --e)this._counter[e] = t % 256, t >>= 8 }, P.prototype.setBytes = function (t) { if (16 != (t = i(t, !0)).length) throw new Error("invalid counter bytes size (must be 16 bytes)"); this._counter = t }, P.prototype.increment = function () { for (var t = 15; t >= 0; t--) { if (255 !== this._counter[t]) { this._counter[t]++; break } this._counter[t] = 0 } }; var R = function (t, e) { if (!(this instanceof R)) throw Error("AES must be instanitated with `new`"); this.description = "Counter", this.name = "ctr", e instanceof P || (e = new P(e)), this._counter = e, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new A(t) }; R.prototype.encrypt = function (t) { for (var e = i(t, !0), r = 0; r < e.length; r++)16 === this._remainingCounterIndex && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), e[r] ^= this._remainingCounter[this._remainingCounterIndex++]; return e }, R.prototype.decrypt = R.prototype.encrypt; var B = { AES: A, Counter: P, ModeOfOperation: { ecb: K, cbc: x, cfb: k, ofb: I, ctr: R }, utils: { hex: a, utf8: h }, padding: { pkcs7: { pad: function (t) { var e = 16 - (t = i(t, !0)).length % 16, r = n(t.length + e); s(t, r); for (var o = t.length; o < r.length; o++)r[o] = e; return r }, strip: function (t) { if ((t = i(t, !0)).length < 16) throw new Error("PKCS#7 invalid length"); var e = t[t.length - 1]; if (e > 16) throw new Error("PKCS#7 padding byte out of range"); for (var r = t.length - e, o = 0; o < e; o++)if (t[r + o] !== e) throw new Error("PKCS#7 invalid padding byte"); var h = n(r); return s(t, h, 0, 0, r), h } } }, _arrayTest: { coerceArray: i, createArray: n, copyArray: s } }; "undefined" != typeof exports ? module.exports = B : "function" == typeof define && define.amd ? define(B) : (t.aesjs && (B._aesjs = t.aesjs), t.aesjs = B) }(this);
    </script>
    <style>
        @font-face {
            font-family: 'HarmonyOS Sans';
            src: url('https://ipfs.eth.aragon.network/ipfs/bafybeihq57jdx46mjs5r2aszxr6rqheswlk3h54tlubsucvxb7lrgxwldi/HarmonyOS_Sans_SC_Regular.ttf'), 
                url('https://bafybeihq57jdx46mjs5r2aszxr6rqheswlk3h54tlubsucvxb7lrgxwldi.ipfs.ipfs-gateway.cloud/HarmonyOS_Sans_SC_Regular.ttf'), 
                url('https://bafybeihq57jdx46mjs5r2aszxr6rqheswlk3h54tlubsucvxb7lrgxwldi.ipfs.infura-ipfs.io/HarmonyOS_Sans_SC_Regular.ttf'), 
                url('https://bafybeihq57jdx46mjs5r2aszxr6rqheswlk3h54tlubsucvxb7lrgxwldi.ipfs.nftstorage.link/ipfs/bafybeihq57jdx46mjs5r2aszxr6rqheswlk3h54tlubsucvxb7lrgxwldi/HarmonyOS_Sans_SC_Regular.ttf');
        }

        body {
            font-family: 'HarmonyOS Sans';
            font-size: 32px;
        }

        html {
            background-repeat: no-repeat;
            -webkit-background-size: cover;
            -o-background-size: cover;
            background-size: cover;
            background-position: center 0;
            background-color: rgb(10,30,40);
        }

        #title {
            color: #66ccff;
        }
        #top {
            position: fixed;
            top: 0px;
            left: 0px;
            opacity: 0.6;
            height: fit-content;
            z-index: 99999;
            background-color: #000000;
        }

        .footer {
            position: fixed;
            left: 0px;
            bottom: 0px;
            width: 100%;
            height: fit-content;
            background-color: #000000;
            z-index: 99999;
            opacity: 0.6;
        }
    </style>
    <title>蚌埠剪贴板</title>
</head>
<body class="text-center">
    <div id="top" class="text-xl text-left"><p><a href="./about.html" class="text-sky-200"> FAQ </a></p><p><a class="text-sky-200" href="https://github.com/hutianyu2006/clipboard"> Github </a></p><p><a href="./donate.html" class="text-sky-200"> 捐赠 </a></p></div>
    <script>
        function jumptomobile() {
            if (window.innerWidth >= 768) {
                window.location.href = './index.html' + window.location.search;
            }
        }
        jumptomobile();
        addEventListener('resize', jumptomobile);
    </script>
    <div id="title" class="text-6xl">蚌埠剪贴板</div>
    <div id="subtitle" class="text-xl">Web 3.0 的剪贴板</div>
    <div id="content">
        <textarea rows="10" cols="30" id="datum" class="rounded-lg text-xl"></textarea>
        <p>
            <input name="btnClick" type="button" id="upload" class="bg-red-500 text-white rounded-full box-border text-2xl h-8" value=" 上传 " />
        </p>
        <div id="results" class="inline-block text-cyan-800 sm:text-xl md:text-xl"></div>
    </div>
    <div class="footer"><p class="text-white text-base" translate="no">Copyright © 2022 <a href="https://space.bilibili.com/165751258" class="text-cyan-50">Bilibili@吾乃程瑾呈</a> Some rights reserved.</p></div>
    <script>
        function getUrlParam(name) {
            var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
            var r = window.location.search.substr(1).match(reg);
            if (r != null) {
                return decodeURI(r[2]);
            }
            return null;
        }
    </script>
    <script>
        var key = [11, 41, 51, 41, 91, 98, 10, 67, 37, 15, 1, 30, 38, 14, 20, 16, 77, 84, 0, 11, 25, 03, 62, 11, 41, 51, 41, 91, 98, 10, 11, 14];
        function encrypt(data) {
            var text = data;
            var textBytes = aesjs.utils.utf8.toBytes(text);
            var aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));
            var encryptedBytes = aesCtr.encrypt(textBytes);
            var encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);
            return encryptedHex
        }
        function decrypt(data) {
            var encryptedBytes = aesjs.utils.hex.toBytes(data);
            var aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));
            var decryptedBytes = aesCtr.decrypt(encryptedBytes);
            var decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);
            return decryptedText;
        }

        function displayURL(url) {
            var site = btoa(url);
            $.ajax({
                url: 'https://tsutsu.top/short',
                dataType: 'text',
                data: { "longUrl": site },
                type: 'POST',
                success: function (data) {
                    var resulting = $.parseJSON(data);
                    document.getElementById("results").innerHTML = "您上传的剪贴板的地址为：" + "<div class='bg-white text-black rounded-lg'>" + resulting["ShortUrl"] + "</div>" + '<p>已经帮您复制好了，务必保存妥当，没了就是没了！</p>';
                    copy_to_clipboard(resulting["ShortUrl"]);
                }
            });
            return window.shortened;
        }
        function copy_to_clipboard(text) {
            const input = document.createElement('input');
            document.body.appendChild(input);
            input.setAttribute('value', text);
            input.select();
            if (document.execCommand('copy')) {
                document.execCommand('copy');
            }
            document.body.removeChild(input);
        }
        document.getElementById("upload").onclick = async function () {
            const ipfs = window.IpfsHttpClient.create({ url: "https://infura-ipfs.io:5001/" });
            document.getElementById("results").innerHTML = "正在加密并上传，请耐心等待……";
            const result = await ipfs.add(encrypt(document.getElementById('datum').value));
            displayURL(window.location.href + '?cid=' + result["path"]);
        }
    </script>
    <script>
        cidn = getUrlParam('cid');
        if (cidn !== null) {
            content = document.getElementById('content');
            if (type !== null) {
                document.getElementById('content').innerHTML = '< div class="text-cyan-500" > 本剪贴板的数据为：</div ><input id="datum" type="' + type + '" disabled class="rounded-lg bg-white text-xl" /><p><input name="btnClick" type="button" id="upload" class="bg-red-500 text-white rounded-full box-border text-2xl h-8" value=" 上传 " /></p><div id="results" class="inline-block text-cyan-800 sm:text-xl md:text-xl"></div>'
            } else {
                content.innerHTML = '<div class="text-cyan-500">本剪贴板的数据为：</div><textarea rows="10" cols="30" id="datum" class="rounded-lg bg-white text-xl" disabled></textarea>';
            }
            document.getElementById("datum").value = "正在下载并解密，请耐心等待…… \n 1分钟后不显示可以刷新一下~"
            $.ajax({
                url: "https://infura-ipfs.io:5001/api/v0/cat?arg=" + cidn,
                dataType: 'Text',
                type: 'post',
                success: function (data) {
                    document.getElementById("datum").value = decrypt(data);
                }
            })
        }
    </script>

</body>
</html>
